var tipuesearch = {"pages":[{"text":"FOSSIL FOSSIL FOSSIL, FOrtran Stereo (si) Litography parser FOSSIL is a pure Fortran (KISS) library for IO and manipulation of STL (Stereo Litography) files for modern (2003+) Fortran projects; FOSSIL is Fortran 2003+ standard compliant; FOSSIL is OOP designed; FOSSIL is TDD designed; FOSSIL is a Free, Open Source Project. Issues Compiler Support What is FOSSIL? | Main features | Copyrights | Documentation | A Taste of FOSSIL What is FOSSIL? FOSSIL is a pure Fortran (KISS) library for IO and manipulation of STL (Stereo Litography) files for modern (2003+) Fortran projects. FOSSIL provides a simple API to IO STL files and also to manipulate the triangulated surface contained into the STL file. the dragon STL test (src/tests/dragon.stl) is composed by 6588 triangular facets. The signed distance computation on a uniform\ngrid of 64&#94;3 is accelerated by a factor of 7x using AABB algorithm with respect the simple brute force. Go to Top Main features User-friendly methods for IO STL files: input: automatic guessing of file format (ASCII or BINARY); load STL file effortless; output: save STL file effortless; powerful surface analysis and manipulation: build facets connectivity; sanitize normals: reverse normals: make normals consistent: compute volume; rotate facets; translate facets; mirror facets; resize (scale) facets; compute minimal distance: square distance; square root distance; signed distance: by means of solid angle computation; by means of rays intersection count; AABB (Axis-Aligned Bounding Box) tree acceleration with user defined refinement levels; point-in-polyhedra test: by means of solid angle computation; by means of rays intersection count; fill holes; check surface watertight; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights FOSSIL is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOSSIL is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOSSIL documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FOSSIL FOSSIL is an KISS library: simple load effortless load of file (with STL surface analysis) use fossil type ( file_stl_object ) :: file_stl ! STL file handler. call file_stl % initialize ( file_name = 'cube.stl' ) call file_stl % load_from_file ( guess_format = . true .) print STL statistics print main informations of STL print '(A)' , file_stl % statistics () upon exection will print something like Mesh_1\nfile name:   src/tests/cube.stl\nfile format: ascii\nX extents: [ 0 .000000000000000E+000, +0.100000000000000E+001 ] Y extents: [ 0 .000000000000000E+000, +0.100000000000000E+001 ] Z extents: [ 0 .000000000000000E+000, +0.100000000000000E+001 ] volume: -0.100000000000000E+001\nnumber of facets: +12 sanitiza normals make normals consistent call file_stl % sanitize_normals simple manipulations simply manipulate geometry call file_stl % resize ( factor = 3.4 * ex + 2 * ey + 0.5 * ez ) ! ex, ey, ez being axis versors call file_stl % resize ( x = 0.5 , z = 1.2 ) ! scale only x and z axis call file_stl % mirror ( normal = ex ) ! mirror respect yz-plane call file_stl % mirror ( normal = ex + ey ) ! mirror respect plane with normal ex+ey call file_stl % mirror ( matrix = matrix ) ! mirror by a given mirroring matrix call file_stl % rotate ( axis = ex , angle = 1.57 ) ! rotate around x axis by pi/2 call file_stl % rotate ( matrix = matrix ) ! rotati by a given rotating matrix call file_stl % translate ( delta = 3 * ex + 2 * ey + 0.5 * ez ) ! translate by a vectorial delta call file_stl % translate ( x = 0.5 , z = 1.2 ) ! translate by only x and z delta Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FOSSIL "},{"text":"FOSSIL, facet class definition. This File Depends On sourcefile~~fossil_facet_object.f90~~EfferentGraph sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil_facet_object.f90~~AfferentGraph sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_facet_objectf90AfferentGraph = svgPanZoom('#sourcefilefossil_facet_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_facet_object Source Code fossil_facet_object.f90 Source Code !< FOSSIL, facet class definition. module fossil_facet_object !< FOSSIL, facet class definition. use fossil_utils , only : EPS , FRLEN use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : FR4P , I2P , I4P , R4P , R8P , str , ZeroR8P use vecfor , only : angle_R8P , face_normal3_R8P , mirror_matrix_R8P , normL2_R8P , rotation_matrix_R8P , vector_R8P implicit none private public :: facet_object type :: facet_object !< FOSSIL, facet class. type ( vector_R8P ) :: normal !< Facet (outward) normal (versor), `(v2-v1).cross.(v3-v1)`. type ( vector_R8P ) :: vertex_1 !< Facet vertex 1. type ( vector_R8P ) :: vertex_2 !< Facet vertex 2. type ( vector_R8P ) :: vertex_3 !< Facet vertex 3. ! metrix ! triangle plane parametric equation: T(s,t) = B + s*E12 + t*E13 type ( vector_R8P ) :: E12 !< Edge 1-2, `V2-V1`. type ( vector_R8P ) :: E13 !< Edge 1-3, `V3-V1`. real ( R8P ) :: a = 0._R8P !< `E12.dot.E12`. real ( R8P ) :: b = 0._R8P !< `E12.dot.E13`. real ( R8P ) :: c = 0._R8P !< `E13.dot.E13`. real ( R8P ) :: det = 0._R8P !< `a*c - b*b`. ! triangle plane equation: nx*x + ny*y + nz*z - d = 0, normal == [nx, ny, nz] real ( R8P ) :: d = 0._R8P !< `normal.dot.vertex_1` ! auxiliary type ( vector_R8P ) :: bb ( 2 ) !< Axis-aligned bounding box (AABB), bb(1)=min, bb(2)=max. ! connectivity integer ( I4P ) :: id !< Facet global ID. integer ( I4P ) :: fcon_edge_12 = 0_I4P !< Connected face ID along edge 1-2. integer ( I4P ) :: fcon_edge_23 = 0_I4P !< Connected face ID along edge 2-3. integer ( I4P ) :: fcon_edge_31 = 0_I4P !< Connected face ID along edge 3-1. integer ( I4P ), allocatable :: vertex_1_occurrence (:) !< List of vertex 1 \"occurrencies\", list of facets global ID containing it. integer ( I4P ), allocatable :: vertex_2_occurrence (:) !< List of vertex 2 \"occurrencies\", list of facets global ID containing it. integer ( I4P ), allocatable :: vertex_3_occurrence (:) !< List of vertex 3 \"occurrencies\", list of facets global ID containing it. contains ! public methods procedure , pass ( self ) :: add_vertex_occurrence !< Add vertex occurence. procedure , pass ( self ) :: check_normal !< Check normal consistency. procedure , pass ( self ) :: check_vertices_occurrencies !< Check if vertices of facet are *identical* to ones of other facet. procedure , pass ( self ) :: compute_metrix !< Compute local (plane) metrix. procedure , pass ( self ) :: compute_normal !< Compute normal by means of vertices data. procedure , pass ( self ) :: destroy !< Destroy facet. procedure , pass ( self ) :: distance !< Compute the (unsigned, squared) distance from a point to facet. procedure , pass ( self ) :: do_ray_intersect !< Return true if facet is intersected by a ray. procedure , pass ( self ) :: initialize !< Initialize facet. procedure , pass ( self ) :: load_from_file_ascii !< Load facet from ASCII file. procedure , pass ( self ) :: load_from_file_binary !< Load facet from binary file. procedure , pass ( self ) :: make_normal_consistent !< Make normal of other facet consistent with self. generic :: mirror => mirror_by_normal , & mirror_by_matrix !< Mirror facet. procedure , pass ( self ) :: reverse_normal !< Reverse facet normal. procedure , pass ( self ) :: resize !< Resize (scale) facet by x or y or z or vectorial factors. generic :: rotate => rotate_by_axis_angle , & rotate_by_matrix !< Rotate facet. procedure , pass ( self ) :: save_into_file_ascii !< Save facet into ASCII file. procedure , pass ( self ) :: save_into_file_binary !< Save facet into binary file. procedure , pass ( self ) :: solid_angle !< Return the (projected) solid angle of the facet with respect point. procedure , pass ( self ) :: tetrahedron_volume !< Return the volume of tetrahedron built by facet and a given apex. procedure , pass ( self ) :: translate !< Translate facet given vectorial delta. procedure , pass ( self ) :: update_connectivity !< Update facet connectivity. procedure , pass ( self ) :: vertex_global_id !< Return the vertex global id given the local one. ! operators generic :: assignment ( = ) => facet_assign_facet !< Overload `=`. ! private methods procedure , pass ( self ), private :: edge_connection_in_other_ref !< Return the edge of connection in the other reference. procedure , pass ( lhs ), private :: facet_assign_facet !< Operator `=`. procedure , pass ( self ), private :: flip_edge !< Flip facet edge. procedure , pass ( self ), private :: mirror_by_normal !< Mirror facet given normal of mirroring plane. procedure , pass ( self ), private :: mirror_by_matrix !< Mirror facet given matrix. procedure , pass ( self ), private :: rotate_by_axis_angle !< Rotate facet given axis and angle. procedure , pass ( self ), private :: rotate_by_matrix !< Rotate facet given matrix. endtype facet_object contains ! public methods elemental subroutine add_vertex_occurrence ( self , vertex_id , facet_id ) !< Add vertex occurrence. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: vertex_id !< Vertex ID in local numeration, 1, 2 or 3. integer ( I4P ), intent ( in ) :: facet_id !< Other facet ID containing vertex. select case ( vertex_id ) case ( 1 ) call add_occurrence ( occurrence = self % vertex_1_occurrence ) case ( 2 ) call add_occurrence ( occurrence = self % vertex_2_occurrence ) case ( 3 ) call add_occurrence ( occurrence = self % vertex_3_occurrence ) endselect contains pure subroutine add_occurrence ( occurrence ) !< Add new occurrence into a generic occurrencies array. integer ( I4P ), allocatable , intent ( inout ) :: occurrence (:) !< Occurrences array. integer ( I4P ), allocatable :: occurrence_tmp (:) !< Temporary occurences array. integer ( I4P ) :: no !< Occurrences number. if ( allocated ( occurrence )) then no = size ( occurrence , dim = 1 ) allocate ( occurrence_tmp ( 1 : no + 1 )) occurrence_tmp ( 1 : no ) = occurrence occurrence_tmp ( no + 1 ) = facet_id call move_alloc ( from = occurrence_tmp , to = occurrence ) else allocate ( occurrence ( 1 )) occurrence ( 1 ) = facet_id endif endsubroutine add_occurrence endsubroutine add_vertex_occurrence elemental function check_normal ( self ) result ( is_consistent ) !< Check normal consistency. class ( facet_object ), intent ( in ) :: self !< Facet. logical :: is_consistent !< Consistency check result. type ( vector_R8P ) :: normal !< Normal computed by means of vertices data. normal = face_normal3_R8P ( pt1 = self % vertex_1 , pt2 = self % vertex_2 , pt3 = self % vertex_3 , norm = 'y' ) is_consistent = (( abs ( normal % x - self % normal % x ) <= 2 * ZeroR8P ). and .& ( abs ( normal % y - self % normal % y ) <= 2 * ZeroR8P ). and .& ( abs ( normal % z - self % normal % z ) <= 2 * ZeroR8P )) endfunction check_normal pure subroutine check_vertices_occurrencies ( self , other ) !< Check if vertices of facet are *identical* (with tollerance) to the ones of other facet. !< !< If multiple occurrencies are found the counters are updated. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ), intent ( inout ) :: other !< Other facet. if ( check_pair ( self % vertex_1 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_1 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_1 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif if ( check_pair ( self % vertex_2 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_2 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_2 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif if ( check_pair ( self % vertex_3 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_3 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_3 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif contains pure function check_pair ( a , b ) !< Check equality of vertices pair. type ( vector_R8P ), intent ( in ) :: a , b !< Vertices pair. logical :: check_pair !< Check result. check_pair = (( abs ( a % x - b % x ) <= EPS ). and .( abs ( a % y - b % y ) <= EPS ). and .( abs ( a % z - b % z ) <= EPS )) endfunction check_pair endsubroutine check_vertices_occurrencies elemental subroutine compute_metrix ( self ) !< Compute local (plane) metrix. class ( facet_object ), intent ( inout ) :: self !< Facet. call self % compute_normal self % E12 = self % vertex_2 - self % vertex_1 self % E13 = self % vertex_3 - self % vertex_1 self % a = self % E12 . dot . self % E12 self % b = self % E12 . dot . self % E13 self % c = self % E13 . dot . self % E13 self % det = self % a * self % c - self % b * self % b self % d = self % normal . dot . self % vertex_1 self % bb ( 1 )% x = min ( self % vertex_1 % x , self % vertex_2 % x , self % vertex_3 % x ) self % bb ( 1 )% y = min ( self % vertex_1 % y , self % vertex_2 % y , self % vertex_3 % y ) self % bb ( 1 )% z = min ( self % vertex_1 % z , self % vertex_2 % z , self % vertex_3 % z ) self % bb ( 2 )% x = max ( self % vertex_1 % x , self % vertex_2 % x , self % vertex_3 % x ) self % bb ( 2 )% y = max ( self % vertex_1 % y , self % vertex_2 % y , self % vertex_3 % y ) self % bb ( 2 )% z = max ( self % vertex_1 % z , self % vertex_2 % z , self % vertex_3 % z ) endsubroutine compute_metrix elemental subroutine compute_normal ( self ) !< Compute normal by means of vertices data. !< !<```fortran !< type(facet_object) :: facet !< facet%vertex_1 = -0.231369_R4P * ex_R4P + 0.0226865_R4P * ey_R4P + 1._R4P * ez_R4P !< facet%vertex_2 = -0.227740_R4P * ex_R4P + 0.0245457_R4P * ey_R4P + 0._R4P * ez_R4P !< facet%vertex_2 = -0.235254_R4P * ex_R4P + 0.0201881_R4P * ey_R4P + 0._R4P * ez_R4P !< call facet%sanitize_normal !< print \"(3(F3.1,1X))\", facet%normal%x, facet%normal%y, facet%normal%z !<``` !=> -0.501673222 0.865057290 -2.12257713<<< class ( facet_object ), intent ( inout ) :: self !< Facet. self % normal = face_normal3_R8P ( pt1 = self % vertex_1 , pt2 = self % vertex_2 , pt3 = self % vertex_3 , norm = 'y' ) endsubroutine compute_normal elemental subroutine destroy ( self ) !< Destroy AABB. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ) :: fresh !< Fresh instance of facet. self = fresh endsubroutine destroy pure function distance ( self , point ) !< Compute the (unsigned, squared) distance from a point to the facet surface. !< !< @note Facet's metrix must be already computed. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: point !< Point. real ( R8P ) :: distance !< Closest distance from point to the facet. type ( vector_R8P ) :: V1P !< `vertex_1-point`. real ( R8P ) :: d , e , f , s , t , sq , tq !< Plane equation coefficients. real ( R8P ) :: tmp0 , tmp1 , numer , denom , invdet !< Temporary. associate ( a => self % a , b => self % b , c => self % c , det => self % det ) V1P = self % vertex_1 - point d = self % E12 . dot . V1P e = self % E13 . dot . V1P f = V1P . dot . V1P s = self % b * e - self % c * d t = self % b * d - self % a * e if ( s + t <= det ) then if ( s < 0._R8P ) then if ( t < 0._R8P ) then ! region 4 if ( e < 0._R8P ) then sq = 0._R8P if ( c >= - e ) then tq = - e / c else tq = 1._R8P endif else if ( d > 0._R8P ) then sq = 0._R8P else if ( a >= - d ) then sq = - d / a else sq = 1._R8P endif endif tq = 0._R8P endif else ! region 3 sq = 0._R8P if ( e >= 0._R8P ) then tq = 0._R8P else if ( - e >= c ) then tq = 1._R8P else tq = - e / c endif endif endif elseif ( t < 0._R8P ) then ! region 5 if ( d >= 0._R8P ) then sq = 0._R8P else if ( - d >= a ) then sq = 1._R8P else sq = - d / a endif endif tq = 0._R8P else ! region 0 invdet = 1._R8P / det sq = s * invdet tq = t * invdet endif else if ( s < 0._R8P ) then ! region 2 tmp0 = b + d tmp1 = c + e if ( tmp1 > tmp0 ) then numer = tmp1 - tmp0 denom = a - 2._R8P * b + c if ( numer >= denom ) then sq = 1._R8P else sq = numer / denom endif tq = 1._R8P - sq else sq = 0._R8P if ( tmp1 <= 0._R8P ) then tq = 1._R8P else if ( e >= 0._R8P ) then tq = 0._R8P else tq = - e / c endif endif endif elseif ( t < 0._R8P ) then ! region 6 tmp0 = a + d tmp1 = b + e if ( tmp0 > tmp1 ) then numer = b + d - c - e denom = a - 2._R8P * b + c if ( numer >= 0._R8P ) then sq = 0._R8P else if ( denom > - numer ) then sq = - numer / denom else sq = 1._R8P endif endif tq = 1._R8P - sq else if ( tmp0 <= 0._R8P ) then sq = 1._R8P else if ( d >= 0._R8P ) then sq = 0._R8P else sq = - d / a endif endif tq = 0._R8P endif else ! region 1 numer = c + e - b - d if ( numer <= 0._R8P ) then sq = 0._R8P else denom = a - 2._R8P * b + c if ( numer >= denom ) then sq = 1._R8P else sq = numer / denom endif endif tq = 1._R8P - sq endif endif distance = abs ( a * sq * sq + 2._R8P * b * sq * tq + c * tq * tq + 2._R8P * d * sq + 2._R8P * e * tq + f ) endassociate endfunction pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( intersect ) !< Return true if facet is intersected by ray from origin and oriented as ray direction vector. !< !< This based on Moller–Trumbore intersection algorithm. !< !< @note Facet's metrix must be already computed. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: intersect !< Intersection test result. type ( vector_R8P ) :: h , s , q !< Projection vectors. real ( R8P ) :: a , f , u , v , t !< Baricentric abscissa. intersect = . false . h = ray_direction . cross . self % E13 a = self % E12 . dot . h if (( a > - EPS ). and .( a < EPS )) return f = 1._R8P / a s = ray_origin - self % vertex_1 u = f * ( s . dot . h ) if (( u < 0._R8P ). or .( u > 1._R8P )) return q = s . cross . self % E12 v = f * ray_direction . dot . q if (( v < 0._R8P ). or .( u + v > 1._R8P )) return t = f * self % E13 . dot . q if ( t > EPS ) intersect = . true . endfunction do_ray_intersect elemental subroutine initialize ( self ) !< Initialize facet. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ) :: fresh !< Fresh instance of facet. self = fresh endsubroutine initialize subroutine load_from_file_ascii ( self , file_unit ) !< Load facet from ASCII file. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. call load_facet_record ( prefix = 'facet normal' , record = self % normal ) read ( file_unit , * ) ! outer loop call load_facet_record ( prefix = 'vertex' , record = self % vertex_1 ) call load_facet_record ( prefix = 'vertex' , record = self % vertex_2 ) call load_facet_record ( prefix = 'vertex' , record = self % vertex_3 ) read ( file_unit , * ) ! endloop read ( file_unit , * ) ! endfacet contains subroutine load_facet_record ( prefix , record ) !< Load a facet *record*, namely normal or vertex data. character ( * ), intent ( in ) :: prefix !< Record prefix string. type ( vector_R8P ), intent ( out ) :: record !< Record data. character ( FRLEN ) :: facet_record !< Facet record string buffer. integer ( I4P ) :: i !< Counter. read ( file_unit , '(A)' ) facet_record i = index ( string = facet_record , substring = prefix ) if ( i > 0 ) then read ( facet_record ( i + len ( prefix ):), * ) record % x , record % y , record % z else write ( stderr , '(A)' ) 'error: impossible to read \"' // prefix // '\" from file unit \"' // trim ( str ( file_unit )) // '\"!' endif endsubroutine load_facet_record endsubroutine load_from_file_ascii subroutine load_from_file_binary ( self , file_unit ) !< Load facet from binary file. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I2P ) :: padding !< Facet padding. real ( R4P ) :: triplet ( 3 ) !< Triplet record of R4P kind real. read ( file_unit ) triplet self % normal % x = real ( triplet ( 1 ), R8P ) ; self % normal % y = real ( triplet ( 2 ), R8P ) ; self % normal % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_1 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_1 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_1 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_2 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_2 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_2 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_3 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_3 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_3 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) padding endsubroutine load_from_file_binary pure subroutine make_normal_consistent ( self , edge_dir , other ) !< Make normal of other facet consistent with self. class ( facet_object ), intent ( in ) :: self !< Facet. character ( * ), intent ( in ) :: edge_dir !< Edge (in self numeration) along which other is connected. type ( facet_object ), intent ( inout ) :: other !< Other facet to make consistent with self. character ( len ( edge_dir )) :: edge_dir_other !< Edge (in self numeration) along which other is connected. type ( vector_R8P ) :: edge !< Edge of connection in the self reference. type ( vector_R8P ) :: edge_other !< Edge of connection in the other reference. call self % edge_connection_in_other_ref ( other = other , edge_dir = edge_dir_other , edge = edge_other ) ! get self edge select case ( edge_dir ) case ( 'edge_12' ) edge = self % vertex_2 - self % vertex_1 case ( 'edge_23' ) edge = self % vertex_3 - self % vertex_2 case ( 'edge_31' ) edge = self % vertex_1 - self % vertex_3 endselect if ( edge % dotproduct ( edge_other ) > 0 ) then ! other numeration is consistent, normal has wrong orientation call other % flip_edge ( edge_dir = edge_dir_other ) endif endsubroutine make_normal_consistent elemental subroutine resize ( self , factor , recompute_metrix ) !< Resize (scale) facet by x or y or z or vectorial factors. !< !< @note The name `scale` has not been used, it been a Fortran built-in. class ( facet_object ), intent ( inout ) :: self !< Facet type ( vector_R8P ), intent ( in ) :: factor !< Vectorial factor. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. self % vertex_1 = self % vertex_1 * factor self % vertex_2 = self % vertex_2 * factor self % vertex_3 = self % vertex_3 * factor if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine resize elemental subroutine reverse_normal ( self ) !< Reverse facet normal. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ) :: vertex !< Temporary vertex variable. call self % flip_edge ( edge_dir = 'edge_23' ) endsubroutine reverse_normal subroutine save_into_file_ascii ( self , file_unit ) !< Save facet into ASCII file. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '  facet normal ' , self % normal % x , ' ' , self % normal % y , ' ' , self % normal % z write ( file_unit , '(A)' ) '    outer loop' write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_1 % x , ' ' , self % vertex_1 % y , ' ' , self % vertex_1 % z write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_2 % x , ' ' , self % vertex_2 % y , ' ' , self % vertex_2 % z write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_3 % x , ' ' , self % vertex_3 % y , ' ' , self % vertex_3 % z write ( file_unit , '(A)' ) '    endloop' write ( file_unit , '(A)' ) '  endfacet' endsubroutine save_into_file_ascii subroutine save_into_file_binary ( self , file_unit ) !< Save facet into binary file. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. real ( R4P ) :: triplet ( 3 ) !< Triplet record of R4P kind real. triplet ( 1 ) = real ( self % normal % x , R4P ) ; triplet ( 2 ) = real ( self % normal % y , R4P ) ; triplet ( 3 ) = real ( self % normal % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_1 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_1 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_1 % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_2 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_2 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_2 % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_3 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_3 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_3 % z , R4P ) write ( file_unit ) triplet write ( file_unit ) 0_I2P endsubroutine save_into_file_binary pure function solid_angle ( self , point ) !< Return the (projected) solid angle of the facet with respect the point. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: point !< Point. real ( R8P ) :: solid_angle !< Solid angle. type ( vector_R8P ) :: R1 , R2 , R3 !< Edges from point to facet vertices. real ( R8P ) :: R1_norm , R2_norm , R3_norm !< Norms (L2) of edges from point to facet vertices. real ( R8P ) :: numerator !< Archtangent numerator. real ( R8P ) :: denominator !< Archtangent denominator. R1 = self % vertex_1 - point ; R1_norm = R1 % normL2 () R2 = self % vertex_2 - point ; R2_norm = R2 % normL2 () R3 = self % vertex_3 - point ; R3_norm = R3 % normL2 () numerator = R1 . dot .( R2 . cross . R3 ) denominator = R1_norm * R2_norm * R3_norm + ( R1 . dot . R2 ) * R3_norm + & ( R1 . dot . R3 ) * R2_norm + & ( R2 . dot . R3 ) * R1_norm solid_angle = 2._R8P * atan2 ( numerator , denominator ) endfunction solid_angle pure function tetrahedron_volume ( self , apex ) result ( volume ) !< Return the volume of tetrahedron built by facet and a given apex. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: apex !< Tetrahedron apex. real ( R8P ) :: volume !< Tetrahedron volume. type ( vector_R8P ) :: e12 !< Edge 1-2. type ( vector_R8P ) :: e13 !< Edge 1-3. e12 = self % vertex_2 - self % vertex_1 e13 = self % vertex_3 - self % vertex_1 volume = 0.5_R8P * normL2_R8P ( e12 ) * normL2_R8P ( e13 ) * sin ( angle_R8P ( e12 , e13 )) * & apex % distance_to_plane ( pt1 = self % vertex_1 , pt2 = self % vertex_2 , pt3 = self % vertex_3 ) / 3._R8P endfunction elemental subroutine translate ( self , delta , recompute_metrix ) !< Translate facet given vectorial delta. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: delta !< Translation delta. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. self % vertex_1 = self % vertex_1 + delta self % vertex_2 = self % vertex_2 + delta self % vertex_3 = self % vertex_3 + delta if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine translate pure subroutine update_connectivity ( self ) !< Update facet connectivity. !< !< @note Vertices occurrencies list must be already computed. class ( facet_object ), intent ( inout ) :: self !< Facet. self % fcon_edge_12 = facet_connected ( occurrence_1 = self % vertex_1_occurrence , occurrence_2 = self % vertex_2_occurrence ) self % fcon_edge_23 = facet_connected ( occurrence_1 = self % vertex_2_occurrence , occurrence_2 = self % vertex_3_occurrence ) self % fcon_edge_31 = facet_connected ( occurrence_1 = self % vertex_3_occurrence , occurrence_2 = self % vertex_1_occurrence ) contains pure function facet_connected ( occurrence_1 , occurrence_2 ) !< Return the facet ID connected by the edge. If no facet is found 0 is returned. !< !< @note Within two vertices occurrencies, namely one edge, there could be only two connected facets. integer ( I4P ), allocatable , intent ( in ) :: occurrence_1 (:) !< Occurrences list of vertex 1. integer ( I4P ), allocatable , intent ( in ) :: occurrence_2 (:) !< Occurrences list of vertex 2. integer ( I4P ) :: facet_connected !< ID of connected connected. integer ( I4P ) :: i1 , i2 !< Counter. facet_connected = 0 if ( allocated ( occurrence_1 ). and . allocated ( occurrence_2 )) then loop_1 : do i1 = 1 , size ( occurrence_1 , dim = 1 ) do i2 = 1 , size ( occurrence_2 , dim = 1 ) if ( occurrence_1 ( i1 ) == occurrence_2 ( i2 )) then facet_connected = occurrence_1 ( i1 ) exit loop_1 endif enddo enddo loop_1 endif endfunction facet_connected endsubroutine update_connectivity pure function vertex_global_id ( self , vertex_id ) !< Return the vertex global id given the local one. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: vertex_id !< Local vertex id. integer ( I4P ) :: vertex_global_id !< Gloval vertex id. vertex_global_id = ( self % id - 1 ) * 3 + vertex_id endfunction vertex_global_id ! private methods pure subroutine flip_edge ( self , edge_dir ) !< Flip facet edge. class ( facet_object ), intent ( inout ) :: self !< Facet. character ( * ), intent ( in ) :: edge_dir !< Edge to be flipped. integer ( I4P ) :: fcon !< Temporary facet connectiviy variable. select case ( edge_dir ) case ( 'edge_12' ) call flip_vertices ( a = self % vertex_1 , b = self % vertex_2 , & fcon_bc = self % fcon_edge_23 , fcon_ca = self % fcon_edge_31 , & vertex_a_occurrence = self % vertex_1_occurrence , vertex_b_occurrence = self % vertex_2_occurrence ) case ( 'edge_23' ) call flip_vertices ( a = self % vertex_2 , b = self % vertex_3 , & fcon_bc = self % fcon_edge_12 , fcon_ca = self % fcon_edge_31 , & vertex_a_occurrence = self % vertex_2_occurrence , vertex_b_occurrence = self % vertex_3_occurrence ) case ( 'edge_31' ) call flip_vertices ( a = self % vertex_3 , b = self % vertex_1 , & fcon_bc = self % fcon_edge_12 , fcon_ca = self % fcon_edge_23 , & vertex_a_occurrence = self % vertex_3_occurrence , vertex_b_occurrence = self % vertex_1_occurrence ) endselect call self % compute_metrix contains pure subroutine flip_vertices ( a , b , fcon_bc , fcon_ca , vertex_a_occurrence , vertex_b_occurrence ) !< Flip two vertices of facet. type ( vector_R8P ), intent ( inout ) :: a , b !< Vertices to be flipped. integer ( I4P ), intent ( inout ) :: fcon_bc !< Connected face ID along edge b-c. integer ( I4P ), intent ( inout ) :: fcon_ca !< Connected face ID along edge c-a. integer ( I4P ), allocatable , intent ( inout ) :: vertex_a_occurrence (:) !< List of vertex a \"occurrencies\". integer ( I4P ), allocatable , intent ( inout ) :: vertex_b_occurrence (:) !< List of vertex b \"occurrencies\". type ( vector_R8P ) :: vertex !< Temporary vertex variable. integer ( I4P ) :: fcon !< Temporary connected face ID. integer ( I4P ), allocatable :: vertex_occurrence (:) !< Temporary list of vertex \"occurrencies\". ! flip vertex vertex = a a = b b = vertex ! flip facet connectivity fcon = fcon_bc fcon_bc = fcon_ca fcon_ca = fcon ! flip vertex occurrences if ( allocated ( vertex_a_occurrence ). and . allocated ( vertex_a_occurrence )) then vertex_occurrence = vertex_a_occurrence vertex_a_occurrence = vertex_b_occurrence vertex_b_occurrence = vertex_occurrence elseif ( allocated ( vertex_a_occurrence )) then vertex_b_occurrence = vertex_a_occurrence deallocate ( vertex_a_occurrence ) elseif ( allocated ( vertex_b_occurrence )) then vertex_a_occurrence = vertex_b_occurrence deallocate ( vertex_b_occurrence ) endif endsubroutine flip_vertices endsubroutine flip_edge pure subroutine mirror_by_normal ( self , normal , recompute_metrix ) !< Mirror facet given normal of mirroring plane. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: normal !< Normal of mirroring plane. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % mirror_by_matrix ( matrix = mirror_matrix_R8P ( normal = normal )) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine mirror_by_normal pure subroutine mirror_by_matrix ( self , matrix , recompute_metrix ) !< Mirror facet given matrix (of mirroring). class ( facet_object ), intent ( inout ) :: self !< Facet. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Mirroring matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % vertex_1 % mirror ( matrix = matrix ) call self % vertex_2 % mirror ( matrix = matrix ) call self % vertex_3 % mirror ( matrix = matrix ) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine mirror_by_matrix pure subroutine rotate_by_axis_angle ( self , axis , angle , recompute_metrix ) !< Rotate facet given axis and angle. !< !< Angle must be in radiants. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: axis !< Axis of rotation. real ( R8P ), intent ( in ) :: angle !< Angle of rotation. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % rotate_by_matrix ( matrix = rotation_matrix_R8P ( axis = axis , angle = angle )) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine rotate_by_axis_angle pure subroutine rotate_by_matrix ( self , matrix , recompute_metrix ) !< Rotate facet given matrix (of ratation). class ( facet_object ), intent ( inout ) :: self !< Facet. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Rotation matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % vertex_1 % rotate ( matrix = matrix ) call self % vertex_2 % rotate ( matrix = matrix ) call self % vertex_3 % rotate ( matrix = matrix ) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine rotate_by_matrix ! `=` operator pure subroutine edge_connection_in_other_ref ( self , other , edge_dir , edge ) !< Return the edge of connection in the other reference. class ( facet_object ), intent ( in ) :: self !< Facet. type ( facet_object ), intent ( in ) :: other !< Other facet. character ( * ), intent ( out ) :: edge_dir !< Edge (in other numeration) along which self is connected. type ( vector_R8P ), intent ( out ) :: edge !< Edge (in other numeration) along which self is connected. if ( other % fcon_edge_12 == self % id ) then edge_dir = 'edge_12' edge = other % vertex_2 - other % vertex_1 elseif ( other % fcon_edge_23 == self % id ) then edge_dir = 'edge_23' edge = other % vertex_3 - other % vertex_2 elseif ( other % fcon_edge_31 == self % id ) then edge_dir = 'edge_31' edge = other % vertex_1 - other % vertex_3 endif endsubroutine edge_connection_in_other_ref pure subroutine facet_assign_facet ( lhs , rhs ) !< Operator `=`. class ( facet_object ), intent ( inout ) :: lhs !< Left hand side. type ( facet_object ), intent ( in ) :: rhs !< Right hand side. lhs % normal = rhs % normal lhs % vertex_1 = rhs % vertex_1 lhs % vertex_2 = rhs % vertex_2 lhs % vertex_3 = rhs % vertex_3 lhs % E12 = rhs % E12 lhs % E13 = rhs % E13 lhs % a = rhs % a lhs % b = rhs % b lhs % c = rhs % c lhs % d = rhs % d lhs % det = rhs % det lhs % bb = rhs % bb lhs % id = rhs % id lhs % fcon_edge_12 = rhs % fcon_edge_12 lhs % fcon_edge_23 = rhs % fcon_edge_23 lhs % fcon_edge_31 = rhs % fcon_edge_31 if ( allocated ( lhs % vertex_1_occurrence )) deallocate ( lhs % vertex_1_occurrence ) if ( allocated ( rhs % vertex_1_occurrence )) lhs % vertex_1_occurrence = rhs % vertex_1_occurrence if ( allocated ( lhs % vertex_2_occurrence )) deallocate ( lhs % vertex_2_occurrence ) if ( allocated ( rhs % vertex_2_occurrence )) lhs % vertex_2_occurrence = rhs % vertex_2_occurrence if ( allocated ( lhs % vertex_3_occurrence )) deallocate ( lhs % vertex_3_occurrence ) if ( allocated ( rhs % vertex_3_occurrence )) lhs % vertex_3_occurrence = rhs % vertex_3_occurrence endsubroutine facet_assign_facet endmodule fossil_facet_object","tags":"","loc":"sourcefile/fossil_facet_object.f90.html","title":"fossil_facet_object.f90 – FOSSIL"},{"text":"FOSSIL, Axis-Aligned Bounding Box (AABB) class definition. This File Depends On sourcefile~~fossil_aabb_object.f90~~EfferentGraph sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil_aabb_object.f90~~AfferentGraph sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 var pansourcefilefossil_aabb_objectf90AfferentGraph = svgPanZoom('#sourcefilefossil_aabb_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_aabb_object Source Code fossil_aabb_object.f90 Source Code !< FOSSIL, Axis-Aligned Bounding Box (AABB) class definition. module fossil_aabb_object !< FOSSIL, Axis-Aligned Bounding Box (AABB) class definition. use fossil_facet_object , only : facet_object use fossil_utils , only : EPS use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : FR8P , I4P , R8P , MaxR8P , str use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none private public :: aabb_object type :: aabb_object !< FOSSIL Axis-Aligned Bounding Box (AABB) class. type ( vector_R8P ) :: bmin !< Minimum point of AABB. type ( vector_R8P ) :: bmax !< Maximum point of AABB. integer ( I4P ) :: facets_number = 0 !< Facets number. type ( facet_object ), allocatable :: facet (:) !< Facets. contains ! public methods procedure , pass ( self ) :: add_facets !< Add facets to AABB. procedure , pass ( self ) :: closest_point !< Return closest point on AABB from point reference. procedure , pass ( self ) :: compute_octants !< Compute AABB octants. procedure , pass ( self ) :: destroy !< Destroy AABB. procedure , pass ( self ) :: distance !< Return the (square) distance from point to AABB. procedure , pass ( self ) :: distance_from_facets !< Return the (square) distance from point to AABB's facets. procedure , pass ( self ) :: do_ray_intersect !< Return true if AABB is intersected by ray. procedure , pass ( self ) :: has_facets !< Return true if AABB has facets. procedure , pass ( self ) :: initialize !< Initialize AABB. procedure , pass ( self ) :: is_inside !< Return the true if point is inside ABB. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB geometry into Tecplot ascii file. procedure , pass ( self ) :: save_facets_into_file_stl !< Save facets into file STL. procedure , pass ( self ) :: update_extents !< Update AABB bounding box extents. procedure , pass ( self ) :: vertex !< Return AABB vertices. ! operators generic :: assignment ( = ) => aabb_assign_aabb !< Overload `=`. procedure , pass ( lhs ), private :: aabb_assign_aabb !< Operator `=`. endtype aabb_object contains ! public methods subroutine add_facets ( self , facet ) !< Add facets to AABB. !< !< @note Previously stored facets are lost. !< !< @note Facets added to AABB are removed to facets list that is also returned. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), allocatable , intent ( inout ) :: facet (:) !< Facets list. integer ( I4P ) :: scratch_unit_add !< Scratch unit file for added facets. integer ( I4P ) :: scratch_unit_rem !< Scratch unit file for remaining facets. integer ( I4P ) :: rem_facets_number !< Remaining facets number. integer ( I4P ) :: f !< Counter. self % facets_number = 0 rem_facets_number = 0 if ( allocated ( self % facet )) deallocate ( self % facet ) open ( newunit = scratch_unit_add , status = 'scratch' , access = 'stream' , form = 'unformatted' ) open ( newunit = scratch_unit_rem , status = 'scratch' , access = 'stream' , form = 'unformatted' ) do f = 1 , size ( facet , dim = 1 ) if ( self % is_inside ( point = facet ( f )% vertex_1 ). and .& self % is_inside ( point = facet ( f )% vertex_2 ). and .& self % is_inside ( point = facet ( f )% vertex_3 )) then self % facets_number = self % facets_number + 1 call facet ( f )% save_into_file_binary ( file_unit = scratch_unit_add ) else rem_facets_number = rem_facets_number + 1 call facet ( f )% save_into_file_binary ( file_unit = scratch_unit_rem ) endif enddo if ( self % facets_number > 0 ) then allocate ( self % facet ( 1 : self % facets_number )) rewind ( unit = scratch_unit_add ) do f = 1 , self % facets_number call self % facet ( f )% load_from_file_binary ( file_unit = scratch_unit_add ) call self % facet ( f )% compute_metrix enddo endif close ( unit = scratch_unit_add ) deallocate ( facet ) if ( rem_facets_number > 0 ) then allocate ( facet ( 1 : rem_facets_number )) rewind ( unit = scratch_unit_rem ) do f = 1 , rem_facets_number call facet ( f )% load_from_file_binary ( file_unit = scratch_unit_rem ) call facet ( f )% compute_metrix enddo endif close ( unit = scratch_unit_rem ) endsubroutine add_facets pure function closest_point ( self , point ) result ( closest ) !< Return closest point on (or in) AABB from point reference. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. type ( vector_R8P ) :: closest !< Closest point on (on in) aabb to point. closest = point closest % x = max ( closest % x , self % bmin % x ) ; closest % x = min ( closest % x , self % bmax % x ) closest % y = max ( closest % y , self % bmin % y ) ; closest % y = min ( closest % y , self % bmax % y ) closest % z = max ( closest % z , self % bmin % z ) ; closest % z = min ( closest % z , self % bmax % z ) endfunction closest_point pure subroutine compute_octants ( self , octant ) !< Return AABB octants. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( aabb_object ), intent ( out ) :: octant ( 8 ) !< AABB octants. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: o !< Counter. vertex = self % vertex () octant ( 1 )% bmin = self % bmin ; octant ( 1 )% bmax = 0.5_R8P * ( self % bmin + self % bmax ) octant ( 8 )% bmin = octant ( 1 )% bmax ; octant ( 8 )% bmax = self % bmax do o = 2 , 7 ! loop over remaining octants octant ( o )% bmin = 0.5_R8P * ( self % bmin + vertex ( o )) ; octant ( o )% bmax = 0.5_R8P * ( vertex ( o ) + self % bmax ) enddo endsubroutine compute_octants elemental subroutine destroy ( self ) !< Destroy AABB. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( aabb_object ) :: fresh !< Fresh instance of AABB box. self = fresh endsubroutine destroy pure function distance ( self , point ) !< Return the (square) distance from point to AABB. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB. real ( R8P ) :: dx , dy , dz !< Distance components. dx = max ( self % bmin % x - point % x , 0._R8P , point % x - self % bmax % x ) dy = max ( self % bmin % y - point % y , 0._R8P , point % y - self % bmax % y ) dz = max ( self % bmin % z - point % z , 0._R8P , point % z - self % bmax % z ) distance = dx * dx + dy * dy + dz * dz endfunction distance pure function distance_from_facets ( self , point ) result ( distance ) !< Return the (square) distance from point to AABB's facets. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB's facets. real ( R8P ) :: distance_ !< Distance from point to AABB's facets, local variable. integer ( I4P ) :: f !< Counter. distance = MaxR8P if ( self % facets_number > 0 ) then do f = 1 , self % facets_number distance_ = self % facet ( f )% distance ( point = point ) if ( abs ( distance_ ) <= abs ( distance )) distance = distance_ enddo endif endfunction distance_from_facets pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( do_intersect ) !< Return true if AABB is intersected by ray from origin and oriented as ray direction vector. class ( aabb_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: do_intersect !< Test result. logical :: must_return !< Flag to check when to return from procedure. real ( R8P ) :: tmin , tmax !< Minimum maximum ray intersections with box slabs. do_intersect = . false . must_return = . false . tmin = 0._R8P tmax = MaxR8P call check_slab ( aabb_min = self % bmin % x , aabb_max = self % bmax % x , & o = ray_origin % x , d = ray_direction % x , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return call check_slab ( aabb_min = self % bmin % y , aabb_max = self % bmax % y , & o = ray_origin % y , d = ray_direction % y , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return call check_slab ( aabb_min = self % bmin % z , aabb_max = self % bmax % z , & o = ray_origin % z , d = ray_direction % z , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return ! ray intersects all 3 slabs do_intersect = . true . contains pure subroutine check_slab ( aabb_min , aabb_max , o , d , must_return , tmin , tmax ) !< Perform ray intersection check in a direction-split fashion over slabs. real ( R8P ), intent ( in ) :: aabb_min !< Box minimum bound in the current direction. real ( R8P ), intent ( in ) :: aabb_max !< Box maximum bound in the current direction. real ( R8P ), intent ( in ) :: o !< Ray origin in the current direction. real ( R8P ), intent ( in ) :: d !< Ray slope in the current direction. logical , intent ( inout ) :: must_return !< Flag to check when to return from procedure. real ( R8P ), intent ( inout ) :: tmin , tmax !< Minimum maximum ray intersections with box slabs. real ( R8P ) :: ood , t1 , t2 !< Intersection coefficients. real ( R8P ) :: tmp !< Temporary buffer. if (( d ) < EPS ) then ! ray is parallel to slab, no hit if origin not within slab if (( o < aabb_min ). or .( o > aabb_max )) then must_return = . true . return endif else ! compute intersection t value of ray with near and far plane of slab ood = 1._R8P / d t1 = ( aabb_min - o ) * ood t2 = ( aabb_max - o ) * ood ! make t1 be intersection with near plane, t2 with far plane if ( t1 > t2 ) then tmp = t1 t1 = t2 t2 = tmp endif ! compute the intersection of slab intersection intervals if ( t1 > tmin ) tmin = t1 if ( t2 > tmax ) tmax = t2 ! exit with no collision as soon as slab intersection becomes empty if ( tmin > tmax ) then must_return = . true . return endif endif endsubroutine check_slab endfunction do_ray_intersect pure function has_facets ( self ) !< Return true if AABB has facets. class ( aabb_object ), intent ( in ) :: self !< AABB box. logical :: has_facets !< Check result. has_facets = self % facets_number > 0 endfunction has_facets pure subroutine initialize ( self , facet , bmin , bmax ) !< Initialize AABB. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. call self % destroy if ( present ( facet )) then call compute_bb_from_facets ( facet = facet , bmin = self % bmin , bmax = self % bmax ) elseif ( present ( bmin ). and . present ( bmax )) then self % bmin = bmin self % bmax = bmax endif endsubroutine initialize pure function is_inside ( self , point ) !< Return the true if point is inside ABB. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. logical :: is_inside !< Check result. is_inside = (( point % x >= self % bmin % x . and . point % x <= self % bmax % x ). and .& ( point % y >= self % bmin % y . and . point % y <= self % bmax % y ). and .& ( point % z >= self % bmin % z . and . point % z <= self % bmax % z )) endfunction is_inside pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. integer ( I4P ) :: f !< Counter. intersections_number = 0 if ( self % facets_number > 0 ) then do f = 1 , self % facets_number if ( self % facet ( f )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) & intersections_number = intersections_number + 1 enddo endif endfunction ray_intersections_number subroutine save_geometry_tecplot_ascii ( self , file_unit , aabb_name ) !< Save AABB geometry into Tecplot ascii file. class ( aabb_object ), intent ( in ) :: self !< AABB. integer ( I4P ), intent ( in ) :: file_unit !< File unit. character ( * ), intent ( in ), optional :: aabb_name !< Name of AABB. character ( len = :), allocatable :: aabb_name_ !< Name of AABB, local variable. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: v !< Counter. aabb_name_ = 'AABB' ; if ( present ( aabb_name )) aabb_name_ = aabb_name write ( file_unit , '(A)' ) 'ZONE T=\"' // aabb_name // '\", I=2, J=2, K=2' vertex = self % vertex () do v = 1 , 8 write ( file_unit , '(3(' // FR8P // ',1X))' ) vertex ( v )% x , vertex ( v )% y , vertex ( v )% z enddo endsubroutine save_geometry_tecplot_ascii subroutine save_facets_into_file_stl ( self , file_name , is_ascii ) !< Save facets into file STL. class ( aabb_object ), intent ( in ) :: self !< AABB. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ) :: is_ascii !< Sentinel to check if file is ASCII. integer ( I4P ) :: file_unit !< File unit. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then call open_file if ( is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% save_into_file_ascii ( file_unit = file_unit ) enddo else do f = 1 , self % facets_number call self % facet ( f )% save_into_file_binary ( file_unit = file_unit ) enddo endif call close_file endif contains subroutine open_file () !< Open STL file. if ( is_ascii ) then open ( newunit = file_unit , file = trim ( adjustl ( file_name )), form = 'formatted' ) write ( file_unit , '(A)' ) 'solid ' // trim ( adjustl ( file_name )) else open ( newunit = file_unit , file = trim ( adjustl ( file_name )), access = 'stream' , form = 'unformatted' ) write ( file_unit ) repeat ( 'a' , 80 ) write ( file_unit ) self % facets_number endif endsubroutine open_file subroutine close_file () !< Close STL file. if ( is_ascii ) write ( file_unit , '(A)' ) 'endsolid ' // trim ( adjustl ( file_name )) close ( unit = file_unit ) endsubroutine close_file endsubroutine save_facets_into_file_stl pure subroutine update_extents ( self ) !< Update AABB bounding box extents. class ( aabb_object ), intent ( inout ) :: self !< AABB. if ( self % facets_number > 0 ) call compute_bb_from_facets ( facet = self % facet , bmin = self % bmin , bmax = self % bmax ) endsubroutine update_extents pure function vertex ( self ) !< Return AABB vertices. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. vertex ( 1 ) = self % bmin vertex ( 2 ) = self % bmax % x * ex_R8P + self % bmin % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 3 ) = self % bmin % x * ex_R8P + self % bmax % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 4 ) = self % bmax % x * ex_R8P + self % bmax % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 5 ) = self % bmin % x * ex_R8P + self % bmin % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 6 ) = self % bmax % x * ex_R8P + self % bmin % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 7 ) = self % bmin % x * ex_R8P + self % bmax % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 8 ) = self % bmax endfunction vertex ! operators ! = pure subroutine aabb_assign_aabb ( lhs , rhs ) !< Operator `=`. class ( aabb_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_object ), intent ( in ) :: rhs !< Right hand side. lhs % bmin = rhs % bmin lhs % bmax = rhs % bmax lhs % facets_number = rhs % facets_number if ( allocated ( lhs % facet )) deallocate ( lhs % facet ) if ( allocated ( rhs % facet )) allocate ( lhs % facet ( 1 : lhs % facets_number ), source = rhs % facet ) endsubroutine aabb_assign_aabb ! non TBP pure subroutine compute_bb_from_facets ( facet , bmin , bmax ) !< Compute AABB extents (minimum and maximum bounding box) from facets list. !< !< @note Facets' metrix must be already computed. type ( facet_object ), intent ( in ) :: facet (:) !< Facets list. type ( vector_R8P ), intent ( inout ) :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( inout ) :: bmax !< Maximum point of AABB. real ( R8P ) :: toll ( 3 ) !< Small tollerance on AABB inclusion. toll ( 1 ) = ( maxval ( facet (:)% bb ( 2 )% x ) - minval ( facet (:)% bb ( 1 )% x )) / 10 0._R8P toll ( 2 ) = ( maxval ( facet (:)% bb ( 2 )% y ) - minval ( facet (:)% bb ( 1 )% y )) / 10 0._R8P toll ( 3 ) = ( maxval ( facet (:)% bb ( 2 )% z ) - minval ( facet (:)% bb ( 1 )% z )) / 10 0._R8P bmin % x = minval ( facet (:)% bb ( 1 )% x ) - toll ( 1 ) bmin % y = minval ( facet (:)% bb ( 1 )% y ) - toll ( 2 ) bmin % z = minval ( facet (:)% bb ( 1 )% z ) - toll ( 3 ) bmax % x = maxval ( facet (:)% bb ( 2 )% x ) + toll ( 1 ) bmax % y = maxval ( facet (:)% bb ( 2 )% y ) + toll ( 2 ) bmax % z = maxval ( facet (:)% bb ( 2 )% z ) + toll ( 3 ) endsubroutine compute_bb_from_facets endmodule fossil_aabb_object","tags":"","loc":"sourcefile/fossil_aabb_object.f90.html","title":"fossil_aabb_object.f90 – FOSSIL"},{"text":"FOSSIL, utils library. Files Dependent On This One sourcefile~~fossil_utils.f90~~AfferentGraph sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_utilsf90AfferentGraph = svgPanZoom('#sourcefilefossil_utilsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_utils Source Code fossil_utils.f90 Source Code !< FOSSIL, utils library. module fossil_utils !< FOSSIL, utils library. use penf , only : I4P , R4P , R8P , ZeroR4P implicit none private public :: EPS public :: FRLEN public :: PI real ( R8P ), parameter :: EPS = real ( ZeroR4P , R8P ) !< Small EPSILON to avoid rund off errors. integer ( I4P ), parameter :: FRLEN = 80 !< Maximum length of fossil STL label string. real ( R8P ), parameter :: PI = 4._R8P * atan ( 1._R8P ) !< Pi greek. endmodule fossil_utils","tags":"","loc":"sourcefile/fossil_utils.f90.html","title":"fossil_utils.f90 – FOSSIL"},{"text":"FOSSIL,  STL file class definition. This File Depends On sourcefile~~fossil_file_stl_object.f90~~EfferentGraph sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_file_stl_objectf90EfferentGraph = svgPanZoom('#sourcefilefossil_file_stl_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil_file_stl_object.f90~~AfferentGraph sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_file_stl_object Source Code fossil_file_stl_object.f90 Source Code !< FOSSIL,  STL file class definition. module fossil_file_stl_object !< FOSSIL,  STL file class definition. use fossil_aabb_tree_object , only : aabb_tree_object use fossil_facet_object , only : facet_object use fossil_utils , only : EPS , PI , FRLEN use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : I4P , R8P , MaxR8P , str use vecfor , only : ex_R8P , ey_R8P , ez_R8P , mirror_matrix_R8P , rotation_matrix_R8P , vector_R8P implicit none private public :: file_stl_object type :: file_stl_object !< FOSSIL STL file class. character ( len = :), allocatable :: file_name !< File name integer ( I4P ) :: file_unit = 0 !< File unit. character ( FRLEN ) :: header !< File header. integer ( I4P ) :: facets_number = 0 !< Facets number. type ( facet_object ), allocatable :: facet (:) !< Facets. type ( aabb_tree_object ) :: aabb !< AABB tree. type ( vector_R8P ) :: bmin !< Minimum point of STL. type ( vector_R8P ) :: bmax !< Maximum point of STL. real ( R8P ) :: volume = 0._R8P !< Volume bounded by STL surface. logical :: is_ascii = . true . !< Sentinel to check if file is ASCII. logical :: is_open = . false . !< Sentinel to check if file is open. contains ! public methods procedure , pass ( self ) :: analize !< Analize STL. procedure , pass ( self ) :: build_connectivity !< Build facets connectivity. procedure , pass ( self ) :: close_file !< Close file. procedure , pass ( self ) :: compute_metrix !< Compute facets metrix. procedure , pass ( self ) :: compute_normals !< Compute facets normals by means of vertices data. procedure , pass ( self ) :: compute_volume !< Compute volume bounded by STL surface. procedure , pass ( self ) :: create_aabb_tree !< Create the AABB tree. procedure , pass ( self ) :: destroy !< Destroy file. procedure , pass ( self ) :: distance !< Compute the (minimum) distance from point to triangulated surface. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: is_point_inside_polyhedron_ri !< Determinate is point is inside or not STL facets by ray intersect. procedure , pass ( self ) :: is_point_inside_polyhedron_sa !< Determinate is point is inside or not STL facets by solid angle. procedure , pass ( self ) :: load_from_file !< Load from file. generic :: mirror => mirror_by_normal , & mirror_by_matrix !< Mirror facets. procedure , pass ( self ) :: open_file !< Open file, once initialized. procedure , pass ( self ) :: reverse_normals !< Reverse facets normals. procedure , pass ( self ) :: resize !< Resize (scale) facets by x or y or z or vectorial factors. generic :: rotate => rotate_by_axis_angle , & rotate_by_matrix !< Rotate facets. procedure , pass ( self ) :: sanitize_normals !< Sanitize facets normals, make them consistent. procedure , pass ( self ) :: save_into_file !< Save into file. procedure , pass ( self ) :: statistics !< Return STL statistics. procedure , pass ( self ) :: translate !< Translate facet given vectorial delta. ! operators generic :: assignment ( = ) => file_stl_assign_file_stl !< Overload `=`. procedure , pass ( lhs ), private :: file_stl_assign_file_stl !< Operator `=`. ! private methods procedure , pass ( self ), private :: allocate_facets !< Allocate facets. procedure , pass ( self ), private :: load_facets_number_from_file !< Load facets number from file. procedure , pass ( self ), private :: load_header_from_file !< Load header from file. procedure , pass ( self ), private :: mirror_by_normal !< Mirror facets given normal of mirroring plane. procedure , pass ( self ), private :: mirror_by_matrix !< Mirror facets given matrix. procedure , pass ( self ), private :: rotate_by_axis_angle !< Rotate facets given axis and angle. procedure , pass ( self ), private :: rotate_by_matrix !< Rotate facets given matrix. procedure , pass ( self ), private :: save_header_into_file !< Save header into file. procedure , pass ( self ), private :: save_trailer_into_file !< Save trailer into file. endtype file_stl_object contains ! public methods pure subroutine analize ( self ) !< Analize STL. !< !< Buil connectivity, compute metrix, compute volume. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then call self % build_connectivity call self % compute_metrix call self % compute_volume endif endsubroutine analize pure subroutine build_connectivity ( self ) !< Build facets connectivity. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ) :: f1 , f2 !< Counter. if ( self % facets_number > 0 ) then do f1 = 1 , self % facets_number - 1 do f2 = f1 + 1 , self % facets_number call self % facet ( f1 )% check_vertices_occurrencies ( other = self % facet ( f2 )) enddo enddo do f1 = 1 , self % facets_number call self % facet ( f1 )% update_connectivity enddo endif endsubroutine build_connectivity subroutine close_file ( self ) !< Close file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical :: file_exist !< Sentinel to check if file exist. if ( self % is_open ) then close ( unit = self % file_unit ) self % file_unit = 0 self % is_open = . false . endif endsubroutine close_file pure subroutine compute_metrix ( self ) !< Compute facets metrix. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then call self % facet % compute_metrix ! computing bounding box extents self % bmin % x = minval ( self % facet (:)% bb ( 1 )% x ) self % bmin % y = minval ( self % facet (:)% bb ( 1 )% y ) self % bmin % z = minval ( self % facet (:)% bb ( 1 )% z ) self % bmax % x = maxval ( self % facet (:)% bb ( 2 )% x ) self % bmax % y = maxval ( self % facet (:)% bb ( 2 )% y ) self % bmax % z = maxval ( self % facet (:)% bb ( 2 )% z ) endif endsubroutine compute_metrix elemental subroutine compute_normals ( self ) !< Compute facets normals by means of vertices data. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) call self % facet % compute_normal endsubroutine compute_normals elemental subroutine compute_volume ( self ) !< Compute volume bounded by STL surface. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then self % volume = 0._R8P do f = 1 , self % facets_number self % volume = self % volume + self % facet ( f )% tetrahedron_volume ( apex = self % facet ( 1 )% vertex_1 ) enddo endif endsubroutine compute_volume subroutine create_aabb_tree ( self , refinement_levels ) !< Create AABB tree. !< !< @note Facets metrix must be already computed. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ), intent ( in ), optional :: refinement_levels !< Total number of refinement levels used. integer ( I4P ) :: refinement_levels_ !< Total number of refinement levels used, local variable. refinement_levels_ = 2 ; if ( present ( refinement_levels )) refinement_levels_ = refinement_levels call self % aabb % initialize ( refinement_levels = refinement_levels_ , facet = self % facet ) endsubroutine create_aabb_tree elemental subroutine destroy ( self ) !< Destroy file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( file_stl_object ) :: fresh !< Fresh instance of file STL. self = fresh endsubroutine destroy pure function distance ( self , point , is_signed , sign_algorithm , is_square_root ) !< Compute the (minimum) distance from a point to the triangulated surface. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical , intent ( in ), optional :: is_signed !< Sentinel to trigger signed distance. character ( * ), intent ( in ), optional :: sign_algorithm !< Algorithm used for \"point in polyhedron\" test. logical , intent ( in ), optional :: is_square_root !< Sentinel to trigger square-root distance. real ( R8P ) :: distance !< Minimum distance from point to the triangulated surface. real ( R8P ) :: distance_ !< Minimum distance, temporary buffer. character ( len = :), allocatable :: sign_algorithm_ !< Algorithm used for \"point in polyhedron\" test, local variable. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then if ( self % aabb % is_initialized ) then ! exploit AABB refinement levels distance = self % aabb % distance ( point = point ) else ! brute-force search over all facets distance = MaxR8P do f = 1 , self % facets_number distance_ = self % facet ( f )% distance ( point = point ) if ( abs ( distance_ ) <= abs ( distance )) distance = distance_ enddo endif endif if ( present ( is_square_root )) then if ( is_square_root ) distance = sqrt ( distance ) endif if ( present ( is_signed )) then if ( is_signed ) then sign_algorithm_ = 'ray_intersections' ; if ( present ( sign_algorithm )) sign_algorithm_ = sign_algorithm select case ( sign_algorithm_ ) case ( 'solid_angle' ) if ( self % is_point_inside_polyhedron_sa ( point = point )) distance = - distance case ( 'ray_intersections' ) if ( self % is_point_inside_polyhedron_ri ( point = point )) distance = - distance case default ! raise error: \"unknown point in polyhedron algorithm\" endselect endif endif endfunction distance pure function is_point_inside_polyhedron_ri ( self , point ) result ( is_inside ) !< Determinate is a point is inside or not to a polyhedron described by STL facets by means ray intersections count. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical :: is_inside !< Check result. logical :: is_inside_by_x !< Test result by x-aligned ray intersections. logical :: is_inside_by_y !< Test result by y-aligned ray intersections. logical :: is_inside_by_z !< Test result by z-aligned ray intersections. is_inside_by_x = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = ex_R8P + EPS * ey_R8P + EPS * ez_R8P ) is_inside_by_y = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = EPS * ex_R8P + ey_R8P + EPS * ez_R8P ) if ( is_inside_by_x . and . is_inside_by_y ) then is_inside = . true . else is_inside_by_z = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = EPS * ex_R8P + EPS * ey_R8P + ez_R8P ) is_inside = (( is_inside_by_x . and . is_inside_by_y ). or .& ( is_inside_by_x . and . is_inside_by_z ). or .& ( is_inside_by_y . and . is_inside_by_z )) endif contains pure function is_inside_by_ray_intersect ( ray_origin , ray_direction ) result ( is_inside_by ) !< Generic line intersect test. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Ray intersections number of STL polyhedra with respect point. integer ( I4P ) :: f !< Counter. logical :: is_inside_by !< Test result. intersections_number = 0 if ( self % aabb % is_initialized ) then ! exploit AABB refinement levels intersections_number = self % aabb % ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) else ! brute-force search over all facets do f = 1 , self % facets_number if ( self % facet ( f )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) & intersections_number = intersections_number + 1 enddo endif if ( mod ( intersections_number , 2 ) == 0 ) then is_inside_by = . false . else is_inside_by = . true . endif endfunction is_inside_by_ray_intersect endfunction is_point_inside_polyhedron_ri pure function is_point_inside_polyhedron_sa ( self , point ) result ( is_inside ) !< Determinate is a point is inside or not to a polyhedron described by STL facets by means of the solid angle criteria. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical :: is_inside !< Check result. real ( R8P ) :: solid_angle !< Solid angle of STL polyhedra projected on point unit sphere. integer ( I4P ) :: f !< Counter. solid_angle = 0._R8P do f = 1 , self % facets_number solid_angle = solid_angle + self % facet ( f )% solid_angle ( point = point ) enddo if ( solid_angle < - 2._R8P * PI . or . 2._R8P * PI < solid_angle ) then is_inside = . true . else is_inside = . false . endif endfunction is_point_inside_polyhedron_sa elemental subroutine initialize ( self , skip_destroy , file_name , is_ascii ) !< Initialize file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical , intent ( in ), optional :: skip_destroy !< Flag to skip destroy file. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical :: skip_destroy_ !< Flag to skip destroy file, local variable. skip_destroy_ = . false . ; if ( present ( skip_destroy )) skip_destroy_ = skip_destroy if (. not . skip_destroy_ ) call self % destroy if ( present ( file_name )) self % file_name = trim ( adjustl ( file_name )) if ( present ( is_ascii )) self % is_ascii = is_ascii endsubroutine initialize subroutine load_from_file ( self , file_name , is_ascii , guess_format , disable_analysis ) !< Load from file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical , intent ( in ), optional :: guess_format !< Sentinel to try to guess format directly from file. logical , intent ( in ), optional :: disable_analysis !< Sentinel to disable STL analysis. logical :: disable_analysis_ !< Sentinel to disable STL analysis, local variable. integer ( I4P ) :: f !< Counter. disable_analysis_ = . false . ; if ( present ( disable_analysis )) disable_analysis_ = disable_analysis call self % initialize ( skip_destroy = . true ., file_name = file_name , is_ascii = is_ascii ) call self % open_file ( file_action = 'read' , guess_format = guess_format ) call self % load_facets_number_from_file call self % allocate_facets call self % load_header_from_file if ( self % is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% load_from_file_ascii ( file_unit = self % file_unit ) self % facet ( f )% id = f enddo else do f = 1 , self % facets_number self % facet ( f )% id = f call self % facet ( f )% load_from_file_binary ( file_unit = self % file_unit ) enddo endif call self % close_file if (. not . disable_analysis_ ) call self % analize endsubroutine load_from_file subroutine open_file ( self , file_action , guess_format ) !< Open file, once initialized. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ) :: file_action !< File action, \"read\" or \"write\". logical , intent ( in ), optional :: guess_format !< Sentinel to try to guess format directly from file. logical :: guess_format_ !< Sentinel to try to guess format directly from file, local var. logical :: file_exist !< Sentinel to check if file exist. character ( 5 ) :: ascii_header !< Ascii header sentinel. if ( allocated ( self % file_name )) then select case ( trim ( adjustl ( file_action ))) case ( 'read' ) guess_format_ = . false . ; if ( present ( guess_format )) guess_format_ = guess_format inquire ( file = self % file_name , exist = file_exist ) if ( file_exist ) then if ( guess_format_ ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) read ( self % file_unit , '(A)' ) ascii_header close ( self % file_unit ) if ( ascii_header == 'solid' ) then self % is_ascii = . true . else self % is_ascii = . false . endif endif if ( self % is_ascii ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) else open ( newunit = self % file_unit , file = self % file_name , access = 'stream' , form = 'unformatted' ) endif self % is_open = . true . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" does not exist, impossible to open file!' endif case ( 'write' ) if ( self % is_ascii ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) else open ( newunit = self % file_unit , file = self % file_name , access = 'stream' , form = 'unformatted' ) endif self % is_open = . true . case default write ( stderr , '(A)' ) 'error: file action \"' // trim ( adjustl ( file_action )) // '\" unknown!' endselect else write ( stderr , '(A)' ) 'error: file name has not be initialized, impossible to open file!' endif endsubroutine open_file elemental subroutine reverse_normals ( self ) !< Reverse facets normals. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) call self % facet % reverse_normal endsubroutine reverse_normals pure subroutine sanitize_normals ( self ) !< Sanitize facets normals, make them consistent. !< !< @note Facets connectivity and normals must be already computed. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical , allocatable :: facet_checked (:) !< List of facets checked. integer ( I4P ) :: f , ff !< Counter. if ( self % facets_number > 0 ) then allocate ( facet_checked ( 1 : self % facets_number )) facet_checked = . false . f = 1 facet_checked ( f ) = . true . do ff = 0 if ( self % facet ( f )% fcon_edge_12 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_12 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_12' , other = self % facet ( self % facet ( f )% fcon_edge_12 )) facet_checked ( self % facet ( f )% fcon_edge_12 ) = . true . ff = self % facet ( f )% fcon_edge_12 endif if ( self % facet ( f )% fcon_edge_23 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_23 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_23' , other = self % facet ( self % facet ( f )% fcon_edge_23 )) facet_checked ( self % facet ( f )% fcon_edge_23 ) = . true . ff = self % facet ( f )% fcon_edge_23 endif if ( self % facet ( f )% fcon_edge_31 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_31 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_31' , other = self % facet ( self % facet ( f )% fcon_edge_31 )) facet_checked ( self % facet ( f )% fcon_edge_31 ) = . true . ff = self % facet ( f )% fcon_edge_31 endif if ( ff == 0 ) then exit else f = ff endif enddo endif call self % compute_volume if ( self % volume < 0 ) call self % reverse_normals endsubroutine sanitize_normals subroutine save_into_file ( self , file_name , is_ascii ) !< Save into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. integer ( I4P ) :: f !< Counter. call self % initialize ( skip_destroy = . true ., file_name = file_name , is_ascii = is_ascii ) call self % open_file ( file_action = 'write' ) call self % save_header_into_file if ( self % is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% save_into_file_ascii ( file_unit = self % file_unit ) enddo else do f = 1 , self % facets_number call self % facet ( f )% save_into_file_binary ( file_unit = self % file_unit ) enddo endif call self % save_trailer_into_file call self % close_file endsubroutine save_into_file elemental subroutine resize ( self , x , y , z , factor , recompute_metrix ) !< Resize (scale) facets by x or y or z or vectorial factors. !< !< @note The name `scale` has not been used, it been a Fortran built-in. class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ), optional :: x !< Factor along x axis. real ( R8P ), intent ( in ), optional :: y !< Factor along y axis. real ( R8P ), intent ( in ), optional :: z !< Factor along z axis. type ( vector_R8P ), intent ( in ), optional :: factor !< Vectorial factor. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. type ( vector_R8P ) :: factor_ !< Vectorial factor, local variable. if ( self % facets_number > 0 ) then factor_ = 1._R8P if ( present ( factor )) then factor_ = factor else if ( present ( x )) factor_ % x = x if ( present ( y )) factor_ % y = y if ( present ( z )) factor_ % z = z endif call self % facet % resize ( factor = factor_ , recompute_metrix = recompute_metrix ) endif endsubroutine resize pure function statistics ( self , prefix ) result ( stats ) !< Return STL statistics. class ( file_stl_object ), intent ( in ) :: self !< File STL. character ( * ), intent ( in ), optional :: prefix !< Lines prefix. character ( len = :), allocatable :: stats !< STL statistics. character ( len = :), allocatable :: prefix_ !< Lines prefix, local variable. character ( 1 ), parameter :: NL = new_line ( 'a' ) !< Line terminator. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix stats = prefix_ // self % header // NL if ( allocated ( self % file_name )) stats = stats // prefix_ // 'file name:   ' // self % file_name // NL if ( self % is_ascii ) then stats = stats // prefix_ // 'file format: ascii' // NL else stats = stats // prefix_ // 'file format: binary' // NL endif if ( self % facets_number > 0 ) then stats = stats // prefix_ // 'X extents: [' // trim ( str ( self % bmin % x )) // ', ' // trim ( str ( self % bmax % x )) // ']' // NL stats = stats // prefix_ // 'Y extents: [' // trim ( str ( self % bmin % y )) // ', ' // trim ( str ( self % bmax % y )) // ']' // NL stats = stats // prefix_ // 'Z extents: [' // trim ( str ( self % bmin % z )) // ', ' // trim ( str ( self % bmax % z )) // ']' // NL stats = stats // prefix_ // 'volume: ' // trim ( str ( self % volume )) // NL stats = stats // prefix_ // 'number of facets: ' // trim ( str ( self % facets_number )) // NL ! stats=stats//prefix_//'number of facets with 1 edge disconnected: '//trim(str(self%facets_1disconnect_number))//NL ! stats=stats//prefix_//'number of facets with 2 edge disconnected: '//trim(str(self%facets_2disconnect_number))//NL ! stats=stats//prefix_//'number of facets with 3 edge disconnected: '//trim(str(self%facets_3disconnect_number))//NL endif endfunction statistics elemental subroutine translate ( self , x , y , z , delta , recompute_metrix ) !< Translate facets x or y or z or vectorial delta increments. class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ), optional :: x !< Increment along x axis. real ( R8P ), intent ( in ), optional :: y !< Increment along y axis. real ( R8P ), intent ( in ), optional :: z !< Increment along z axis. type ( vector_R8P ), intent ( in ), optional :: delta !< Vectorial increment. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. type ( vector_R8P ) :: delta_ !< Vectorial increment, local variable. if ( self % facets_number > 0 ) then delta_ = 0._R8P if ( present ( delta )) then delta_ = delta else if ( present ( x )) delta_ % x = x if ( present ( y )) delta_ % y = y if ( present ( z )) delta_ % z = z endif call self % facet % translate ( delta = delta_ , recompute_metrix = recompute_metrix ) endif endsubroutine translate ! operators ! = pure subroutine file_stl_assign_file_stl ( lhs , rhs ) !< Operator `=`. class ( file_stl_object ), intent ( inout ) :: lhs !< Left hand side. type ( file_stl_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( lhs % file_name )) deallocate ( lhs % file_name ) if ( allocated ( rhs % file_name )) lhs % file_name = rhs % file_name lhs % file_unit = rhs % file_unit lhs % header = rhs % header lhs % facets_number = rhs % facets_number if ( allocated ( lhs % facet )) deallocate ( lhs % facet ) if ( allocated ( rhs % facet )) allocate ( lhs % facet ( 1 : lhs % facets_number ), source = rhs % facet ) lhs % aabb = rhs % aabb lhs % bmin = rhs % bmin lhs % bmax = rhs % bmax lhs % is_ascii = rhs % is_ascii lhs % is_open = rhs % is_open endsubroutine file_stl_assign_file_stl ! private methods elemental subroutine allocate_facets ( self ) !< Allocate facets. !< !< @note Facets previously allocated are lost. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then if ( allocated ( self % facet )) deallocate ( self % facet ) allocate ( self % facet ( 1 : self % facets_number )) endif endsubroutine allocate_facets subroutine load_facets_number_from_file ( self ) !< Load facets number from file. !< !< @note File is rewinded. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( FRLEN ) :: facet_record !< Facet record string buffer. if ( self % is_open ) then self % facets_number = 0 rewind ( self % file_unit ) if ( self % is_ascii ) then do read ( self % file_unit , '(A)' , end = 10 , err = 10 ) facet_record if ( index ( string = facet_record , substring = 'facet normal' ) > 0 ) self % facets_number = self % facets_number + 1 enddo else read ( self % file_unit , end = 10 , err = 10 ) facet_record read ( self % file_unit , end = 10 , err = 10 ) self % facets_number endif 10 rewind ( self % file_unit ) else write ( stderr , '(A)' ) 'error: file is not open, impossible to load facets number from file!' endif endsubroutine load_facets_number_from_file subroutine load_header_from_file ( self ) !< Load header from file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then rewind ( self % file_unit ) if ( self % is_ascii ) then read ( self % file_unit , '(A)' ) self % header self % header = trim ( adjustl ( self % header ( index ( self % header , 'solid' ) + 6 :))) else read ( self % file_unit ) self % header read ( self % file_unit ) self % facets_number endif else write ( stderr , '(A)' ) 'error: file is not open, impossible to load header from file!' endif endsubroutine load_header_from_file elemental subroutine mirror_by_normal ( self , normal , recompute_metrix ) !< Mirror facets given normal of mirroring plane. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: normal !< Normal of mirroring plane. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. real ( R8P ) :: matrix ( 3 , 3 ) !< Mirroring matrix. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then matrix = mirror_matrix_R8P ( normal = normal ) do f = 1 , self % facets_number call self % facet ( f )% mirror ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine mirror_by_normal pure subroutine mirror_by_matrix ( self , matrix , recompute_metrix ) !< Mirror facet given matrix (of mirroring). class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Mirroring matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then do f = 1 , self % facets_number call self % facet ( f )% mirror ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine mirror_by_matrix elemental subroutine rotate_by_axis_angle ( self , axis , angle , recompute_metrix ) !< Rotate facets given axis and angle. !< !< Angle must be in radiants. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: axis !< Axis of rotation. real ( R8P ), intent ( in ) :: angle !< Angle of rotation. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. real ( R8P ) :: matrix ( 3 , 3 ) !< Rotation matrix. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then matrix = rotation_matrix_R8P ( axis = axis , angle = angle ) do f = 1 , self % facets_number call self % facet ( f )% rotate ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine rotate_by_axis_angle pure subroutine rotate_by_matrix ( self , matrix , recompute_metrix ) !< Rotate facet given matrix (of ratation). class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Rotation matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then do f = 1 , self % facets_number call self % facet ( f )% rotate ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine rotate_by_matrix subroutine save_header_into_file ( self ) !< Save header into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then rewind ( self % file_unit ) if ( self % is_ascii ) then write ( self % file_unit , '(A)' ) 'solid ' // trim ( self % header ) else write ( self % file_unit ) self % header write ( self % file_unit ) self % facets_number endif else write ( stderr , '(A)' ) 'error: file is not open, impossible to load header from file!' endif endsubroutine save_header_into_file subroutine save_trailer_into_file ( self ) !< Save trailer into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then if ( self % is_ascii ) write ( self % file_unit , '(A)' ) 'endsolid ' // trim ( self % header ) else write ( stderr , '(A)' ) 'error: file is not open, impossible to write trailer into file!' endif endsubroutine save_trailer_into_file endmodule fossil_file_stl_object","tags":"","loc":"sourcefile/fossil_file_stl_object.f90.html","title":"fossil_file_stl_object.f90 – FOSSIL"},{"text":"FOSSIL, FOrtran Stereo (si) Litography parser. This File Depends On sourcefile~~fossil.f90~~EfferentGraph sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossilf90EfferentGraph = svgPanZoom('#sourcefilefossilf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil.f90~~AfferentGraph sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil Source Code fossil.f90 Source Code !< FOSSIL, FOrtran Stereo (si) Litography parser. module fossil !< FOSSIL, FOrtran Stereo (si) Litography parser. use fossil_facet_object use fossil_file_stl_object implicit none private public :: facet_object public :: file_stl_object endmodule fossil","tags":"","loc":"sourcefile/fossil.f90.html","title":"fossil.f90 – FOSSIL"},{"text":"FOSSIL, Axis-Aligned Bounding Box (AABB) tree-node class definition. This File Depends On sourcefile~~fossil_aabb_node_object.f90~~EfferentGraph sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil_aabb_node_object.f90~~AfferentGraph sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 var pansourcefilefossil_aabb_node_objectf90AfferentGraph = svgPanZoom('#sourcefilefossil_aabb_node_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_aabb_node_object Source Code fossil_aabb_node_object.f90 Source Code !< FOSSIL, Axis-Aligned Bounding Box (AABB) tree-node class definition. module fossil_aabb_node_object !< FOSSIL, Axis-Aligned Bounding Box (AABB) tree-node class definition. !< !< This is just a *container* for AABB tree's nodes. use fossil_aabb_object , only : aabb_object use fossil_facet_object , only : facet_object use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : I4P , R8P , MaxR8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none private public :: aabb_node_object type :: aabb_node_object !< FOSSIL Axis-Aligned Bounding Box (AABB) tree-node class. private type ( aabb_object ), allocatable :: aabb !< AABB data. contains ! public methods procedure , pass ( self ) :: add_facets !< Add facets to AABB. procedure , pass ( self ) :: bmin !< Return AABB bmin. procedure , pass ( self ) :: bmax !< Return AABB bmax. procedure , pass ( self ) :: closest_point !< Return closest point on AABB from point reference. procedure , pass ( self ) :: compute_octants !< Compute AABB octants. procedure , pass ( self ) :: destroy !< Destroy AABB. procedure , pass ( self ) :: distance !< Return the (square) distance from point to AABB. procedure , pass ( self ) :: distance_from_facets !< Return the (square) distance from point to AABB's facets. procedure , pass ( self ) :: do_ray_intersect !< Return true if AABB is intersected by ray. procedure , pass ( self ) :: has_facets !< Return true if AABB has facets. procedure , pass ( self ) :: initialize !< Initialize AABB. procedure , pass ( self ) :: is_allocated !< Return true is node is allocated. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB geometry into Tecplot ascii file. procedure , pass ( self ) :: save_facets_into_file_stl !< Save facets into file STL. procedure , pass ( self ) :: update_extents !< Update AABB bounding box extents. ! operators generic :: assignment ( = ) => aabb_node_assign_aabb_node !< Overload `=`. procedure , pass ( lhs ), private :: aabb_node_assign_aabb_node !< Operator `=`. endtype aabb_node_object contains ! public methods subroutine add_facets ( self , facet ) !< Add facets to AABB. !< !< @note Facets added to AABB are removed to facets list that is also returned. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), allocatable , intent ( inout ) :: facet (:) !< Facets list. if ( allocated ( self % aabb )) call self % aabb % add_facets ( facet = facet ) endsubroutine add_facets pure function bmin ( self ) !< Return AABB bmin. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ) :: bmin !< AABB bmin. if ( allocated ( self % aabb )) bmin = self % aabb % bmin endfunction bmin pure function bmax ( self ) !< Return AABB bmax. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ) :: bmax !< AABB bmax. if ( allocated ( self % aabb )) bmax = self % aabb % bmax endfunction bmax pure function closest_point ( self , point ) result ( closest ) !< Return closest point on (or in) AABB from point reference. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ), intent ( in ) :: point !< Point reference. type ( vector_R8P ) :: closest !< Closest point on (on in) aabb to point. closest = MaxR8P if ( allocated ( self % aabb )) closest = self % aabb % closest_point ( point = point ) endfunction closest_point pure subroutine compute_octants ( self , octant ) !< Return AABB octants. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( aabb_object ), intent ( out ) :: octant ( 8 ) !< AABB octants. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: o !< Counter. call self % aabb % compute_octants ( octant = octant ) endsubroutine compute_octants elemental subroutine destroy ( self ) !< Destroy AABB. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( aabb_node_object ) :: fresh !< Fresh instance of AABB. if ( allocated ( self % aabb )) then call self % aabb % destroy deallocate ( self % aabb ) endif endsubroutine destroy pure function distance ( self , point ) !< Return the (square) distance from point to AABB. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB. distance = MaxR8P if ( allocated ( self % aabb )) distance = self % aabb % distance ( point = point ) endfunction distance pure function distance_from_facets ( self , point ) result ( distance ) !< Return the (square) distance from point to AABB's facets. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB's facets. distance = MaxR8P if ( allocated ( self % aabb )) distance = self % aabb % distance_from_facets ( point = point ) endfunction distance_from_facets pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( do_intersect ) !< Return true if AABB is intersected by ray from origin and oriented as ray direction vector. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: do_intersect !< Test result. do_intersect = . false . if ( allocated ( self % aabb )) do_intersect = self % aabb % do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction ) endfunction do_ray_intersect pure function has_facets ( self ) !< Return true if AABB has facets. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. logical :: has_facets !< Check result. has_facets = allocated ( self % aabb ) if ( has_facets ) has_facets = self % aabb % has_facets () endfunction has_facets pure subroutine initialize ( self , facet , bmin , bmax ) !< Initialize AABB. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. call self % destroy if ( present ( facet ). or .( present ( bmin ). and . present ( bmin ))) then allocate ( self % aabb ) call self % aabb % initialize ( facet = facet , bmin = bmin , bmax = bmax ) endif endsubroutine initialize pure function is_allocated ( self ) !< Return true if node is allocated. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. logical :: is_allocated !< Check result. is_allocated = allocated ( self % aabb ) endfunction is_allocated pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. intersections_number = 0 if ( allocated ( self % aabb )) & intersections_number = self % aabb % ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) endfunction ray_intersections_number subroutine save_geometry_tecplot_ascii ( self , file_unit , aabb_name ) !< Save AABB geometry into Tecplot ascii file. class ( aabb_node_object ), intent ( in ) :: self !< AABB. integer ( I4P ), intent ( in ) :: file_unit !< File unit. character ( * ), intent ( in ), optional :: aabb_name !< Name of AABB. if ( allocated ( self % aabb )) call self % aabb % save_geometry_tecplot_ascii ( file_unit = file_unit , aabb_name = aabb_name ) endsubroutine save_geometry_tecplot_ascii subroutine save_facets_into_file_stl ( self , file_name , is_ascii ) !< Save facets into file STL. class ( aabb_node_object ), intent ( in ) :: self !< AABB. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ) :: is_ascii !< Sentinel to check if file is ASCII. if ( allocated ( self % aabb )) call self % aabb % save_facets_into_file_stl ( file_name = file_name , is_ascii = is_ascii ) endsubroutine save_facets_into_file_stl pure subroutine update_extents ( self ) !< Update AABB bounding box extents. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. if ( allocated ( self % aabb )) call self % aabb % update_extents endsubroutine update_extents ! operators ! = pure subroutine aabb_node_assign_aabb_node ( lhs , rhs ) !< Operator `=`. class ( aabb_node_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_node_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( lhs % aabb )) then call lhs % aabb % destroy deallocate ( lhs % aabb ) endif if ( allocated ( rhs % aabb )) then allocate ( lhs % aabb ) lhs % aabb = rhs % aabb endif endsubroutine aabb_node_assign_aabb_node endmodule fossil_aabb_node_object","tags":"","loc":"sourcefile/fossil_aabb_node_object.f90.html","title":"fossil_aabb_node_object.f90 – FOSSIL"},{"text":"FOSSIL, Axis-Aligned Bounding Box (AABB) tree class definition. Note The tree is assumed to be an octree . This File Depends On sourcefile~~fossil_aabb_tree_object.f90~~EfferentGraph sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 var pansourcefilefossil_aabb_tree_objectf90EfferentGraph = svgPanZoom('#sourcefilefossil_aabb_tree_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~fossil_aabb_tree_object.f90~~AfferentGraph sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules fossil_aabb_tree_object Source Code fossil_aabb_tree_object.f90 Source Code !< FOSSIL, Axis-Aligned Bounding Box (AABB) tree class definition. !< !< @note The tree is assumed to be an **octree**. module fossil_aabb_tree_object !< FOSSIL, Axis-Aligned Bounding Box (AABB) tree class definition. !< !< @note The tree is assumed to be an **octree**. use fossil_aabb_object , only : aabb_object use fossil_aabb_node_object , only : aabb_node_object use fossil_facet_object , only : facet_object use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : I4P , R8P , MaxR8P , str use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none private public :: aabb_tree_object integer ( I4P ), parameter :: TREE_RATIO = 8 !< Tree refinement ratio, it is assumed to be an **octree**. type :: aabb_tree_object !< FOSSIL Axis-Aligned Bounding Box (AABB) tree class. !< !< @note The tree is assumed to be an **octree**. integer ( I4P ) :: refinement_levels = 0 !< Total number of refinement levels used. integer ( I4P ) :: nodes_number = 0 !< Total number of tree nodes. type ( aabb_node_object ), allocatable :: node (:) !< AABB tree nodes [0:nodes_number-1]. logical :: is_initialized = . false . !< Sentinel to check is AABB tree is initialized. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy AABB tree. procedure , pass ( self ) :: distance !< Compute the (minimum) distance from point to triangulated surface. procedure , pass ( self ) :: initialize !< Initialize AABB tree. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB tree boxes geometry into Tecplot ascii file. procedure , pass ( self ) :: save_into_file_stl !< Save  AABB tree boxes facets into files STL. ! operators generic :: assignment ( = ) => aabb_tree_assign_aabb_tree !< Overload `=`. procedure , pass ( lhs ), private :: aabb_tree_assign_aabb_tree !< Operator `=`. endtype aabb_tree_object contains ! public methods elemental subroutine destroy ( self ) !< Destroy AABB tree. class ( aabb_tree_object ), intent ( inout ) :: self !< AABB tree. type ( aabb_tree_object ) :: fresh !< Fresh instance of AABB tree. self = fresh endsubroutine destroy pure function distance ( self , point ) !< Compute the (minimum) distance from a point to the triangulated surface. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. real ( R8P ) :: distance !< Minimum distance from point to the triangulated surface. real ( R8P ), allocatable :: distance_ (:) !< Minimum distance, temporary buffer. integer ( I4P ), allocatable :: aabb_closest (:) !< Index of closest AABB. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) allocate ( distance_ ( 0 : self % refinement_levels )) allocate ( aabb_closest ( 0 : self % refinement_levels )) distance_ = MaxR8P aabb_closest = - 1 do level = 0 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at finest level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( node ( bbb )% is_allocated ()) then distance = node ( bbb )% distance ( point = point ) ! node distance if ( distance <= distance_ ( level )) then distance_ ( level ) = distance ! update minimum distance aabb_closest ( level ) = bbb ! store closest node endif endif enddo enddo distance = MaxR8P do level = 0 , self % refinement_levels if ( aabb_closest ( level ) >= 0 ) then distance = min ( distance , node ( aabb_closest ( level ))% distance_from_facets ( point = point )) endif enddo endassociate endfunction distance subroutine initialize ( self , refinement_levels , facet , bmin , bmax ) !< Initialize AABB tree. class ( aabb_tree_object ), intent ( inout ) :: self !< AABB tree. integer ( I4P ), intent ( in ) :: refinement_levels !< Total number of refinement levels used. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb , bbbb !< Counter. integer ( I4P ) :: parent !< Parent node index. type ( aabb_object ) :: octant ( 8 ) !< AABB octants. type ( facet_object ), allocatable :: facet_ (:) !< Facets list, local variable. call self % destroy self % refinement_levels = refinement_levels self % nodes_number = nodes_number ( refinement_levels = self % refinement_levels ) allocate ( self % node ( 0 : self % nodes_number - 1 )) associate ( node => self % node ) ! inizialize all tree nodes with only the bounding box call node ( 0 )% initialize ( facet = facet , bmin = bmin , bmax = bmax ) do level = 1 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ), TREE_RATIO ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree parent = parent_node ( node = bbb ) ! parent of the current node if ( node ( parent )% is_allocated ()) then ! create children nodes call node ( parent )% compute_octants ( octant = octant ) ! compute parent AABB octants do bbbb = 0 , TREE_RATIO - 1 ! loop over children call node ( bbb + bbbb )% initialize ( bmin = octant ( bbbb + 1 )% bmin , bmax = octant ( bbbb + 1 )% bmax ) ! initialize node enddo endif enddo enddo ! fill all tree nodes with facets if ( present ( facet )) then allocate ( facet_ , source = facet ) ! add facets to nodes do level = self % refinement_levels , 0 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( allocated ( facet_ )) then ! check if facets list still has facets call node ( bbb )% add_facets ( facet = facet_ ) ! add facets to node and prune added facets from list endif enddo enddo ! destroy void nodes (except root node) do level = self % refinement_levels , 1 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if (. not . node ( bbb )% has_facets ()) call node ( bbb )% destroy ! destroy void node enddo enddo ! update AABB extents do level = self % refinement_levels , 1 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree call node ( bbb )% update_extents ! update extents enddo enddo endif endassociate self % is_initialized = . true . endsubroutine initialize pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. intersections_number = 0 associate ( node => self % node ) do level = 0 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at finest level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( node ( bbb )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) then intersections_number = intersections_number + & node ( bbb )% ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) endif enddo enddo endassociate endfunction ray_intersections_number subroutine save_geometry_tecplot_ascii ( self , file_name ) !< Save AABB tree boxes geometry into Tecplot ascii file. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. character ( * ), intent ( in ) :: file_name !< File name. integer ( I4P ) :: file_unit !< File unit. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) if ( self % is_initialized ) then open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) write ( file_unit , '(A)' ) 'VARIABLES=x y z' do level = 0 , self % refinement_levels b = first_node ( level = level ) do bb = 1 , nodes_number_at_level ( level = level ) bbb = b + bb - 1 call node ( bbb )% save_geometry_tecplot_ascii ( file_unit = file_unit , aabb_name = 'aabb-l_' // trim ( str ( level , . true .)) // & '-b_' // trim ( str ( bbb , . true .))) enddo enddo close ( file_unit ) endif endassociate endsubroutine save_geometry_tecplot_ascii subroutine save_into_file_stl ( self , base_file_name , is_ascii ) !< Save  AABB tree boxes facets into files STL. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. character ( * ), intent ( in ) :: base_file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical :: is_ascii_ !< Sentinel to check if file is ASCII, local variable. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) if ( self % is_initialized ) then is_ascii_ = . false . ; if ( present ( is_ascii )) is_ascii_ = is_ascii do level = 0 , self % refinement_levels b = first_node ( level = level ) do bb = 1 , nodes_number_at_level ( level = level ) bbb = b + bb - 1 call node ( bbb )% save_facets_into_file_stl ( file_name = trim ( adjustl ( base_file_name )) // & 'aabb-l_' // trim ( str ( level , . true .)) // & '-b_' // trim ( str ( bbb , . true .)) // '.stl' , is_ascii = is_ascii_ ) enddo enddo endif endassociate endsubroutine save_into_file_stl ! operators ! = pure subroutine aabb_tree_assign_aabb_tree ( lhs , rhs ) !< Operator `=`. class ( aabb_tree_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_tree_object ), intent ( in ) :: rhs !< Right hand side. integer :: b !< Counter. if ( allocated ( lhs % node )) then do b = 1 , lhs % nodes_number call lhs % node % destroy enddo deallocate ( lhs % node ) endif lhs % refinement_levels = rhs % refinement_levels lhs % nodes_number = rhs % nodes_number if ( allocated ( rhs % node )) then allocate ( lhs % node ( 0 : lhs % nodes_number - 1 )) do b = 0 , lhs % nodes_number - 1 lhs % node ( b ) = rhs % node ( b ) enddo endif lhs % is_initialized = rhs % is_initialized endsubroutine aabb_tree_assign_aabb_tree ! non TBP pure function first_child_node ( node ) !< Return first child tree node. integer ( I4P ), intent ( in ) :: node !< Node queried. integer ( I4P ) :: first_child_node !< First child tree node. first_child_node = node * TREE_RATIO + 1 endfunction first_child_node pure function first_node ( level ) !< Return first tree node at a given level. integer ( I4P ), intent ( in ) :: level !< Refinement level queried. integer ( I4P ) :: first_node !< Number of tree nodes at given level. first_node = nodes_number ( refinement_levels = level - 1 ) endfunction first_node pure function nodes_number ( refinement_levels ) !< Return total number of tree nodes given the total number refinement levels used. integer ( I4P ), intent ( in ) :: refinement_levels !< Total number of refinement levels used. integer ( I4P ) :: nodes_number !< Total number of tree nodes. integer :: level !< Counter. nodes_number = 0 do level = 0 , refinement_levels nodes_number = nodes_number + nodes_number_at_level ( level = level ) enddo endfunction nodes_number pure function nodes_number_at_level ( level ) result ( nodes_number ) !< Return number of tree nodes at a given level. integer ( I4P ), intent ( in ) :: level !< Refinement level queried. integer ( I4P ) :: nodes_number !< Number of tree nodes at given level. nodes_number = TREE_RATIO ** ( level ) endfunction nodes_number_at_level pure function parent_node ( node ) !< Return parent tree node. integer ( I4P ), intent ( in ) :: node !< Node queried. integer ( I4P ) :: parent_node !< Parent tree node. parent_node = ( node - 1 ) / TREE_RATIO endfunction parent_node endmodule fossil_aabb_tree_object","tags":"","loc":"sourcefile/fossil_aabb_tree_object.f90.html","title":"fossil_aabb_tree_object.f90 – FOSSIL"},{"text":"FOSSIL, test load and write binary file. This File Depends On sourcefile~~fossil_test_load_save_binary.f90~~EfferentGraph sourcefile~fossil_test_load_save_binary.f90 fossil_test_load_save_binary.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_binary.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_load_save_binaryf90EfferentGraph = svgPanZoom('#sourcefilefossil_test_load_save_binaryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_load_save_binary Source Code fossil_test_load_save_binary.f90 Source Code !< FOSSIL, test load and write binary file. program fossil_test_load_save_binary !< FOSSIL, test load and write binary file. use fossil , only : file_stl_object use penf , only : R4P implicit none type ( file_stl_object ) :: file_1 !< STL file. type ( file_stl_object ) :: file_2 !< STL file. integer :: file_unit !< File unit. logical :: are_tests_passed ( 8 ) !< Result of tests check. are_tests_passed = . false . call file_1 % initialize ( file_name = 'src/tests/naca0012-binary.stl' , is_ascii = . false .) call file_1 % load_from_file are_tests_passed ( 1 ) = file_1 % facets_number == 188 are_tests_passed ( 2 ) = real ( file_1 % facet ( 5 )% vertex_2 % x , R4P ) == 0.683601_R4P are_tests_passed ( 3 ) = real ( file_1 % facet ( 5 )% vertex_2 % y , R4P ) == - 0.00763869_R4P are_tests_passed ( 4 ) = real ( file_1 % facet ( 5 )% vertex_2 % z , R4P ) == 0._R4P call file_1 % save_into_file ( file_name = 'fossil_test_load_save-naca0012-binary.stl' ) call file_2 % initialize ( file_name = 'fossil_test_load_save-naca0012-binary.stl' , is_ascii = . false .) call file_2 % load_from_file are_tests_passed ( 5 ) = file_2 % facets_number == 188 are_tests_passed ( 6 ) = real ( file_2 % facet ( 5 )% vertex_2 % x , R4P ) == 0.683601_R4P are_tests_passed ( 7 ) = real ( file_2 % facet ( 5 )% vertex_2 % y , R4P ) == - 0.00763869_R4P are_tests_passed ( 8 ) = real ( file_2 % facet ( 5 )% vertex_2 % z , R4P ) == 0._R4P print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) open ( newunit = file_unit , file = 'fossil_test_load_save-naca0012-binary.stl' ) close ( unit = file_unit , status = 'delete' ) endprogram fossil_test_load_save_binary","tags":"","loc":"sourcefile/fossil_test_load_save_binary.f90.html","title":"fossil_test_load_save_binary.f90 – FOSSIL"},{"text":"FOSSIL, test normals sanitization . This File Depends On sourcefile~~fossil_test_sanitize_normals.f90~~EfferentGraph sourcefile~fossil_test_sanitize_normals.f90 fossil_test_sanitize_normals.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_sanitize_normals.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_sanitize_normalsf90EfferentGraph = svgPanZoom('#sourcefilefossil_test_sanitize_normalsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_sanitize_normals Source Code fossil_test_sanitize_normals.f90 Source Code !< FOSSIL, test normals *sanitization*. program fossil_test_sanitize_normals !< FOSSIL, test normals *sanitization*. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) print * , 'volume before sanitize normals: ' , file_stl % volume are_tests_passed ( 1 ) = file_stl % volume < 0._R8P call file_stl % sanitize_normals call file_stl % compute_volume print * , 'volume after sanitize normals:  ' , file_stl % volume are_tests_passed ( 2 ) = nint ( file_stl % volume ) == 1 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_sanitize_normals' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_sanitize_normals --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube-inconsistent.stl' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse endprogram fossil_test_sanitize_normals","tags":"","loc":"sourcefile/fossil_test_sanitize_normals.f90.html","title":"fossil_test_sanitize_normals.f90 – FOSSIL"},{"text":"FOSSIL, test translate STL. This File Depends On sourcefile~~fossil_test_translate.f90~~EfferentGraph sourcefile~fossil_test_translate.f90 fossil_test_translate.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_translate.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_translatef90EfferentGraph = svgPanZoom('#sourcefilefossil_test_translatef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_translate Source Code fossil_test_translate.f90 Source Code !< FOSSIL, test translate STL. program fossil_test_translate !< FOSSIL, test translate STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: delta !< Vectorial delta. real ( R8P ) :: x , y , z !< Scalar deltas. logical :: are_tests_passed ( 4 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % translate ( delta = delta ) call file_stl % save_into_file ( file_name = 'fossil_test_translate-delta.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( delta =- delta ) call file_stl % translate ( x = x ) are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( y = y ) are_tests_passed ( 3 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( z = z ) are_tests_passed ( 4 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 2 * ez_R8P )) == 0 call file_stl % save_into_file ( file_name = 'fossil_test_translate-xyz.stl' ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: delta_ ( 3 ) !< Vectorial delta. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_translate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_translate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--delta' , & help = 'vectorial delta' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'delta x' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'delta y' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'delta z' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--delta' , val = delta_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop delta % x = delta_ ( 1 ) delta % y = delta_ ( 2 ) delta % z = delta_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_translate","tags":"","loc":"sourcefile/fossil_test_translate.f90.html","title":"fossil_test_translate.f90 – FOSSIL"},{"text":"FOSSIL, test distance computation. This File Depends On sourcefile~~fossil_test_distance.f90~~EfferentGraph sourcefile~fossil_test_distance.f90 fossil_test_distance.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_distance.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_distancef90EfferentGraph = svgPanZoom('#sourcefilefossil_test_distancef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_distance Source Code fossil_test_distance.f90 Source Code !< FOSSIL, test distance computation. program fossil_test_distance !< FOSSIL, test distance computation. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , I8P , R8P , str use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. type ( vector_R8P ), allocatable :: grid (:,:,:) !< Grid. real ( R8P ), allocatable :: distance (:,:,:) !< Distance of grid points to STL surface. character ( 999 ) :: file_name_stl !< Input STL file name. integer ( I4P ) :: refinement_levels !< AABB refinement levels used. logical :: save_aabb_tree_geometry !< Sentinel to save AABB geometry. logical :: save_aabb_tree_stl !< Sentinel to save AABB stl. logical :: test_brute_force !< Sentinel to test also brute force. character ( 999 ) :: sign_algorithm !< Algorithm used for \"point in polyhedron\" test. integer ( I4P ) :: ni , nj , nk !< Grid dimensions. integer ( I4P ) :: i , j , k !< Counter. real ( R8P ) :: Dx , Dy , Dz !< Space steps. integer ( I4P ) :: file_unit !< File unit. integer ( I8P ) :: timing ( 0 : 4 ) !< Tic toc timing. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % sanitize_normals print * , file_stl % statistics () call file_stl % create_aabb_tree ( refinement_levels = refinement_levels ) are_tests_passed = int ( file_stl % distance ( point = 0 * ex_R8P ), I4P ) == 0_I4P if ( save_aabb_tree_geometry ) call file_stl % aabb % save_geometry_tecplot_ascii ( file_name = 'fossil_test_distance_aabb_tree.dat' ) if ( save_aabb_tree_stl ) call file_stl % aabb % save_into_file_stl ( base_file_name = 'fossil_test_distance_' , is_ascii = . true .) associate ( bmin => file_stl % aabb % node ( 0 )% bmin (), bmax => file_stl % aabb % node ( 0 )% bmax ()) ni = 64 nj = 64 nk = 64 Dx = ( bmax % x - bmin % x ) / ni Dy = ( bmax % y - bmin % y ) / nj Dz = ( bmax % z - bmin % z ) / nk allocate ( grid ( - 4 : ni + 5 , - 4 : nj + 5 , - 4 : nk + 5 )) allocate ( distance ( - 4 : ni + 5 , - 4 : nj + 5 , - 4 : nk + 5 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 grid ( i , j , k ) = bmin + ( i * Dx ) * ex_R8P + ( j * Dy ) * ey_R8P + ( k * Dz ) * ez_R8P enddo enddo enddo endassociate if ( test_brute_force ) then file_stl % aabb % is_initialized = . false . print * , 'compute distances brute force' call system_clock ( timing ( 1 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 distance ( i , j , k ) = file_stl % distance ( point = grid ( i , j , k ), is_signed = . true ., sign_algorithm = trim ( sign_algorithm )) enddo enddo enddo call system_clock ( timing ( 2 ), timing ( 0 )) print * , 'brute force timing: ' , real ( timing ( 2 ) - timing ( 1 )) / timing ( 0 ) print * , 'save output' open ( newunit = file_unit , file = 'fossil_test_distance-brute.dat' ) write ( file_unit , '(A)' ) 'VARIABLES = x y z distance' write ( file_unit , '(A)' ) 'ZONE T=\"distance\", I=' // trim ( str ( ni + 10 )) // ', J=' // trim ( str ( nj + 10 )) // ', K=' // trim ( str ( nk + 10 )) // '' do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 write ( file_unit , '(A)' ) str ( grid ( i , j , k )% x ) // ' ' // str ( grid ( i , j , k )% y ) // ' ' // str ( grid ( i , j , k )% z ) // ' ' // str ( distance ( i , j , k )) enddo enddo enddo close ( file_unit ) endif file_stl % aabb % is_initialized = . true . print * , 'compute distances AABB' call system_clock ( timing ( 3 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 distance ( i , j , k ) = file_stl % distance ( point = grid ( i , j , k ), is_signed = . true ., sign_algorithm = trim ( sign_algorithm )) enddo enddo enddo call system_clock ( timing ( 4 ), timing ( 0 )) print * , 'AABB timing: ' , real ( timing ( 4 ) - timing ( 3 )) / timing ( 0 ) print * , 'save output' open ( newunit = file_unit , file = 'fossil_test_distance-aabb.dat' ) write ( file_unit , '(A)' ) 'VARIABLES = x y z distance' write ( file_unit , '(A)' ) 'ZONE T=\"distance\", I=' // trim ( str ( ni + 10 )) // ', J=' // trim ( str ( nj + 10 )) // ', K=' // trim ( str ( nk + 10 )) // '' do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 write ( file_unit , '(A)' ) str ( grid ( i , j , k )% x ) // ' ' // str ( grid ( i , j , k )% y ) // ' ' // str ( grid ( i , j , k )% z ) // ' ' // str ( distance ( i , j , k )) enddo enddo enddo close ( file_unit ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_distance' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_distance --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/naca0012-binary.stl' , & act = 'store' ) call cli % add ( switch = '--ref_levels' , & help = 'AABB refinement levels' , & required = . false ., & def = '2' , & act = 'store' ) call cli % add ( switch = '--save_aabb_tree_geometry' , & help = 'save AABB tree geometry' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--save_aabb_tree_stl' , & help = 'save AABB tree STL' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--brute_force' , & help = 'test (also) brute force' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--sign_algorithm' , & help = 'algorithm used to compute sign of distance' , & required = . false ., & def = 'ray_intersections' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ref_levels' , val = refinement_levels , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_geometry' , val = save_aabb_tree_geometry , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_stl' , val = save_aabb_tree_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--brute_force' , val = test_brute_force , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--sign_algorithm' , val = sign_algorithm , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse endprogram fossil_test_distance","tags":"","loc":"sourcefile/fossil_test_distance.f90.html","title":"fossil_test_distance.f90 – FOSSIL"},{"text":"FOSSIL, test load and write ASCII file. This File Depends On sourcefile~~fossil_test_load_save_ascii.f90~~EfferentGraph sourcefile~fossil_test_load_save_ascii.f90 fossil_test_load_save_ascii.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_load_save_ascii.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_load_save_asciif90EfferentGraph = svgPanZoom('#sourcefilefossil_test_load_save_asciif90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_load_save_ascii Source Code fossil_test_load_save_ascii.f90 Source Code !< FOSSIL, test load and write ASCII file. program fossil_test_load_save_ascii !< FOSSIL, test load and write ASCII file. use fossil , only : file_stl_object use penf , only : R8P implicit none type ( file_stl_object ) :: file_1 !< STL file. type ( file_stl_object ) :: file_2 !< STL file. integer :: file_unit !< File unit. logical :: are_tests_passed ( 8 ) !< Result of tests check. are_tests_passed = . false . call file_1 % initialize ( file_name = 'src/tests/naca0012-ascii.stl' , is_ascii = . true .) call file_1 % load_from_file are_tests_passed ( 1 ) = file_1 % facets_number == 188 are_tests_passed ( 2 ) = file_1 % facet ( 5 )% vertex_2 % x == 0.683601_R8P are_tests_passed ( 3 ) = file_1 % facet ( 5 )% vertex_2 % y == - 0.00763869_R8P are_tests_passed ( 4 ) = file_1 % facet ( 5 )% vertex_2 % z == 0._R8P call file_1 % save_into_file ( file_name = 'fossil_test_load_save-naca0012-ascii.stl' ) call file_2 % initialize ( file_name = 'fossil_test_load_save-naca0012-ascii.stl' , is_ascii = . true .) call file_2 % load_from_file are_tests_passed ( 5 ) = file_2 % facets_number == 188 are_tests_passed ( 6 ) = file_2 % facet ( 5 )% vertex_2 % x == 0.683601_R8P are_tests_passed ( 7 ) = file_2 % facet ( 5 )% vertex_2 % y == - 0.00763869_R8P are_tests_passed ( 8 ) = file_2 % facet ( 5 )% vertex_2 % z == 0._R8P print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) open ( newunit = file_unit , file = 'fossil_test_load_save-naca0012-ascii.stl' ) close ( unit = file_unit , status = 'delete' ) endprogram fossil_test_load_save_ascii","tags":"","loc":"sourcefile/fossil_test_load_save_ascii.f90.html","title":"fossil_test_load_save_ascii.f90 – FOSSIL"},{"text":"FOSSIL, test mirror STL. This File Depends On sourcefile~~fossil_test_mirror.f90~~EfferentGraph sourcefile~fossil_test_mirror.f90 fossil_test_mirror.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_mirror.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_mirrorf90EfferentGraph = svgPanZoom('#sourcefilefossil_test_mirrorf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_mirror Source Code fossil_test_mirror.f90 Source Code !< FOSSIL, test mirror STL. program fossil_test_mirror !< FOSSIL, test mirror STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: normal !< Normal of mirroring plane. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) print '(A)' , file_stl % statistics () call file_stl % mirror ( normal = normal ) call file_stl % save_into_file ( file_name = 'fossil_test_mirror.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 0 * ex_R8P - 1 * ey_R8P + 1 * ez_R8P )) == 1 are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 1 * ex_R8P - 1 * ey_R8P + 0 * ez_R8P )) == 1 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: normal_ ( 3 ) !< Normal of mirroring plane. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_mirror' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_mirror --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--normal' , & help = 'normal of mirroring plane' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--normal' , val = normal_ , error = error ) ; if ( error /= 0 ) stop normal % x = normal_ ( 1 ) normal % y = normal_ ( 2 ) normal % z = normal_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_mirror","tags":"","loc":"sourcefile/fossil_test_mirror.f90.html","title":"fossil_test_mirror.f90 – FOSSIL"},{"text":"FOSSIL, test resize STL. This File Depends On sourcefile~~fossil_test_resize.f90~~EfferentGraph sourcefile~fossil_test_resize.f90 fossil_test_resize.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_resize.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_resizef90EfferentGraph = svgPanZoom('#sourcefilefossil_test_resizef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_resize Source Code fossil_test_resize.f90 Source Code !< FOSSIL, test resize STL. program fossil_test_resize !< FOSSIL, test resize STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: factor !< Vectorial factor. real ( R8P ) :: x , y , z !< Scalar factors. logical :: are_tests_passed ( 4 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % resize ( factor = factor ) call file_stl % save_into_file ( file_name = 'fossil_test_resize-factor.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( factor = factor / 4._R8P ) call file_stl % resize ( x = x ) are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( y = y ) are_tests_passed ( 3 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( z = z ) are_tests_passed ( 4 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 2 * ez_R8P )) == 0 call file_stl % save_into_file ( file_name = 'fossil_test_resize-xyz.stl' ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: factor_ ( 3 ) !< Vectorial factor. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_resize' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_resize --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--factor' , & help = 'vectorial factor' , & required = . false ., & nargs = '+' , & def = '2.0 2.0 2.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'factor x' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'factor y' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'factor z' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--factor' , val = factor_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop factor % x = factor_ ( 1 ) factor % y = factor_ ( 2 ) factor % z = factor_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_resize","tags":"","loc":"sourcefile/fossil_test_resize.f90.html","title":"fossil_test_resize.f90 – FOSSIL"},{"text":"FOSSIL, test rotate STL. This File Depends On sourcefile~~fossil_test_rotate.f90~~EfferentGraph sourcefile~fossil_test_rotate.f90 fossil_test_rotate.f90 sourcefile~fossil.f90 fossil.f90 sourcefile~fossil.f90->sourcefile~fossil_test_rotate.f90 sourcefile~fossil_facet_object.f90 fossil_facet_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil.f90 sourcefile~fossil_file_stl_object.f90 fossil_file_stl_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_tree_object.f90 fossil_aabb_tree_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90 fossil_aabb_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_node_object.f90 fossil_aabb_node_object.f90 sourcefile~fossil_facet_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_file_stl_object.f90->sourcefile~fossil.f90 sourcefile~fossil_utils.f90 fossil_utils.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_facet_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_utils.f90->sourcefile~fossil_aabb_object.f90 sourcefile~fossil_aabb_tree_object.f90->sourcefile~fossil_file_stl_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_tree_object.f90 sourcefile~fossil_aabb_object.f90->sourcefile~fossil_aabb_node_object.f90 sourcefile~fossil_aabb_node_object.f90->sourcefile~fossil_aabb_tree_object.f90 var pansourcefilefossil_test_rotatef90EfferentGraph = svgPanZoom('#sourcefilefossil_test_rotatef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fossil_test_rotate Source Code fossil_test_rotate.f90 Source Code !< FOSSIL, test rotate STL. program fossil_test_rotate !< FOSSIL, test rotate STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: axis !< Axis of rotation. real ( R8P ) :: angle !< Angle of rotation. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % rotate ( axis = axis , angle = angle ) call file_stl % save_into_file ( file_name = 'fossil_test_rotate.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 0 * ex_R8P - 1 * ey_R8P + 1 * ez_R8P )) == 0 are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 1 * ex_R8P - 1 * ey_R8P + 0 * ez_R8P )) == 0 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: axis_ ( 3 ) !< Axis of rotation. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_rotate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_rotate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--axis' , & help = 'axis of rotation' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--angle' , & help = 'angle of rotation' , & required = . false ., & def = '1.57079633' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--axis' , val = axis_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--angle' , val = angle , error = error ) ; if ( error /= 0 ) stop axis % x = axis_ ( 1 ) axis % y = axis_ ( 2 ) axis % z = axis_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_rotate","tags":"","loc":"sourcefile/fossil_test_rotate.f90.html","title":"fossil_test_rotate.f90 – FOSSIL"},{"text":"type, public :: facet_object type~~facet_object~~InheritsGraph type~facet_object facet_object vector_R8P vector_R8P vector_R8P->type~facet_object normal, vertex_1, vertex_2, vertex_3, E12, E13, bb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOSSIL, facet class. Inherited By type~~facet_object~~InheritedByGraph type~facet_object facet_object type~aabb_object aabb_object type~facet_object->type~aabb_object facet type~file_stl_object file_stl_object type~facet_object->type~file_stl_object facet type~aabb_node_object aabb_node_object type~aabb_object->type~aabb_node_object aabb type~aabb_tree_object aabb_tree_object type~aabb_node_object->type~aabb_tree_object node type~aabb_tree_object->type~file_stl_object aabb var pantypefacet_objectInheritedByGraph = svgPanZoom('#typefacet_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables normal vertex_1 vertex_2 vertex_3 E12 E13 a b c det d bb id fcon_edge_12 fcon_edge_23 fcon_edge_31 vertex_1_occurrence vertex_2_occurrence vertex_3_occurrence Type-Bound Procedures add_vertex_occurrence check_normal check_vertices_occurrencies compute_metrix compute_normal destroy distance do_ray_intersect initialize load_from_file_ascii load_from_file_binary make_normal_consistent mirror reverse_normal resize rotate save_into_file_ascii save_into_file_binary solid_angle tetrahedron_volume translate update_connectivity vertex_global_id assignment(=) edge_connection_in_other_ref facet_assign_facet flip_edge mirror_by_normal mirror_by_matrix rotate_by_axis_angle rotate_by_matrix Source Code facet_object Components Type Visibility Attributes Name Initial type(vector_R8P), public :: normal Facet (outward) normal (versor), (v2-v1).cross.(v3-v1) . type(vector_R8P), public :: vertex_1 Facet vertex 1. type(vector_R8P), public :: vertex_2 Facet vertex 2. type(vector_R8P), public :: vertex_3 Facet vertex 3. type(vector_R8P), public :: E12 Edge 1-2, V2-V1 . type(vector_R8P), public :: E13 Edge 1-3, V3-V1 . real(kind=R8P), public :: a = 0._R8P E12.dot.E12 . real(kind=R8P), public :: b = 0._R8P E12.dot.E13 . real(kind=R8P), public :: c = 0._R8P E13.dot.E13 . real(kind=R8P), public :: det = 0._R8P a*c - b*b . real(kind=R8P), public :: d = 0._R8P normal.dot.vertex_1 type(vector_R8P), public :: bb (2) Axis-aligned bounding box (AABB), bb(1)=min, bb(2)=max. integer(kind=I4P), public :: id Facet global ID. integer(kind=I4P), public :: fcon_edge_12 = 0_I4P Connected face ID along edge 1-2. integer(kind=I4P), public :: fcon_edge_23 = 0_I4P Connected face ID along edge 2-3. integer(kind=I4P), public :: fcon_edge_31 = 0_I4P Connected face ID along edge 3-1. integer(kind=I4P), public, allocatable :: vertex_1_occurrence (:) List of vertex 1 \"occurrencies\", list of facets global ID containing it. integer(kind=I4P), public, allocatable :: vertex_2_occurrence (:) List of vertex 2 \"occurrencies\", list of facets global ID containing it. integer(kind=I4P), public, allocatable :: vertex_3_occurrence (:) List of vertex 3 \"occurrencies\", list of facets global ID containing it. Type-Bound Procedures procedure, public, pass(self) :: add_vertex_occurrence Add vertex occurence. private elemental subroutine add_vertex_occurrence (self, vertex_id, facet_id) Add vertex occurrence. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Vertex ID in local numeration, 1, 2 or 3. integer(kind=I4P), intent(in) :: facet_id Other facet ID containing vertex. procedure, public, pass(self) :: check_normal Check normal consistency. private elemental function check_normal (self) result(is_consistent) Check normal consistency. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. Return Value logical Consistency check result. procedure, public, pass(self) :: check_vertices_occurrencies Check if vertices of facet are identical to ones of other facet. private pure subroutine check_vertices_occurrencies (self, other) Check if vertices of facet are identical (with tollerance) to the ones of other facet. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type( facet_object ), intent(inout) :: other Other facet. procedure, public, pass(self) :: compute_metrix Compute local (plane) metrix. private elemental subroutine compute_metrix (self) Compute local (plane) metrix. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: compute_normal Compute normal by means of vertices data. private elemental subroutine compute_normal (self) Compute normal by means of vertices data. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: destroy Destroy facet. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: distance Compute the (unsigned, squared) distance from a point to facet. private pure function distance (self, point) Compute the (unsigned, squared) distance from a point to the facet surface. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Closest distance from point to the facet. procedure, public, pass(self) :: do_ray_intersect Return true if facet is intersected by a ray. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(intersect) Return true if facet is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Intersection test result. procedure, public, pass(self) :: initialize Initialize facet. private elemental subroutine initialize (self) Initialize facet. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: load_from_file_ascii Load facet from ASCII file. private subroutine load_from_file_ascii (self, file_unit) Load facet from ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: load_from_file_binary Load facet from binary file. private subroutine load_from_file_binary (self, file_unit) Load facet from binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: make_normal_consistent Make normal of other facet consistent with self. private pure subroutine make_normal_consistent (self, edge_dir, other) Make normal of other facet consistent with self. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. character(len=*), intent(in) :: edge_dir Edge (in self numeration) along which other is connected. type( facet_object ), intent(inout) :: other Other facet to make consistent with self. generic, public :: mirror => mirror_by_normal , mirror_by_matrix Mirror facet. private pure subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facet given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, public, pass(self) :: reverse_normal Reverse facet normal. private elemental subroutine reverse_normal (self) Reverse facet normal. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: resize Resize (scale) facet by x or y or z or vectorial factors. private elemental subroutine resize (self, factor, recompute_metrix) Resize (scale) facet by x or y or z or vectorial factors. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet type(vector_R8P), intent(in) :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. generic, public :: rotate => rotate_by_axis_angle , rotate_by_matrix Rotate facet. private pure subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facet given axis and angle. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, public, pass(self) :: save_into_file_ascii Save facet into ASCII file. private subroutine save_into_file_ascii (self, file_unit) Save facet into ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: save_into_file_binary Save facet into binary file. private subroutine save_into_file_binary (self, file_unit) Save facet into binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: solid_angle Return the (projected) solid angle of the facet with respect point. private pure function solid_angle (self, point) Return the (projected) solid angle of the facet with respect the point. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Solid angle. procedure, public, pass(self) :: tetrahedron_volume Return the volume of tetrahedron built by facet and a given apex. private pure function tetrahedron_volume (self, apex) result(volume) Return the volume of tetrahedron built by facet and a given apex. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: apex Tetrahedron apex. Return Value real(kind=R8P) Tetrahedron volume. procedure, public, pass(self) :: translate Translate facet given vectorial delta. private elemental subroutine translate (self, delta, recompute_metrix) Translate facet given vectorial delta. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: delta Translation delta. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, public, pass(self) :: update_connectivity Update facet connectivity. private pure subroutine update_connectivity (self) Update facet connectivity. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. procedure, public, pass(self) :: vertex_global_id Return the vertex global id given the local one. private pure function vertex_global_id (self, vertex_id) Return the vertex global id given the local one. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Local vertex id. Return Value integer(kind=I4P) Gloval vertex id. generic, public :: assignment(=) => facet_assign_facet Overload = . private pure subroutine facet_assign_facet (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: lhs Left hand side. type( facet_object ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: edge_connection_in_other_ref Return the edge of connection in the other reference. private pure subroutine edge_connection_in_other_ref (self, other, edge_dir, edge) Return the edge of connection in the other reference. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type( facet_object ), intent(in) :: other Other facet. character(len=*), intent(out) :: edge_dir Edge (in other numeration) along which self is connected. type(vector_R8P), intent(out) :: edge Edge (in other numeration) along which self is connected. procedure, private, pass(lhs) :: facet_assign_facet Operator = . private pure subroutine facet_assign_facet (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: lhs Left hand side. type( facet_object ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: flip_edge Flip facet edge. private pure subroutine flip_edge (self, edge_dir) Flip facet edge. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. character(len=*), intent(in) :: edge_dir Edge to be flipped. procedure, private, pass(self) :: mirror_by_normal Mirror facet given normal of mirroring plane. private pure subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facet given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: mirror_by_matrix Mirror facet given matrix. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: rotate_by_axis_angle Rotate facet given axis and angle. private pure subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facet given axis and angle. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: rotate_by_matrix Rotate facet given matrix. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code type :: facet_object !< FOSSIL, facet class. type ( vector_R8P ) :: normal !< Facet (outward) normal (versor), `(v2-v1).cross.(v3-v1)`. type ( vector_R8P ) :: vertex_1 !< Facet vertex 1. type ( vector_R8P ) :: vertex_2 !< Facet vertex 2. type ( vector_R8P ) :: vertex_3 !< Facet vertex 3. ! metrix ! triangle plane parametric equation: T(s,t) = B + s*E12 + t*E13 type ( vector_R8P ) :: E12 !< Edge 1-2, `V2-V1`. type ( vector_R8P ) :: E13 !< Edge 1-3, `V3-V1`. real ( R8P ) :: a = 0._R8P !< `E12.dot.E12`. real ( R8P ) :: b = 0._R8P !< `E12.dot.E13`. real ( R8P ) :: c = 0._R8P !< `E13.dot.E13`. real ( R8P ) :: det = 0._R8P !< `a*c - b*b`. ! triangle plane equation: nx*x + ny*y + nz*z - d = 0, normal == [nx, ny, nz] real ( R8P ) :: d = 0._R8P !< `normal.dot.vertex_1` ! auxiliary type ( vector_R8P ) :: bb ( 2 ) !< Axis-aligned bounding box (AABB), bb(1)=min, bb(2)=max. ! connectivity integer ( I4P ) :: id !< Facet global ID. integer ( I4P ) :: fcon_edge_12 = 0_I4P !< Connected face ID along edge 1-2. integer ( I4P ) :: fcon_edge_23 = 0_I4P !< Connected face ID along edge 2-3. integer ( I4P ) :: fcon_edge_31 = 0_I4P !< Connected face ID along edge 3-1. integer ( I4P ), allocatable :: vertex_1_occurrence (:) !< List of vertex 1 \"occurrencies\", list of facets global ID containing it. integer ( I4P ), allocatable :: vertex_2_occurrence (:) !< List of vertex 2 \"occurrencies\", list of facets global ID containing it. integer ( I4P ), allocatable :: vertex_3_occurrence (:) !< List of vertex 3 \"occurrencies\", list of facets global ID containing it. contains ! public methods procedure , pass ( self ) :: add_vertex_occurrence !< Add vertex occurence. procedure , pass ( self ) :: check_normal !< Check normal consistency. procedure , pass ( self ) :: check_vertices_occurrencies !< Check if vertices of facet are *identical* to ones of other facet. procedure , pass ( self ) :: compute_metrix !< Compute local (plane) metrix. procedure , pass ( self ) :: compute_normal !< Compute normal by means of vertices data. procedure , pass ( self ) :: destroy !< Destroy facet. procedure , pass ( self ) :: distance !< Compute the (unsigned, squared) distance from a point to facet. procedure , pass ( self ) :: do_ray_intersect !< Return true if facet is intersected by a ray. procedure , pass ( self ) :: initialize !< Initialize facet. procedure , pass ( self ) :: load_from_file_ascii !< Load facet from ASCII file. procedure , pass ( self ) :: load_from_file_binary !< Load facet from binary file. procedure , pass ( self ) :: make_normal_consistent !< Make normal of other facet consistent with self. generic :: mirror => mirror_by_normal , & mirror_by_matrix !< Mirror facet. procedure , pass ( self ) :: reverse_normal !< Reverse facet normal. procedure , pass ( self ) :: resize !< Resize (scale) facet by x or y or z or vectorial factors. generic :: rotate => rotate_by_axis_angle , & rotate_by_matrix !< Rotate facet. procedure , pass ( self ) :: save_into_file_ascii !< Save facet into ASCII file. procedure , pass ( self ) :: save_into_file_binary !< Save facet into binary file. procedure , pass ( self ) :: solid_angle !< Return the (projected) solid angle of the facet with respect point. procedure , pass ( self ) :: tetrahedron_volume !< Return the volume of tetrahedron built by facet and a given apex. procedure , pass ( self ) :: translate !< Translate facet given vectorial delta. procedure , pass ( self ) :: update_connectivity !< Update facet connectivity. procedure , pass ( self ) :: vertex_global_id !< Return the vertex global id given the local one. ! operators generic :: assignment ( = ) => facet_assign_facet !< Overload `=`. ! private methods procedure , pass ( self ), private :: edge_connection_in_other_ref !< Return the edge of connection in the other reference. procedure , pass ( lhs ), private :: facet_assign_facet !< Operator `=`. procedure , pass ( self ), private :: flip_edge !< Flip facet edge. procedure , pass ( self ), private :: mirror_by_normal !< Mirror facet given normal of mirroring plane. procedure , pass ( self ), private :: mirror_by_matrix !< Mirror facet given matrix. procedure , pass ( self ), private :: rotate_by_axis_angle !< Rotate facet given axis and angle. procedure , pass ( self ), private :: rotate_by_matrix !< Rotate facet given matrix. endtype facet_object","tags":"","loc":"type/facet_object.html","title":"facet_object – FOSSIL "},{"text":"type, public :: aabb_object type~~aabb_object~~InheritsGraph type~aabb_object aabb_object vector_R8P vector_R8P vector_R8P->type~aabb_object bmin, bmax type~facet_object facet_object vector_R8P->type~facet_object normal, vertex_1, vertex_2, vertex_3, E12, E13, bb type~facet_object->type~aabb_object facet Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOSSIL Axis-Aligned Bounding Box (AABB) class. Inherited By type~~aabb_object~~InheritedByGraph type~aabb_object aabb_object type~aabb_node_object aabb_node_object type~aabb_object->type~aabb_node_object aabb type~aabb_tree_object aabb_tree_object type~aabb_node_object->type~aabb_tree_object node type~file_stl_object file_stl_object type~aabb_tree_object->type~file_stl_object aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables bmin bmax facets_number facet Type-Bound Procedures add_facets closest_point compute_octants destroy distance distance_from_facets do_ray_intersect has_facets initialize is_inside ray_intersections_number save_geometry_tecplot_ascii save_facets_into_file_stl update_extents vertex assignment(=) aabb_assign_aabb Source Code aabb_object Components Type Visibility Attributes Name Initial type(vector_R8P), public :: bmin Minimum point of AABB. type(vector_R8P), public :: bmax Maximum point of AABB. integer(kind=I4P), public :: facets_number = 0 Facets number. type( facet_object ), public, allocatable :: facet (:) Facets. Type-Bound Procedures procedure, public, pass(self) :: add_facets Add facets to AABB. private subroutine add_facets (self, facet) Add facets to AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. procedure, public, pass(self) :: closest_point Return closest point on AABB from point reference. private pure function closest_point (self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. procedure, public, pass(self) :: compute_octants Compute AABB octants. private pure subroutine compute_octants (self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. procedure, public, pass(self) :: destroy Destroy AABB. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. procedure, public, pass(self) :: distance Return the (square) distance from point to AABB. private pure function distance (self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. procedure, public, pass(self) :: distance_from_facets Return the (square) distance from point to AABB's facets. private pure function distance_from_facets (self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. procedure, public, pass(self) :: do_ray_intersect Return true if AABB is intersected by ray. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. procedure, public, pass(self) :: has_facets Return true if AABB has facets. private pure function has_facets (self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. Return Value logical Check result. procedure, public, pass(self) :: initialize Initialize AABB. private pure subroutine initialize (self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. procedure, public, pass(self) :: is_inside Return the true if point is inside ABB. private pure function is_inside (self, point) Return the true if point is inside ABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value logical Check result. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB geometry into Tecplot ascii file. private subroutine save_geometry_tecplot_ascii (self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. procedure, public, pass(self) :: save_facets_into_file_stl Save facets into file STL. private subroutine save_facets_into_file_stl (self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. procedure, public, pass(self) :: update_extents Update AABB bounding box extents. private pure subroutine update_extents (self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. procedure, public, pass(self) :: vertex Return AABB vertices. private pure function vertex (self) Return AABB vertices. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. Return Value type(vector_R8P)\n  (8) AABB vertices. generic, public :: assignment(=) => aabb_assign_aabb Overload = . private pure subroutine aabb_assign_aabb (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: lhs Left hand side. type( aabb_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: aabb_assign_aabb Operator = . private pure subroutine aabb_assign_aabb (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: lhs Left hand side. type( aabb_object ), intent(in) :: rhs Right hand side. Source Code type :: aabb_object !< FOSSIL Axis-Aligned Bounding Box (AABB) class. type ( vector_R8P ) :: bmin !< Minimum point of AABB. type ( vector_R8P ) :: bmax !< Maximum point of AABB. integer ( I4P ) :: facets_number = 0 !< Facets number. type ( facet_object ), allocatable :: facet (:) !< Facets. contains ! public methods procedure , pass ( self ) :: add_facets !< Add facets to AABB. procedure , pass ( self ) :: closest_point !< Return closest point on AABB from point reference. procedure , pass ( self ) :: compute_octants !< Compute AABB octants. procedure , pass ( self ) :: destroy !< Destroy AABB. procedure , pass ( self ) :: distance !< Return the (square) distance from point to AABB. procedure , pass ( self ) :: distance_from_facets !< Return the (square) distance from point to AABB's facets. procedure , pass ( self ) :: do_ray_intersect !< Return true if AABB is intersected by ray. procedure , pass ( self ) :: has_facets !< Return true if AABB has facets. procedure , pass ( self ) :: initialize !< Initialize AABB. procedure , pass ( self ) :: is_inside !< Return the true if point is inside ABB. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB geometry into Tecplot ascii file. procedure , pass ( self ) :: save_facets_into_file_stl !< Save facets into file STL. procedure , pass ( self ) :: update_extents !< Update AABB bounding box extents. procedure , pass ( self ) :: vertex !< Return AABB vertices. ! operators generic :: assignment ( = ) => aabb_assign_aabb !< Overload `=`. procedure , pass ( lhs ), private :: aabb_assign_aabb !< Operator `=`. endtype aabb_object","tags":"","loc":"type/aabb_object.html","title":"aabb_object – FOSSIL "},{"text":"type, public :: file_stl_object type~~file_stl_object~~InheritsGraph type~file_stl_object file_stl_object vector_R8P vector_R8P vector_R8P->type~file_stl_object bmin, bmax type~facet_object facet_object vector_R8P->type~facet_object normal, vertex_1, vertex_2, vertex_3, E12, E13, bb type~aabb_object aabb_object vector_R8P->type~aabb_object bmin, bmax type~facet_object->type~file_stl_object facet type~facet_object->type~aabb_object facet type~aabb_tree_object aabb_tree_object type~aabb_tree_object->type~file_stl_object aabb type~aabb_node_object aabb_node_object type~aabb_node_object->type~aabb_tree_object node type~aabb_object->type~aabb_node_object aabb var pantypefile_stl_objectInheritsGraph = svgPanZoom('#typefile_stl_objectInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOSSIL STL file class. Variables file_name file_unit header facets_number facet aabb bmin bmax volume is_ascii is_open Type-Bound Procedures analize build_connectivity close_file compute_metrix compute_normals compute_volume create_aabb_tree destroy distance initialize is_point_inside_polyhedron_ri is_point_inside_polyhedron_sa load_from_file mirror open_file reverse_normals resize rotate sanitize_normals save_into_file statistics translate assignment(=) file_stl_assign_file_stl allocate_facets load_facets_number_from_file load_header_from_file mirror_by_normal mirror_by_matrix rotate_by_axis_angle rotate_by_matrix save_header_into_file save_trailer_into_file Source Code file_stl_object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_name File name integer(kind=I4P), public :: file_unit = 0 File unit. character(len=FRLEN), public :: header File header. integer(kind=I4P), public :: facets_number = 0 Facets number. type( facet_object ), public, allocatable :: facet (:) Facets. type( aabb_tree_object ), public :: aabb AABB tree. type(vector_R8P), public :: bmin Minimum point of STL. type(vector_R8P), public :: bmax Maximum point of STL. real(kind=R8P), public :: volume = 0._R8P Volume bounded by STL surface. logical, public :: is_ascii = .true. Sentinel to check if file is ASCII. logical, public :: is_open = .false. Sentinel to check if file is open. Type-Bound Procedures procedure, public, pass(self) :: analize Analize STL. private pure subroutine analize (self) Analize STL. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: build_connectivity Build facets connectivity. private pure subroutine build_connectivity (self) Build facets connectivity. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: close_file Close file. private subroutine close_file (self) Close file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: compute_metrix Compute facets metrix. private pure subroutine compute_metrix (self) Compute facets metrix. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: compute_normals Compute facets normals by means of vertices data. private elemental subroutine compute_normals (self) Compute facets normals by means of vertices data. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: compute_volume Compute volume bounded by STL surface. private elemental subroutine compute_volume (self) Compute volume bounded by STL surface. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: create_aabb_tree Create the AABB tree. private subroutine create_aabb_tree (self, refinement_levels) Create AABB tree. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. integer(kind=I4P), intent(in), optional :: refinement_levels Total number of refinement levels used. procedure, public, pass(self) :: destroy Destroy file. private elemental subroutine destroy (self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: distance Compute the (minimum) distance from point to triangulated surface. private pure function distance (self, point, is_signed, sign_algorithm, is_square_root) Compute the (minimum) distance from a point to the triangulated surface. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. logical, intent(in), optional :: is_signed Sentinel to trigger signed distance. character(len=*), intent(in), optional :: sign_algorithm Algorithm used for \"point in polyhedron\" test. logical, intent(in), optional :: is_square_root Sentinel to trigger square-root distance. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. procedure, public, pass(self) :: initialize Initialize file. private elemental subroutine initialize (self, skip_destroy, file_name, is_ascii) Initialize file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. logical, intent(in), optional :: skip_destroy Flag to skip destroy file. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. procedure, public, pass(self) :: is_point_inside_polyhedron_ri Determinate is point is inside or not STL facets by ray intersect. private pure function is_point_inside_polyhedron_ri (self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means ray intersections count. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. procedure, public, pass(self) :: is_point_inside_polyhedron_sa Determinate is point is inside or not STL facets by solid angle. private pure function is_point_inside_polyhedron_sa (self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means of the solid angle criteria. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, file_name, is_ascii, guess_format, disable_analysis) Load from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. logical, intent(in), optional :: disable_analysis Sentinel to disable STL analysis. generic, public :: mirror => mirror_by_normal , mirror_by_matrix Mirror facets. private elemental subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facets given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, public, pass(self) :: open_file Open file, once initialized. private subroutine open_file (self, file_action, guess_format) Open file, once initialized. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in) :: file_action File action, \"read\" or \"write\". logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. procedure, public, pass(self) :: reverse_normals Reverse facets normals. private elemental subroutine reverse_normals (self) Reverse facets normals. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: resize Resize (scale) facets by x or y or z or vectorial factors. private elemental subroutine resize (self, x, y, z, factor, recompute_metrix) Resize (scale) facets by x or y or z or vectorial factors. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Factor along x axis. real(kind=R8P), intent(in), optional :: y Factor along y axis. real(kind=R8P), intent(in), optional :: z Factor along z axis. type(vector_R8P), intent(in), optional :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. generic, public :: rotate => rotate_by_axis_angle , rotate_by_matrix Rotate facets. private elemental subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facets given axis and angle. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, public, pass(self) :: sanitize_normals Sanitize facets normals, make them consistent. private pure subroutine sanitize_normals (self) Sanitize facets normals, make them consistent. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, file_name, is_ascii) Save into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. procedure, public, pass(self) :: statistics Return STL statistics. private pure function statistics (self, prefix) result(stats) Return STL statistics. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. character(len=*), intent(in), optional :: prefix Lines prefix. Return Value character(len=:),\n  allocatable STL statistics. procedure, public, pass(self) :: translate Translate facet given vectorial delta. private elemental subroutine translate (self, x, y, z, delta, recompute_metrix) Translate facets x or y or z or vectorial delta increments. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Increment along x axis. real(kind=R8P), intent(in), optional :: y Increment along y axis. real(kind=R8P), intent(in), optional :: z Increment along z axis. type(vector_R8P), intent(in), optional :: delta Vectorial increment. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. generic, public :: assignment(=) => file_stl_assign_file_stl Overload = . private pure subroutine file_stl_assign_file_stl (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: lhs Left hand side. type( file_stl_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: file_stl_assign_file_stl Operator = . private pure subroutine file_stl_assign_file_stl (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: lhs Left hand side. type( file_stl_object ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: allocate_facets Allocate facets. private elemental subroutine allocate_facets (self) Allocate facets. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, private, pass(self) :: load_facets_number_from_file Load facets number from file. private subroutine load_facets_number_from_file (self) Load facets number from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, private, pass(self) :: load_header_from_file Load header from file. private subroutine load_header_from_file (self) Load header from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, private, pass(self) :: mirror_by_normal Mirror facets given normal of mirroring plane. private elemental subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facets given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: mirror_by_matrix Mirror facets given matrix. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: rotate_by_axis_angle Rotate facets given axis and angle. private elemental subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facets given axis and angle. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: rotate_by_matrix Rotate facets given matrix. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. procedure, private, pass(self) :: save_header_into_file Save header into file. private subroutine save_header_into_file (self) Save header into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. procedure, private, pass(self) :: save_trailer_into_file Save trailer into file. private subroutine save_trailer_into_file (self) Save trailer into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code type :: file_stl_object !< FOSSIL STL file class. character ( len = :), allocatable :: file_name !< File name integer ( I4P ) :: file_unit = 0 !< File unit. character ( FRLEN ) :: header !< File header. integer ( I4P ) :: facets_number = 0 !< Facets number. type ( facet_object ), allocatable :: facet (:) !< Facets. type ( aabb_tree_object ) :: aabb !< AABB tree. type ( vector_R8P ) :: bmin !< Minimum point of STL. type ( vector_R8P ) :: bmax !< Maximum point of STL. real ( R8P ) :: volume = 0._R8P !< Volume bounded by STL surface. logical :: is_ascii = . true . !< Sentinel to check if file is ASCII. logical :: is_open = . false . !< Sentinel to check if file is open. contains ! public methods procedure , pass ( self ) :: analize !< Analize STL. procedure , pass ( self ) :: build_connectivity !< Build facets connectivity. procedure , pass ( self ) :: close_file !< Close file. procedure , pass ( self ) :: compute_metrix !< Compute facets metrix. procedure , pass ( self ) :: compute_normals !< Compute facets normals by means of vertices data. procedure , pass ( self ) :: compute_volume !< Compute volume bounded by STL surface. procedure , pass ( self ) :: create_aabb_tree !< Create the AABB tree. procedure , pass ( self ) :: destroy !< Destroy file. procedure , pass ( self ) :: distance !< Compute the (minimum) distance from point to triangulated surface. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: is_point_inside_polyhedron_ri !< Determinate is point is inside or not STL facets by ray intersect. procedure , pass ( self ) :: is_point_inside_polyhedron_sa !< Determinate is point is inside or not STL facets by solid angle. procedure , pass ( self ) :: load_from_file !< Load from file. generic :: mirror => mirror_by_normal , & mirror_by_matrix !< Mirror facets. procedure , pass ( self ) :: open_file !< Open file, once initialized. procedure , pass ( self ) :: reverse_normals !< Reverse facets normals. procedure , pass ( self ) :: resize !< Resize (scale) facets by x or y or z or vectorial factors. generic :: rotate => rotate_by_axis_angle , & rotate_by_matrix !< Rotate facets. procedure , pass ( self ) :: sanitize_normals !< Sanitize facets normals, make them consistent. procedure , pass ( self ) :: save_into_file !< Save into file. procedure , pass ( self ) :: statistics !< Return STL statistics. procedure , pass ( self ) :: translate !< Translate facet given vectorial delta. ! operators generic :: assignment ( = ) => file_stl_assign_file_stl !< Overload `=`. procedure , pass ( lhs ), private :: file_stl_assign_file_stl !< Operator `=`. ! private methods procedure , pass ( self ), private :: allocate_facets !< Allocate facets. procedure , pass ( self ), private :: load_facets_number_from_file !< Load facets number from file. procedure , pass ( self ), private :: load_header_from_file !< Load header from file. procedure , pass ( self ), private :: mirror_by_normal !< Mirror facets given normal of mirroring plane. procedure , pass ( self ), private :: mirror_by_matrix !< Mirror facets given matrix. procedure , pass ( self ), private :: rotate_by_axis_angle !< Rotate facets given axis and angle. procedure , pass ( self ), private :: rotate_by_matrix !< Rotate facets given matrix. procedure , pass ( self ), private :: save_header_into_file !< Save header into file. procedure , pass ( self ), private :: save_trailer_into_file !< Save trailer into file. endtype file_stl_object","tags":"","loc":"type/file_stl_object.html","title":"file_stl_object – FOSSIL "},{"text":"type, public :: aabb_node_object type~~aabb_node_object~~InheritsGraph type~aabb_node_object aabb_node_object type~aabb_object aabb_object type~aabb_object->type~aabb_node_object aabb vector_R8P vector_R8P vector_R8P->type~aabb_object bmin, bmax type~facet_object facet_object vector_R8P->type~facet_object normal, vertex_1, vertex_2, vertex_3, E12, E13, bb type~facet_object->type~aabb_object facet var pantypeaabb_node_objectInheritsGraph = svgPanZoom('#typeaabb_node_objectInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOSSIL Axis-Aligned Bounding Box (AABB) tree-node class. Inherited By type~~aabb_node_object~~InheritedByGraph type~aabb_node_object aabb_node_object type~aabb_tree_object aabb_tree_object type~aabb_node_object->type~aabb_tree_object node type~file_stl_object file_stl_object type~aabb_tree_object->type~file_stl_object aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables aabb Type-Bound Procedures add_facets bmin bmax closest_point compute_octants destroy distance distance_from_facets do_ray_intersect has_facets initialize is_allocated ray_intersections_number save_geometry_tecplot_ascii save_facets_into_file_stl update_extents assignment(=) aabb_node_assign_aabb_node Source Code aabb_node_object Components Type Visibility Attributes Name Initial type( aabb_object ), private, allocatable :: aabb AABB data. Type-Bound Procedures procedure, public, pass(self) :: add_facets Add facets to AABB. private subroutine add_facets (self, facet) Add facets to AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. procedure, public, pass(self) :: bmin Return AABB bmin. private pure function bmin (self) Return AABB bmin. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmin. procedure, public, pass(self) :: bmax Return AABB bmax. private pure function bmax (self) Return AABB bmax. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmax. procedure, public, pass(self) :: closest_point Return closest point on AABB from point reference. private pure function closest_point (self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. procedure, public, pass(self) :: compute_octants Compute AABB octants. private pure subroutine compute_octants (self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. procedure, public, pass(self) :: destroy Destroy AABB. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. procedure, public, pass(self) :: distance Return the (square) distance from point to AABB. private pure function distance (self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. procedure, public, pass(self) :: distance_from_facets Return the (square) distance from point to AABB's facets. private pure function distance_from_facets (self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. procedure, public, pass(self) :: do_ray_intersect Return true if AABB is intersected by ray. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. procedure, public, pass(self) :: has_facets Return true if AABB has facets. private pure function has_facets (self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. procedure, public, pass(self) :: initialize Initialize AABB. private pure subroutine initialize (self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. procedure, public, pass(self) :: is_allocated Return true is node is allocated. private pure function is_allocated (self) Return true if node is allocated. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB geometry into Tecplot ascii file. private subroutine save_geometry_tecplot_ascii (self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. procedure, public, pass(self) :: save_facets_into_file_stl Save facets into file STL. private subroutine save_facets_into_file_stl (self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. procedure, public, pass(self) :: update_extents Update AABB bounding box extents. private pure subroutine update_extents (self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. generic, public :: assignment(=) => aabb_node_assign_aabb_node Overload = . private pure subroutine aabb_node_assign_aabb_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: lhs Left hand side. type( aabb_node_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: aabb_node_assign_aabb_node Operator = . private pure subroutine aabb_node_assign_aabb_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: lhs Left hand side. type( aabb_node_object ), intent(in) :: rhs Right hand side. Source Code type :: aabb_node_object !< FOSSIL Axis-Aligned Bounding Box (AABB) tree-node class. private type ( aabb_object ), allocatable :: aabb !< AABB data. contains ! public methods procedure , pass ( self ) :: add_facets !< Add facets to AABB. procedure , pass ( self ) :: bmin !< Return AABB bmin. procedure , pass ( self ) :: bmax !< Return AABB bmax. procedure , pass ( self ) :: closest_point !< Return closest point on AABB from point reference. procedure , pass ( self ) :: compute_octants !< Compute AABB octants. procedure , pass ( self ) :: destroy !< Destroy AABB. procedure , pass ( self ) :: distance !< Return the (square) distance from point to AABB. procedure , pass ( self ) :: distance_from_facets !< Return the (square) distance from point to AABB's facets. procedure , pass ( self ) :: do_ray_intersect !< Return true if AABB is intersected by ray. procedure , pass ( self ) :: has_facets !< Return true if AABB has facets. procedure , pass ( self ) :: initialize !< Initialize AABB. procedure , pass ( self ) :: is_allocated !< Return true is node is allocated. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB geometry into Tecplot ascii file. procedure , pass ( self ) :: save_facets_into_file_stl !< Save facets into file STL. procedure , pass ( self ) :: update_extents !< Update AABB bounding box extents. ! operators generic :: assignment ( = ) => aabb_node_assign_aabb_node !< Overload `=`. procedure , pass ( lhs ), private :: aabb_node_assign_aabb_node !< Operator `=`. endtype aabb_node_object","tags":"","loc":"type/aabb_node_object.html","title":"aabb_node_object – FOSSIL "},{"text":"type, public :: aabb_tree_object type~~aabb_tree_object~~InheritsGraph type~aabb_tree_object aabb_tree_object type~aabb_node_object aabb_node_object type~aabb_node_object->type~aabb_tree_object node type~aabb_object aabb_object type~aabb_object->type~aabb_node_object aabb vector_R8P vector_R8P vector_R8P->type~aabb_object bmin, bmax type~facet_object facet_object vector_R8P->type~facet_object normal, vertex_1, vertex_2, vertex_3, E12, E13, bb type~facet_object->type~aabb_object facet var pantypeaabb_tree_objectInheritsGraph = svgPanZoom('#typeaabb_tree_objectInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOSSIL Axis-Aligned Bounding Box (AABB) tree class. Note The tree is assumed to be an octree . Inherited By type~~aabb_tree_object~~InheritedByGraph type~aabb_tree_object aabb_tree_object type~file_stl_object file_stl_object type~aabb_tree_object->type~file_stl_object aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables refinement_levels nodes_number node is_initialized Type-Bound Procedures destroy distance initialize ray_intersections_number save_geometry_tecplot_ascii save_into_file_stl assignment(=) aabb_tree_assign_aabb_tree Source Code aabb_tree_object Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: refinement_levels = 0 Total number of refinement levels used. integer(kind=I4P), public :: nodes_number = 0 Total number of tree nodes. type( aabb_node_object ), public, allocatable :: node (:) AABB tree nodes [0:nodes_number-1]. logical, public :: is_initialized = .false. Sentinel to check is AABB tree is initialized. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy AABB tree. private elemental subroutine destroy (self) Destroy AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. procedure, public, pass(self) :: distance Compute the (minimum) distance from point to triangulated surface. private pure function distance (self, point) Compute the (minimum) distance from a point to the triangulated surface. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: point Point coordinates. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. procedure, public, pass(self) :: initialize Initialize AABB tree. private subroutine initialize (self, refinement_levels, facet, bmin, bmax) Initialize AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. integer(kind=I4P), intent(in) :: refinement_levels Total number of refinement levels used. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB tree boxes geometry into Tecplot ascii file. private subroutine save_geometry_tecplot_ascii (self, file_name) Save AABB tree boxes geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: file_name File name. procedure, public, pass(self) :: save_into_file_stl Save  AABB tree boxes facets into files STL. private subroutine save_into_file_stl (self, base_file_name, is_ascii) Save  AABB tree boxes facets into files STL. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: base_file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. generic, public :: assignment(=) => aabb_tree_assign_aabb_tree Overload = . private pure subroutine aabb_tree_assign_aabb_tree (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: lhs Left hand side. type( aabb_tree_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: aabb_tree_assign_aabb_tree Operator = . private pure subroutine aabb_tree_assign_aabb_tree (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: lhs Left hand side. type( aabb_tree_object ), intent(in) :: rhs Right hand side. Source Code type :: aabb_tree_object !< FOSSIL Axis-Aligned Bounding Box (AABB) tree class. !< !< @note The tree is assumed to be an **octree**. integer ( I4P ) :: refinement_levels = 0 !< Total number of refinement levels used. integer ( I4P ) :: nodes_number = 0 !< Total number of tree nodes. type ( aabb_node_object ), allocatable :: node (:) !< AABB tree nodes [0:nodes_number-1]. logical :: is_initialized = . false . !< Sentinel to check is AABB tree is initialized. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy AABB tree. procedure , pass ( self ) :: distance !< Compute the (minimum) distance from point to triangulated surface. procedure , pass ( self ) :: initialize !< Initialize AABB tree. procedure , pass ( self ) :: ray_intersections_number !< Return ray intersections number. procedure , pass ( self ) :: save_geometry_tecplot_ascii !< Save AABB tree boxes geometry into Tecplot ascii file. procedure , pass ( self ) :: save_into_file_stl !< Save  AABB tree boxes facets into files STL. ! operators generic :: assignment ( = ) => aabb_tree_assign_aabb_tree !< Overload `=`. procedure , pass ( lhs ), private :: aabb_tree_assign_aabb_tree !< Operator `=`. endtype aabb_tree_object","tags":"","loc":"type/aabb_tree_object.html","title":"aabb_tree_object – FOSSIL "},{"text":"private elemental function check_normal(self) result(is_consistent) Check normal consistency. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. Return Value logical Consistency check result. Calls proc~~check_normal~~CallsGraph proc~check_normal check_normal face_normal3_r8p face_normal3_r8p proc~check_normal->face_normal3_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_normal Source Code elemental function check_normal ( self ) result ( is_consistent ) !< Check normal consistency. class ( facet_object ), intent ( in ) :: self !< Facet. logical :: is_consistent !< Consistency check result. type ( vector_R8P ) :: normal !< Normal computed by means of vertices data. normal = face_normal3_R8P ( pt1 = self % vertex_1 , pt2 = self % vertex_2 , pt3 = self % vertex_3 , norm = 'y' ) is_consistent = (( abs ( normal % x - self % normal % x ) <= 2 * ZeroR8P ). and .& ( abs ( normal % y - self % normal % y ) <= 2 * ZeroR8P ). and .& ( abs ( normal % z - self % normal % z ) <= 2 * ZeroR8P )) endfunction check_normal","tags":"","loc":"proc/check_normal.html","title":"check_normal – FOSSIL"},{"text":"private pure function distance(self, point) Compute the (unsigned, squared) distance from a point to the facet surface. Note Facet's metrix must be already computed. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Closest distance from point to the facet.","tags":"","loc":"proc/distance.html","title":"distance – FOSSIL"},{"text":"private pure function do_ray_intersect(self, ray_origin, ray_direction) result(intersect) Return true if facet is intersected by ray from origin and oriented as ray direction vector. This based on Moller–Trumbore intersection algorithm. Note Facet's metrix must be already computed. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Intersection test result. Source Code do_ray_intersect Source Code pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( intersect ) !< Return true if facet is intersected by ray from origin and oriented as ray direction vector. !< !< This based on Moller–Trumbore intersection algorithm. !< !< @note Facet's metrix must be already computed. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: intersect !< Intersection test result. type ( vector_R8P ) :: h , s , q !< Projection vectors. real ( R8P ) :: a , f , u , v , t !< Baricentric abscissa. intersect = . false . h = ray_direction . cross . self % E13 a = self % E12 . dot . h if (( a > - EPS ). and .( a < EPS )) return f = 1._R8P / a s = ray_origin - self % vertex_1 u = f * ( s . dot . h ) if (( u < 0._R8P ). or .( u > 1._R8P )) return q = s . cross . self % E12 v = f * ray_direction . dot . q if (( v < 0._R8P ). or .( u + v > 1._R8P )) return t = f * self % E13 . dot . q if ( t > EPS ) intersect = . true . endfunction do_ray_intersect","tags":"","loc":"proc/do_ray_intersect.html","title":"do_ray_intersect – FOSSIL"},{"text":"private pure function solid_angle(self, point) Return the (projected) solid angle of the facet with respect the point. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Solid angle. Source Code solid_angle Source Code pure function solid_angle ( self , point ) !< Return the (projected) solid angle of the facet with respect the point. class ( facet_object ), intent ( in ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: point !< Point. real ( R8P ) :: solid_angle !< Solid angle. type ( vector_R8P ) :: R1 , R2 , R3 !< Edges from point to facet vertices. real ( R8P ) :: R1_norm , R2_norm , R3_norm !< Norms (L2) of edges from point to facet vertices. real ( R8P ) :: numerator !< Archtangent numerator. real ( R8P ) :: denominator !< Archtangent denominator. R1 = self % vertex_1 - point ; R1_norm = R1 % normL2 () R2 = self % vertex_2 - point ; R2_norm = R2 % normL2 () R3 = self % vertex_3 - point ; R3_norm = R3 % normL2 () numerator = R1 . dot .( R2 . cross . R3 ) denominator = R1_norm * R2_norm * R3_norm + ( R1 . dot . R2 ) * R3_norm + & ( R1 . dot . R3 ) * R2_norm + & ( R2 . dot . R3 ) * R1_norm solid_angle = 2._R8P * atan2 ( numerator , denominator ) endfunction solid_angle","tags":"","loc":"proc/solid_angle.html","title":"solid_angle – FOSSIL"},{"text":"private pure function tetrahedron_volume(self, apex) result(volume) Return the volume of tetrahedron built by facet and a given apex. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: apex Tetrahedron apex. Return Value real(kind=R8P) Tetrahedron volume. Calls proc~~tetrahedron_volume~~CallsGraph proc~tetrahedron_volume tetrahedron_volume norml2_r8p norml2_r8p proc~tetrahedron_volume->norml2_r8p angle_r8p angle_r8p proc~tetrahedron_volume->angle_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/tetrahedron_volume.html","title":"tetrahedron_volume – FOSSIL"},{"text":"private pure function vertex_global_id(self, vertex_id) Return the vertex global id given the local one. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Local vertex id. Return Value integer(kind=I4P) Gloval vertex id. Source Code vertex_global_id Source Code pure function vertex_global_id ( self , vertex_id ) !< Return the vertex global id given the local one. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: vertex_id !< Local vertex id. integer ( I4P ) :: vertex_global_id !< Gloval vertex id. vertex_global_id = ( self % id - 1 ) * 3 + vertex_id endfunction vertex_global_id","tags":"","loc":"proc/vertex_global_id.html","title":"vertex_global_id – FOSSIL"},{"text":"private elemental subroutine add_vertex_occurrence(self, vertex_id, facet_id) Add vertex occurrence. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Vertex ID in local numeration, 1, 2 or 3. integer(kind=I4P), intent(in) :: facet_id Other facet ID containing vertex. Source Code add_vertex_occurrence Source Code elemental subroutine add_vertex_occurrence ( self , vertex_id , facet_id ) !< Add vertex occurrence. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: vertex_id !< Vertex ID in local numeration, 1, 2 or 3. integer ( I4P ), intent ( in ) :: facet_id !< Other facet ID containing vertex. select case ( vertex_id ) case ( 1 ) call add_occurrence ( occurrence = self % vertex_1_occurrence ) case ( 2 ) call add_occurrence ( occurrence = self % vertex_2_occurrence ) case ( 3 ) call add_occurrence ( occurrence = self % vertex_3_occurrence ) endselect contains pure subroutine add_occurrence ( occurrence ) !< Add new occurrence into a generic occurrencies array. integer ( I4P ), allocatable , intent ( inout ) :: occurrence (:) !< Occurrences array. integer ( I4P ), allocatable :: occurrence_tmp (:) !< Temporary occurences array. integer ( I4P ) :: no !< Occurrences number. if ( allocated ( occurrence )) then no = size ( occurrence , dim = 1 ) allocate ( occurrence_tmp ( 1 : no + 1 )) occurrence_tmp ( 1 : no ) = occurrence occurrence_tmp ( no + 1 ) = facet_id call move_alloc ( from = occurrence_tmp , to = occurrence ) else allocate ( occurrence ( 1 )) occurrence ( 1 ) = facet_id endif endsubroutine add_occurrence endsubroutine add_vertex_occurrence","tags":"","loc":"proc/add_vertex_occurrence.html","title":"add_vertex_occurrence – FOSSIL"},{"text":"private pure subroutine check_vertices_occurrencies(self, other) Check if vertices of facet are identical (with tollerance) to the ones of other facet. If multiple occurrencies are found the counters are updated. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type( facet_object ), intent(inout) :: other Other facet. Source Code check_vertices_occurrencies Source Code pure subroutine check_vertices_occurrencies ( self , other ) !< Check if vertices of facet are *identical* (with tollerance) to the ones of other facet. !< !< If multiple occurrencies are found the counters are updated. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ), intent ( inout ) :: other !< Other facet. if ( check_pair ( self % vertex_1 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_1 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_1 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 1 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif if ( check_pair ( self % vertex_2 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_2 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_2 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 2 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif if ( check_pair ( self % vertex_3 , other % vertex_1 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 1 , facet_id = self % id ) elseif ( check_pair ( self % vertex_3 , other % vertex_2 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 2 , facet_id = self % id ) elseif ( check_pair ( self % vertex_3 , other % vertex_3 )) then call self % add_vertex_occurrence ( vertex_id = 3 , facet_id = other % id ) call other % add_vertex_occurrence ( vertex_id = 3 , facet_id = self % id ) endif contains pure function check_pair ( a , b ) !< Check equality of vertices pair. type ( vector_R8P ), intent ( in ) :: a , b !< Vertices pair. logical :: check_pair !< Check result. check_pair = (( abs ( a % x - b % x ) <= EPS ). and .( abs ( a % y - b % y ) <= EPS ). and .( abs ( a % z - b % z ) <= EPS )) endfunction check_pair endsubroutine check_vertices_occurrencies","tags":"","loc":"proc/check_vertices_occurrencies.html","title":"check_vertices_occurrencies – FOSSIL"},{"text":"private elemental subroutine compute_metrix(self) Compute local (plane) metrix. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Source Code compute_metrix Source Code elemental subroutine compute_metrix ( self ) !< Compute local (plane) metrix. class ( facet_object ), intent ( inout ) :: self !< Facet. call self % compute_normal self % E12 = self % vertex_2 - self % vertex_1 self % E13 = self % vertex_3 - self % vertex_1 self % a = self % E12 . dot . self % E12 self % b = self % E12 . dot . self % E13 self % c = self % E13 . dot . self % E13 self % det = self % a * self % c - self % b * self % b self % d = self % normal . dot . self % vertex_1 self % bb ( 1 )% x = min ( self % vertex_1 % x , self % vertex_2 % x , self % vertex_3 % x ) self % bb ( 1 )% y = min ( self % vertex_1 % y , self % vertex_2 % y , self % vertex_3 % y ) self % bb ( 1 )% z = min ( self % vertex_1 % z , self % vertex_2 % z , self % vertex_3 % z ) self % bb ( 2 )% x = max ( self % vertex_1 % x , self % vertex_2 % x , self % vertex_3 % x ) self % bb ( 2 )% y = max ( self % vertex_1 % y , self % vertex_2 % y , self % vertex_3 % y ) self % bb ( 2 )% z = max ( self % vertex_1 % z , self % vertex_2 % z , self % vertex_3 % z ) endsubroutine compute_metrix","tags":"","loc":"proc/compute_metrix.html","title":"compute_metrix – FOSSIL"},{"text":"private elemental subroutine compute_normal(self) Compute normal by means of vertices data. type ( facet_object ) :: facet facet % vertex_1 = - 0.231369_R4P * ex_R4P + 0.0226865_R4P * ey_R4P + 1._R4P * ez_R4P facet % vertex_2 = - 0.227740_R4P * ex_R4P + 0.0245457_R4P * ey_R4P + 0._R4P * ez_R4P facet % vertex_2 = - 0.235254_R4P * ex_R4P + 0.0201881_R4P * ey_R4P + 0._R4P * ez_R4P call facet % sanitize_normal print \"(3(F3.1,1X))\" , facet % normal % x , facet % normal % y , facet % normal % z Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Calls proc~~compute_normal~~CallsGraph proc~compute_normal compute_normal face_normal3_r8p face_normal3_r8p proc~compute_normal->face_normal3_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_normal Source Code elemental subroutine compute_normal ( self ) !< Compute normal by means of vertices data. !< !<```fortran !< type(facet_object) :: facet !< facet%vertex_1 = -0.231369_R4P * ex_R4P + 0.0226865_R4P * ey_R4P + 1._R4P * ez_R4P !< facet%vertex_2 = -0.227740_R4P * ex_R4P + 0.0245457_R4P * ey_R4P + 0._R4P * ez_R4P !< facet%vertex_2 = -0.235254_R4P * ex_R4P + 0.0201881_R4P * ey_R4P + 0._R4P * ez_R4P !< call facet%sanitize_normal !< print \"(3(F3.1,1X))\", facet%normal%x, facet%normal%y, facet%normal%z !<``` !=> -0.501673222 0.865057290 -2.12257713<<< class ( facet_object ), intent ( inout ) :: self !< Facet. self % normal = face_normal3_R8P ( pt1 = self % vertex_1 , pt2 = self % vertex_2 , pt3 = self % vertex_3 , norm = 'y' ) endsubroutine compute_normal","tags":"","loc":"proc/compute_normal.html","title":"compute_normal – FOSSIL"},{"text":"private elemental subroutine destroy(self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy AABB. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ) :: fresh !< Fresh instance of facet. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOSSIL"},{"text":"private elemental subroutine initialize(self) Initialize facet. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize facet. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( facet_object ) :: fresh !< Fresh instance of facet. self = fresh endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FOSSIL"},{"text":"private subroutine load_from_file_ascii(self, file_unit) Load facet from ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code load_from_file_ascii Source Code subroutine load_from_file_ascii ( self , file_unit ) !< Load facet from ASCII file. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. call load_facet_record ( prefix = 'facet normal' , record = self % normal ) read ( file_unit , * ) ! outer loop call load_facet_record ( prefix = 'vertex' , record = self % vertex_1 ) call load_facet_record ( prefix = 'vertex' , record = self % vertex_2 ) call load_facet_record ( prefix = 'vertex' , record = self % vertex_3 ) read ( file_unit , * ) ! endloop read ( file_unit , * ) ! endfacet contains subroutine load_facet_record ( prefix , record ) !< Load a facet *record*, namely normal or vertex data. character ( * ), intent ( in ) :: prefix !< Record prefix string. type ( vector_R8P ), intent ( out ) :: record !< Record data. character ( FRLEN ) :: facet_record !< Facet record string buffer. integer ( I4P ) :: i !< Counter. read ( file_unit , '(A)' ) facet_record i = index ( string = facet_record , substring = prefix ) if ( i > 0 ) then read ( facet_record ( i + len ( prefix ):), * ) record % x , record % y , record % z else write ( stderr , '(A)' ) 'error: impossible to read \"' // prefix // '\" from file unit \"' // trim ( str ( file_unit )) // '\"!' endif endsubroutine load_facet_record endsubroutine load_from_file_ascii","tags":"","loc":"proc/load_from_file_ascii.html","title":"load_from_file_ascii – FOSSIL"},{"text":"private subroutine load_from_file_binary(self, file_unit) Load facet from binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code load_from_file_binary Source Code subroutine load_from_file_binary ( self , file_unit ) !< Load facet from binary file. class ( facet_object ), intent ( inout ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I2P ) :: padding !< Facet padding. real ( R4P ) :: triplet ( 3 ) !< Triplet record of R4P kind real. read ( file_unit ) triplet self % normal % x = real ( triplet ( 1 ), R8P ) ; self % normal % y = real ( triplet ( 2 ), R8P ) ; self % normal % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_1 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_1 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_1 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_2 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_2 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_2 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) triplet self % vertex_3 % x = real ( triplet ( 1 ), R8P ) ; self % vertex_3 % y = real ( triplet ( 2 ), R8P ) ; self % vertex_3 % z = real ( triplet ( 3 ), R8P ) read ( file_unit ) padding endsubroutine load_from_file_binary","tags":"","loc":"proc/load_from_file_binary.html","title":"load_from_file_binary – FOSSIL"},{"text":"private pure subroutine make_normal_consistent(self, edge_dir, other) Make normal of other facet consistent with self. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. character(len=*), intent(in) :: edge_dir Edge (in self numeration) along which other is connected. type( facet_object ), intent(inout) :: other Other facet to make consistent with self. Source Code make_normal_consistent Source Code pure subroutine make_normal_consistent ( self , edge_dir , other ) !< Make normal of other facet consistent with self. class ( facet_object ), intent ( in ) :: self !< Facet. character ( * ), intent ( in ) :: edge_dir !< Edge (in self numeration) along which other is connected. type ( facet_object ), intent ( inout ) :: other !< Other facet to make consistent with self. character ( len ( edge_dir )) :: edge_dir_other !< Edge (in self numeration) along which other is connected. type ( vector_R8P ) :: edge !< Edge of connection in the self reference. type ( vector_R8P ) :: edge_other !< Edge of connection in the other reference. call self % edge_connection_in_other_ref ( other = other , edge_dir = edge_dir_other , edge = edge_other ) ! get self edge select case ( edge_dir ) case ( 'edge_12' ) edge = self % vertex_2 - self % vertex_1 case ( 'edge_23' ) edge = self % vertex_3 - self % vertex_2 case ( 'edge_31' ) edge = self % vertex_1 - self % vertex_3 endselect if ( edge % dotproduct ( edge_other ) > 0 ) then ! other numeration is consistent, normal has wrong orientation call other % flip_edge ( edge_dir = edge_dir_other ) endif endsubroutine make_normal_consistent","tags":"","loc":"proc/make_normal_consistent.html","title":"make_normal_consistent – FOSSIL"},{"text":"private elemental subroutine resize(self, factor, recompute_metrix) Resize (scale) facet by x or y or z or vectorial factors. Note The name scale has not been used, it been a Fortran built-in. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet type(vector_R8P), intent(in) :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code resize Source Code elemental subroutine resize ( self , factor , recompute_metrix ) !< Resize (scale) facet by x or y or z or vectorial factors. !< !< @note The name `scale` has not been used, it been a Fortran built-in. class ( facet_object ), intent ( inout ) :: self !< Facet type ( vector_R8P ), intent ( in ) :: factor !< Vectorial factor. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. self % vertex_1 = self % vertex_1 * factor self % vertex_2 = self % vertex_2 * factor self % vertex_3 = self % vertex_3 * factor if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine resize","tags":"","loc":"proc/resize.html","title":"resize – FOSSIL"},{"text":"private elemental subroutine reverse_normal(self) Reverse facet normal. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Source Code reverse_normal Source Code elemental subroutine reverse_normal ( self ) !< Reverse facet normal. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ) :: vertex !< Temporary vertex variable. call self % flip_edge ( edge_dir = 'edge_23' ) endsubroutine reverse_normal","tags":"","loc":"proc/reverse_normal.html","title":"reverse_normal – FOSSIL"},{"text":"private subroutine save_into_file_ascii(self, file_unit) Save facet into ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code save_into_file_ascii Source Code subroutine save_into_file_ascii ( self , file_unit ) !< Save facet into ASCII file. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '  facet normal ' , self % normal % x , ' ' , self % normal % y , ' ' , self % normal % z write ( file_unit , '(A)' ) '    outer loop' write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_1 % x , ' ' , self % vertex_1 % y , ' ' , self % vertex_1 % z write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_2 % x , ' ' , self % vertex_2 % y , ' ' , self % vertex_2 % z write ( file_unit , '(A,2(' // FR4P // ',A),' // FR4P // ')' ) '      vertex ' , self % vertex_3 % x , ' ' , self % vertex_3 % y , ' ' , self % vertex_3 % z write ( file_unit , '(A)' ) '    endloop' write ( file_unit , '(A)' ) '  endfacet' endsubroutine save_into_file_ascii","tags":"","loc":"proc/save_into_file_ascii.html","title":"save_into_file_ascii – FOSSIL"},{"text":"private subroutine save_into_file_binary(self, file_unit) Save facet into binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code save_into_file_binary Source Code subroutine save_into_file_binary ( self , file_unit ) !< Save facet into binary file. class ( facet_object ), intent ( in ) :: self !< Facet. integer ( I4P ), intent ( in ) :: file_unit !< File unit. real ( R4P ) :: triplet ( 3 ) !< Triplet record of R4P kind real. triplet ( 1 ) = real ( self % normal % x , R4P ) ; triplet ( 2 ) = real ( self % normal % y , R4P ) ; triplet ( 3 ) = real ( self % normal % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_1 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_1 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_1 % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_2 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_2 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_2 % z , R4P ) write ( file_unit ) triplet triplet ( 1 ) = real ( self % vertex_3 % x , R4P ) ; triplet ( 2 ) = real ( self % vertex_3 % y , R4P ) ; triplet ( 3 ) = real ( self % vertex_3 % z , R4P ) write ( file_unit ) triplet write ( file_unit ) 0_I2P endsubroutine save_into_file_binary","tags":"","loc":"proc/save_into_file_binary.html","title":"save_into_file_binary – FOSSIL"},{"text":"private elemental subroutine translate(self, delta, recompute_metrix) Translate facet given vectorial delta. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: delta Translation delta. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code translate Source Code elemental subroutine translate ( self , delta , recompute_metrix ) !< Translate facet given vectorial delta. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: delta !< Translation delta. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. self % vertex_1 = self % vertex_1 + delta self % vertex_2 = self % vertex_2 + delta self % vertex_3 = self % vertex_3 + delta if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine translate","tags":"","loc":"proc/translate.html","title":"translate – FOSSIL"},{"text":"private pure subroutine update_connectivity(self) Update facet connectivity. Note Vertices occurrencies list must be already computed. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. Source Code update_connectivity Source Code pure subroutine update_connectivity ( self ) !< Update facet connectivity. !< !< @note Vertices occurrencies list must be already computed. class ( facet_object ), intent ( inout ) :: self !< Facet. self % fcon_edge_12 = facet_connected ( occurrence_1 = self % vertex_1_occurrence , occurrence_2 = self % vertex_2_occurrence ) self % fcon_edge_23 = facet_connected ( occurrence_1 = self % vertex_2_occurrence , occurrence_2 = self % vertex_3_occurrence ) self % fcon_edge_31 = facet_connected ( occurrence_1 = self % vertex_3_occurrence , occurrence_2 = self % vertex_1_occurrence ) contains pure function facet_connected ( occurrence_1 , occurrence_2 ) !< Return the facet ID connected by the edge. If no facet is found 0 is returned. !< !< @note Within two vertices occurrencies, namely one edge, there could be only two connected facets. integer ( I4P ), allocatable , intent ( in ) :: occurrence_1 (:) !< Occurrences list of vertex 1. integer ( I4P ), allocatable , intent ( in ) :: occurrence_2 (:) !< Occurrences list of vertex 2. integer ( I4P ) :: facet_connected !< ID of connected connected. integer ( I4P ) :: i1 , i2 !< Counter. facet_connected = 0 if ( allocated ( occurrence_1 ). and . allocated ( occurrence_2 )) then loop_1 : do i1 = 1 , size ( occurrence_1 , dim = 1 ) do i2 = 1 , size ( occurrence_2 , dim = 1 ) if ( occurrence_1 ( i1 ) == occurrence_2 ( i2 )) then facet_connected = occurrence_1 ( i1 ) exit loop_1 endif enddo enddo loop_1 endif endfunction facet_connected endsubroutine update_connectivity","tags":"","loc":"proc/update_connectivity.html","title":"update_connectivity – FOSSIL"},{"text":"private pure subroutine flip_edge(self, edge_dir) Flip facet edge. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. character(len=*), intent(in) :: edge_dir Edge to be flipped. Source Code flip_edge Source Code pure subroutine flip_edge ( self , edge_dir ) !< Flip facet edge. class ( facet_object ), intent ( inout ) :: self !< Facet. character ( * ), intent ( in ) :: edge_dir !< Edge to be flipped. integer ( I4P ) :: fcon !< Temporary facet connectiviy variable. select case ( edge_dir ) case ( 'edge_12' ) call flip_vertices ( a = self % vertex_1 , b = self % vertex_2 , & fcon_bc = self % fcon_edge_23 , fcon_ca = self % fcon_edge_31 , & vertex_a_occurrence = self % vertex_1_occurrence , vertex_b_occurrence = self % vertex_2_occurrence ) case ( 'edge_23' ) call flip_vertices ( a = self % vertex_2 , b = self % vertex_3 , & fcon_bc = self % fcon_edge_12 , fcon_ca = self % fcon_edge_31 , & vertex_a_occurrence = self % vertex_2_occurrence , vertex_b_occurrence = self % vertex_3_occurrence ) case ( 'edge_31' ) call flip_vertices ( a = self % vertex_3 , b = self % vertex_1 , & fcon_bc = self % fcon_edge_12 , fcon_ca = self % fcon_edge_23 , & vertex_a_occurrence = self % vertex_3_occurrence , vertex_b_occurrence = self % vertex_1_occurrence ) endselect call self % compute_metrix contains pure subroutine flip_vertices ( a , b , fcon_bc , fcon_ca , vertex_a_occurrence , vertex_b_occurrence ) !< Flip two vertices of facet. type ( vector_R8P ), intent ( inout ) :: a , b !< Vertices to be flipped. integer ( I4P ), intent ( inout ) :: fcon_bc !< Connected face ID along edge b-c. integer ( I4P ), intent ( inout ) :: fcon_ca !< Connected face ID along edge c-a. integer ( I4P ), allocatable , intent ( inout ) :: vertex_a_occurrence (:) !< List of vertex a \"occurrencies\". integer ( I4P ), allocatable , intent ( inout ) :: vertex_b_occurrence (:) !< List of vertex b \"occurrencies\". type ( vector_R8P ) :: vertex !< Temporary vertex variable. integer ( I4P ) :: fcon !< Temporary connected face ID. integer ( I4P ), allocatable :: vertex_occurrence (:) !< Temporary list of vertex \"occurrencies\". ! flip vertex vertex = a a = b b = vertex ! flip facet connectivity fcon = fcon_bc fcon_bc = fcon_ca fcon_ca = fcon ! flip vertex occurrences if ( allocated ( vertex_a_occurrence ). and . allocated ( vertex_a_occurrence )) then vertex_occurrence = vertex_a_occurrence vertex_a_occurrence = vertex_b_occurrence vertex_b_occurrence = vertex_occurrence elseif ( allocated ( vertex_a_occurrence )) then vertex_b_occurrence = vertex_a_occurrence deallocate ( vertex_a_occurrence ) elseif ( allocated ( vertex_b_occurrence )) then vertex_a_occurrence = vertex_b_occurrence deallocate ( vertex_b_occurrence ) endif endsubroutine flip_vertices endsubroutine flip_edge","tags":"","loc":"proc/flip_edge.html","title":"flip_edge – FOSSIL"},{"text":"private pure subroutine mirror_by_normal(self, normal, recompute_metrix) Mirror facet given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Calls proc~~mirror_by_normal~~CallsGraph proc~mirror_by_normal mirror_by_normal mirror_matrix_r8p mirror_matrix_r8p proc~mirror_by_normal->mirror_matrix_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mirror_by_normal Source Code pure subroutine mirror_by_normal ( self , normal , recompute_metrix ) !< Mirror facet given normal of mirroring plane. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: normal !< Normal of mirroring plane. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % mirror_by_matrix ( matrix = mirror_matrix_R8P ( normal = normal )) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine mirror_by_normal","tags":"","loc":"proc/mirror_by_normal.html","title":"mirror_by_normal – FOSSIL"},{"text":"private pure subroutine mirror_by_matrix(self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code mirror_by_matrix Source Code pure subroutine mirror_by_matrix ( self , matrix , recompute_metrix ) !< Mirror facet given matrix (of mirroring). class ( facet_object ), intent ( inout ) :: self !< Facet. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Mirroring matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % vertex_1 % mirror ( matrix = matrix ) call self % vertex_2 % mirror ( matrix = matrix ) call self % vertex_3 % mirror ( matrix = matrix ) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine mirror_by_matrix","tags":"","loc":"proc/mirror_by_matrix.html","title":"mirror_by_matrix – FOSSIL"},{"text":"private pure subroutine rotate_by_axis_angle(self, axis, angle, recompute_metrix) Rotate facet given axis and angle. Angle must be in radiants. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Calls proc~~rotate_by_axis_angle~~CallsGraph proc~rotate_by_axis_angle rotate_by_axis_angle rotation_matrix_r8p rotation_matrix_r8p proc~rotate_by_axis_angle->rotation_matrix_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code rotate_by_axis_angle Source Code pure subroutine rotate_by_axis_angle ( self , axis , angle , recompute_metrix ) !< Rotate facet given axis and angle. !< !< Angle must be in radiants. class ( facet_object ), intent ( inout ) :: self !< Facet. type ( vector_R8P ), intent ( in ) :: axis !< Axis of rotation. real ( R8P ), intent ( in ) :: angle !< Angle of rotation. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % rotate_by_matrix ( matrix = rotation_matrix_R8P ( axis = axis , angle = angle )) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine rotate_by_axis_angle","tags":"","loc":"proc/rotate_by_axis_angle.html","title":"rotate_by_axis_angle – FOSSIL"},{"text":"private pure subroutine rotate_by_matrix(self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code rotate_by_matrix Source Code pure subroutine rotate_by_matrix ( self , matrix , recompute_metrix ) !< Rotate facet given matrix (of ratation). class ( facet_object ), intent ( inout ) :: self !< Facet. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Rotation matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. call self % vertex_1 % rotate ( matrix = matrix ) call self % vertex_2 % rotate ( matrix = matrix ) call self % vertex_3 % rotate ( matrix = matrix ) if ( present ( recompute_metrix )) then if ( recompute_metrix ) call self % compute_metrix endif endsubroutine rotate_by_matrix","tags":"","loc":"proc/rotate_by_matrix.html","title":"rotate_by_matrix – FOSSIL"},{"text":"private pure subroutine edge_connection_in_other_ref(self, other, edge_dir, edge) Return the edge of connection in the other reference. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type( facet_object ), intent(in) :: other Other facet. character(len=*), intent(out) :: edge_dir Edge (in other numeration) along which self is connected. type(vector_R8P), intent(out) :: edge Edge (in other numeration) along which self is connected. Source Code edge_connection_in_other_ref Source Code pure subroutine edge_connection_in_other_ref ( self , other , edge_dir , edge ) !< Return the edge of connection in the other reference. class ( facet_object ), intent ( in ) :: self !< Facet. type ( facet_object ), intent ( in ) :: other !< Other facet. character ( * ), intent ( out ) :: edge_dir !< Edge (in other numeration) along which self is connected. type ( vector_R8P ), intent ( out ) :: edge !< Edge (in other numeration) along which self is connected. if ( other % fcon_edge_12 == self % id ) then edge_dir = 'edge_12' edge = other % vertex_2 - other % vertex_1 elseif ( other % fcon_edge_23 == self % id ) then edge_dir = 'edge_23' edge = other % vertex_3 - other % vertex_2 elseif ( other % fcon_edge_31 == self % id ) then edge_dir = 'edge_31' edge = other % vertex_1 - other % vertex_3 endif endsubroutine edge_connection_in_other_ref","tags":"","loc":"proc/edge_connection_in_other_ref.html","title":"edge_connection_in_other_ref – FOSSIL"},{"text":"private pure subroutine facet_assign_facet(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: lhs Left hand side. type( facet_object ), intent(in) :: rhs Right hand side. Source Code facet_assign_facet Source Code pure subroutine facet_assign_facet ( lhs , rhs ) !< Operator `=`. class ( facet_object ), intent ( inout ) :: lhs !< Left hand side. type ( facet_object ), intent ( in ) :: rhs !< Right hand side. lhs % normal = rhs % normal lhs % vertex_1 = rhs % vertex_1 lhs % vertex_2 = rhs % vertex_2 lhs % vertex_3 = rhs % vertex_3 lhs % E12 = rhs % E12 lhs % E13 = rhs % E13 lhs % a = rhs % a lhs % b = rhs % b lhs % c = rhs % c lhs % d = rhs % d lhs % det = rhs % det lhs % bb = rhs % bb lhs % id = rhs % id lhs % fcon_edge_12 = rhs % fcon_edge_12 lhs % fcon_edge_23 = rhs % fcon_edge_23 lhs % fcon_edge_31 = rhs % fcon_edge_31 if ( allocated ( lhs % vertex_1_occurrence )) deallocate ( lhs % vertex_1_occurrence ) if ( allocated ( rhs % vertex_1_occurrence )) lhs % vertex_1_occurrence = rhs % vertex_1_occurrence if ( allocated ( lhs % vertex_2_occurrence )) deallocate ( lhs % vertex_2_occurrence ) if ( allocated ( rhs % vertex_2_occurrence )) lhs % vertex_2_occurrence = rhs % vertex_2_occurrence if ( allocated ( lhs % vertex_3_occurrence )) deallocate ( lhs % vertex_3_occurrence ) if ( allocated ( rhs % vertex_3_occurrence )) lhs % vertex_3_occurrence = rhs % vertex_3_occurrence endsubroutine facet_assign_facet","tags":"","loc":"proc/facet_assign_facet.html","title":"facet_assign_facet – FOSSIL"},{"text":"private pure function closest_point(self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. Source Code closest_point Source Code pure function closest_point ( self , point ) result ( closest ) !< Return closest point on (or in) AABB from point reference. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. type ( vector_R8P ) :: closest !< Closest point on (on in) aabb to point. closest = point closest % x = max ( closest % x , self % bmin % x ) ; closest % x = min ( closest % x , self % bmax % x ) closest % y = max ( closest % y , self % bmin % y ) ; closest % y = min ( closest % y , self % bmax % y ) closest % z = max ( closest % z , self % bmin % z ) ; closest % z = min ( closest % z , self % bmax % z ) endfunction closest_point","tags":"","loc":"proc/closest_point.html","title":"closest_point – FOSSIL"},{"text":"private pure function distance(self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. Source Code distance Source Code pure function distance ( self , point ) !< Return the (square) distance from point to AABB. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB. real ( R8P ) :: dx , dy , dz !< Distance components. dx = max ( self % bmin % x - point % x , 0._R8P , point % x - self % bmax % x ) dy = max ( self % bmin % y - point % y , 0._R8P , point % y - self % bmax % y ) dz = max ( self % bmin % z - point % z , 0._R8P , point % z - self % bmax % z ) distance = dx * dx + dy * dy + dz * dz endfunction distance","tags":"","loc":"proc/distance~2.html","title":"distance – FOSSIL"},{"text":"private pure function distance_from_facets(self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. Source Code distance_from_facets Source Code pure function distance_from_facets ( self , point ) result ( distance ) !< Return the (square) distance from point to AABB's facets. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB's facets. real ( R8P ) :: distance_ !< Distance from point to AABB's facets, local variable. integer ( I4P ) :: f !< Counter. distance = MaxR8P if ( self % facets_number > 0 ) then do f = 1 , self % facets_number distance_ = self % facet ( f )% distance ( point = point ) if ( abs ( distance_ ) <= abs ( distance )) distance = distance_ enddo endif endfunction distance_from_facets","tags":"","loc":"proc/distance_from_facets.html","title":"distance_from_facets – FOSSIL"},{"text":"private pure function do_ray_intersect(self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. Source Code do_ray_intersect Source Code pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( do_intersect ) !< Return true if AABB is intersected by ray from origin and oriented as ray direction vector. class ( aabb_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: do_intersect !< Test result. logical :: must_return !< Flag to check when to return from procedure. real ( R8P ) :: tmin , tmax !< Minimum maximum ray intersections with box slabs. do_intersect = . false . must_return = . false . tmin = 0._R8P tmax = MaxR8P call check_slab ( aabb_min = self % bmin % x , aabb_max = self % bmax % x , & o = ray_origin % x , d = ray_direction % x , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return call check_slab ( aabb_min = self % bmin % y , aabb_max = self % bmax % y , & o = ray_origin % y , d = ray_direction % y , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return call check_slab ( aabb_min = self % bmin % z , aabb_max = self % bmax % z , & o = ray_origin % z , d = ray_direction % z , must_return = must_return , tmin = tmin , tmax = tmax ) if ( must_return ) return ! ray intersects all 3 slabs do_intersect = . true . contains pure subroutine check_slab ( aabb_min , aabb_max , o , d , must_return , tmin , tmax ) !< Perform ray intersection check in a direction-split fashion over slabs. real ( R8P ), intent ( in ) :: aabb_min !< Box minimum bound in the current direction. real ( R8P ), intent ( in ) :: aabb_max !< Box maximum bound in the current direction. real ( R8P ), intent ( in ) :: o !< Ray origin in the current direction. real ( R8P ), intent ( in ) :: d !< Ray slope in the current direction. logical , intent ( inout ) :: must_return !< Flag to check when to return from procedure. real ( R8P ), intent ( inout ) :: tmin , tmax !< Minimum maximum ray intersections with box slabs. real ( R8P ) :: ood , t1 , t2 !< Intersection coefficients. real ( R8P ) :: tmp !< Temporary buffer. if (( d ) < EPS ) then ! ray is parallel to slab, no hit if origin not within slab if (( o < aabb_min ). or .( o > aabb_max )) then must_return = . true . return endif else ! compute intersection t value of ray with near and far plane of slab ood = 1._R8P / d t1 = ( aabb_min - o ) * ood t2 = ( aabb_max - o ) * ood ! make t1 be intersection with near plane, t2 with far plane if ( t1 > t2 ) then tmp = t1 t1 = t2 t2 = tmp endif ! compute the intersection of slab intersection intervals if ( t1 > tmin ) tmin = t1 if ( t2 > tmax ) tmax = t2 ! exit with no collision as soon as slab intersection becomes empty if ( tmin > tmax ) then must_return = . true . return endif endif endsubroutine check_slab endfunction do_ray_intersect","tags":"","loc":"proc/do_ray_intersect~2.html","title":"do_ray_intersect – FOSSIL"},{"text":"private pure function has_facets(self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. Return Value logical Check result. Source Code has_facets Source Code pure function has_facets ( self ) !< Return true if AABB has facets. class ( aabb_object ), intent ( in ) :: self !< AABB box. logical :: has_facets !< Check result. has_facets = self % facets_number > 0 endfunction has_facets","tags":"","loc":"proc/has_facets.html","title":"has_facets – FOSSIL"},{"text":"private pure function is_inside(self, point) Return the true if point is inside ABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value logical Check result. Source Code is_inside Source Code pure function is_inside ( self , point ) !< Return the true if point is inside ABB. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. logical :: is_inside !< Check result. is_inside = (( point % x >= self % bmin % x . and . point % x <= self % bmax % x ). and .& ( point % y >= self % bmin % y . and . point % y <= self % bmax % y ). and .& ( point % z >= self % bmin % z . and . point % z <= self % bmax % z )) endfunction is_inside","tags":"","loc":"proc/is_inside.html","title":"is_inside – FOSSIL"},{"text":"private pure function ray_intersections_number(self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. Source Code ray_intersections_number Source Code pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. integer ( I4P ) :: f !< Counter. intersections_number = 0 if ( self % facets_number > 0 ) then do f = 1 , self % facets_number if ( self % facet ( f )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) & intersections_number = intersections_number + 1 enddo endif endfunction ray_intersections_number","tags":"","loc":"proc/ray_intersections_number.html","title":"ray_intersections_number – FOSSIL"},{"text":"private pure function vertex(self) Return AABB vertices. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. Return Value type(vector_R8P)\n  (8) AABB vertices. Source Code vertex Source Code pure function vertex ( self ) !< Return AABB vertices. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. vertex ( 1 ) = self % bmin vertex ( 2 ) = self % bmax % x * ex_R8P + self % bmin % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 3 ) = self % bmin % x * ex_R8P + self % bmax % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 4 ) = self % bmax % x * ex_R8P + self % bmax % y * ey_R8P + self % bmin % z * ez_R8P vertex ( 5 ) = self % bmin % x * ex_R8P + self % bmin % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 6 ) = self % bmax % x * ex_R8P + self % bmin % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 7 ) = self % bmin % x * ex_R8P + self % bmax % y * ey_R8P + self % bmax % z * ez_R8P vertex ( 8 ) = self % bmax endfunction vertex","tags":"","loc":"proc/vertex.html","title":"vertex – FOSSIL"},{"text":"private subroutine add_facets(self, facet) Add facets to AABB. Note Previously stored facets are lost. Note Facets added to AABB are removed to facets list that is also returned. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. Source Code add_facets Source Code subroutine add_facets ( self , facet ) !< Add facets to AABB. !< !< @note Previously stored facets are lost. !< !< @note Facets added to AABB are removed to facets list that is also returned. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), allocatable , intent ( inout ) :: facet (:) !< Facets list. integer ( I4P ) :: scratch_unit_add !< Scratch unit file for added facets. integer ( I4P ) :: scratch_unit_rem !< Scratch unit file for remaining facets. integer ( I4P ) :: rem_facets_number !< Remaining facets number. integer ( I4P ) :: f !< Counter. self % facets_number = 0 rem_facets_number = 0 if ( allocated ( self % facet )) deallocate ( self % facet ) open ( newunit = scratch_unit_add , status = 'scratch' , access = 'stream' , form = 'unformatted' ) open ( newunit = scratch_unit_rem , status = 'scratch' , access = 'stream' , form = 'unformatted' ) do f = 1 , size ( facet , dim = 1 ) if ( self % is_inside ( point = facet ( f )% vertex_1 ). and .& self % is_inside ( point = facet ( f )% vertex_2 ). and .& self % is_inside ( point = facet ( f )% vertex_3 )) then self % facets_number = self % facets_number + 1 call facet ( f )% save_into_file_binary ( file_unit = scratch_unit_add ) else rem_facets_number = rem_facets_number + 1 call facet ( f )% save_into_file_binary ( file_unit = scratch_unit_rem ) endif enddo if ( self % facets_number > 0 ) then allocate ( self % facet ( 1 : self % facets_number )) rewind ( unit = scratch_unit_add ) do f = 1 , self % facets_number call self % facet ( f )% load_from_file_binary ( file_unit = scratch_unit_add ) call self % facet ( f )% compute_metrix enddo endif close ( unit = scratch_unit_add ) deallocate ( facet ) if ( rem_facets_number > 0 ) then allocate ( facet ( 1 : rem_facets_number )) rewind ( unit = scratch_unit_rem ) do f = 1 , rem_facets_number call facet ( f )% load_from_file_binary ( file_unit = scratch_unit_rem ) call facet ( f )% compute_metrix enddo endif close ( unit = scratch_unit_rem ) endsubroutine add_facets","tags":"","loc":"proc/add_facets.html","title":"add_facets – FOSSIL"},{"text":"private pure subroutine compute_octants(self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. Source Code compute_octants Source Code pure subroutine compute_octants ( self , octant ) !< Return AABB octants. class ( aabb_object ), intent ( in ) :: self !< AABB. type ( aabb_object ), intent ( out ) :: octant ( 8 ) !< AABB octants. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: o !< Counter. vertex = self % vertex () octant ( 1 )% bmin = self % bmin ; octant ( 1 )% bmax = 0.5_R8P * ( self % bmin + self % bmax ) octant ( 8 )% bmin = octant ( 1 )% bmax ; octant ( 8 )% bmax = self % bmax do o = 2 , 7 ! loop over remaining octants octant ( o )% bmin = 0.5_R8P * ( self % bmin + vertex ( o )) ; octant ( o )% bmax = 0.5_R8P * ( vertex ( o ) + self % bmax ) enddo endsubroutine compute_octants","tags":"","loc":"proc/compute_octants.html","title":"compute_octants – FOSSIL"},{"text":"private elemental subroutine destroy(self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy AABB. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( aabb_object ) :: fresh !< Fresh instance of AABB box. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOSSIL"},{"text":"private pure subroutine initialize(self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. Calls proc~~initialize~2~~CallsGraph proc~initialize~2 initialize proc~compute_bb_from_facets compute_bb_from_facets proc~initialize~2->proc~compute_bb_from_facets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code pure subroutine initialize ( self , facet , bmin , bmax ) !< Initialize AABB. class ( aabb_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. call self % destroy if ( present ( facet )) then call compute_bb_from_facets ( facet = facet , bmin = self % bmin , bmax = self % bmax ) elseif ( present ( bmin ). and . present ( bmax )) then self % bmin = bmin self % bmax = bmax endif endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – FOSSIL"},{"text":"private subroutine save_geometry_tecplot_ascii(self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. Source Code save_geometry_tecplot_ascii Source Code subroutine save_geometry_tecplot_ascii ( self , file_unit , aabb_name ) !< Save AABB geometry into Tecplot ascii file. class ( aabb_object ), intent ( in ) :: self !< AABB. integer ( I4P ), intent ( in ) :: file_unit !< File unit. character ( * ), intent ( in ), optional :: aabb_name !< Name of AABB. character ( len = :), allocatable :: aabb_name_ !< Name of AABB, local variable. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: v !< Counter. aabb_name_ = 'AABB' ; if ( present ( aabb_name )) aabb_name_ = aabb_name write ( file_unit , '(A)' ) 'ZONE T=\"' // aabb_name // '\", I=2, J=2, K=2' vertex = self % vertex () do v = 1 , 8 write ( file_unit , '(3(' // FR8P // ',1X))' ) vertex ( v )% x , vertex ( v )% y , vertex ( v )% z enddo endsubroutine save_geometry_tecplot_ascii","tags":"","loc":"proc/save_geometry_tecplot_ascii.html","title":"save_geometry_tecplot_ascii – FOSSIL"},{"text":"private subroutine save_facets_into_file_stl(self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. Source Code save_facets_into_file_stl Source Code subroutine save_facets_into_file_stl ( self , file_name , is_ascii ) !< Save facets into file STL. class ( aabb_object ), intent ( in ) :: self !< AABB. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ) :: is_ascii !< Sentinel to check if file is ASCII. integer ( I4P ) :: file_unit !< File unit. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then call open_file if ( is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% save_into_file_ascii ( file_unit = file_unit ) enddo else do f = 1 , self % facets_number call self % facet ( f )% save_into_file_binary ( file_unit = file_unit ) enddo endif call close_file endif contains subroutine open_file () !< Open STL file. if ( is_ascii ) then open ( newunit = file_unit , file = trim ( adjustl ( file_name )), form = 'formatted' ) write ( file_unit , '(A)' ) 'solid ' // trim ( adjustl ( file_name )) else open ( newunit = file_unit , file = trim ( adjustl ( file_name )), access = 'stream' , form = 'unformatted' ) write ( file_unit ) repeat ( 'a' , 80 ) write ( file_unit ) self % facets_number endif endsubroutine open_file subroutine close_file () !< Close STL file. if ( is_ascii ) write ( file_unit , '(A)' ) 'endsolid ' // trim ( adjustl ( file_name )) close ( unit = file_unit ) endsubroutine close_file endsubroutine save_facets_into_file_stl","tags":"","loc":"proc/save_facets_into_file_stl.html","title":"save_facets_into_file_stl – FOSSIL"},{"text":"private pure subroutine update_extents(self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. Calls proc~~update_extents~~CallsGraph proc~update_extents update_extents proc~compute_bb_from_facets compute_bb_from_facets proc~update_extents->proc~compute_bb_from_facets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code update_extents Source Code pure subroutine update_extents ( self ) !< Update AABB bounding box extents. class ( aabb_object ), intent ( inout ) :: self !< AABB. if ( self % facets_number > 0 ) call compute_bb_from_facets ( facet = self % facet , bmin = self % bmin , bmax = self % bmax ) endsubroutine update_extents","tags":"","loc":"proc/update_extents.html","title":"update_extents – FOSSIL"},{"text":"private pure subroutine aabb_assign_aabb(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: lhs Left hand side. type( aabb_object ), intent(in) :: rhs Right hand side. Source Code aabb_assign_aabb Source Code pure subroutine aabb_assign_aabb ( lhs , rhs ) !< Operator `=`. class ( aabb_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_object ), intent ( in ) :: rhs !< Right hand side. lhs % bmin = rhs % bmin lhs % bmax = rhs % bmax lhs % facets_number = rhs % facets_number if ( allocated ( lhs % facet )) deallocate ( lhs % facet ) if ( allocated ( rhs % facet )) allocate ( lhs % facet ( 1 : lhs % facets_number ), source = rhs % facet ) endsubroutine aabb_assign_aabb","tags":"","loc":"proc/aabb_assign_aabb.html","title":"aabb_assign_aabb – FOSSIL"},{"text":"private pure subroutine compute_bb_from_facets(facet, bmin, bmax) Compute AABB extents (minimum and maximum bounding box) from facets list. Note Facets' metrix must be already computed. Arguments Type Intent Optional Attributes Name type( facet_object ), intent(in) :: facet (:) Facets list. type(vector_R8P), intent(inout) :: bmin Minimum point of AABB. type(vector_R8P), intent(inout) :: bmax Maximum point of AABB. Called By proc~~compute_bb_from_facets~~CalledByGraph proc~compute_bb_from_facets compute_bb_from_facets proc~initialize~2 initialize proc~initialize~2->proc~compute_bb_from_facets proc~update_extents update_extents proc~update_extents->proc~compute_bb_from_facets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_bb_from_facets Source Code pure subroutine compute_bb_from_facets ( facet , bmin , bmax ) !< Compute AABB extents (minimum and maximum bounding box) from facets list. !< !< @note Facets' metrix must be already computed. type ( facet_object ), intent ( in ) :: facet (:) !< Facets list. type ( vector_R8P ), intent ( inout ) :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( inout ) :: bmax !< Maximum point of AABB. real ( R8P ) :: toll ( 3 ) !< Small tollerance on AABB inclusion. toll ( 1 ) = ( maxval ( facet (:)% bb ( 2 )% x ) - minval ( facet (:)% bb ( 1 )% x )) / 10 0._R8P toll ( 2 ) = ( maxval ( facet (:)% bb ( 2 )% y ) - minval ( facet (:)% bb ( 1 )% y )) / 10 0._R8P toll ( 3 ) = ( maxval ( facet (:)% bb ( 2 )% z ) - minval ( facet (:)% bb ( 1 )% z )) / 10 0._R8P bmin % x = minval ( facet (:)% bb ( 1 )% x ) - toll ( 1 ) bmin % y = minval ( facet (:)% bb ( 1 )% y ) - toll ( 2 ) bmin % z = minval ( facet (:)% bb ( 1 )% z ) - toll ( 3 ) bmax % x = maxval ( facet (:)% bb ( 2 )% x ) + toll ( 1 ) bmax % y = maxval ( facet (:)% bb ( 2 )% y ) + toll ( 2 ) bmax % z = maxval ( facet (:)% bb ( 2 )% z ) + toll ( 3 ) endsubroutine compute_bb_from_facets","tags":"","loc":"proc/compute_bb_from_facets.html","title":"compute_bb_from_facets – FOSSIL"},{"text":"private pure function distance(self, point, is_signed, sign_algorithm, is_square_root) Compute the (minimum) distance from a point to the triangulated surface. Note STL's metrix must be already computed. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. logical, intent(in), optional :: is_signed Sentinel to trigger signed distance. character(len=*), intent(in), optional :: sign_algorithm Algorithm used for \"point in polyhedron\" test. logical, intent(in), optional :: is_square_root Sentinel to trigger square-root distance. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. Source Code distance Source Code pure function distance ( self , point , is_signed , sign_algorithm , is_square_root ) !< Compute the (minimum) distance from a point to the triangulated surface. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical , intent ( in ), optional :: is_signed !< Sentinel to trigger signed distance. character ( * ), intent ( in ), optional :: sign_algorithm !< Algorithm used for \"point in polyhedron\" test. logical , intent ( in ), optional :: is_square_root !< Sentinel to trigger square-root distance. real ( R8P ) :: distance !< Minimum distance from point to the triangulated surface. real ( R8P ) :: distance_ !< Minimum distance, temporary buffer. character ( len = :), allocatable :: sign_algorithm_ !< Algorithm used for \"point in polyhedron\" test, local variable. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then if ( self % aabb % is_initialized ) then ! exploit AABB refinement levels distance = self % aabb % distance ( point = point ) else ! brute-force search over all facets distance = MaxR8P do f = 1 , self % facets_number distance_ = self % facet ( f )% distance ( point = point ) if ( abs ( distance_ ) <= abs ( distance )) distance = distance_ enddo endif endif if ( present ( is_square_root )) then if ( is_square_root ) distance = sqrt ( distance ) endif if ( present ( is_signed )) then if ( is_signed ) then sign_algorithm_ = 'ray_intersections' ; if ( present ( sign_algorithm )) sign_algorithm_ = sign_algorithm select case ( sign_algorithm_ ) case ( 'solid_angle' ) if ( self % is_point_inside_polyhedron_sa ( point = point )) distance = - distance case ( 'ray_intersections' ) if ( self % is_point_inside_polyhedron_ri ( point = point )) distance = - distance case default ! raise error: \"unknown point in polyhedron algorithm\" endselect endif endif endfunction distance","tags":"","loc":"proc/distance~3.html","title":"distance – FOSSIL"},{"text":"private pure function is_point_inside_polyhedron_ri(self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means ray intersections count. Note STL's metrix must be already computed. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. Source Code is_point_inside_polyhedron_ri Source Code pure function is_point_inside_polyhedron_ri ( self , point ) result ( is_inside ) !< Determinate is a point is inside or not to a polyhedron described by STL facets by means ray intersections count. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical :: is_inside !< Check result. logical :: is_inside_by_x !< Test result by x-aligned ray intersections. logical :: is_inside_by_y !< Test result by y-aligned ray intersections. logical :: is_inside_by_z !< Test result by z-aligned ray intersections. is_inside_by_x = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = ex_R8P + EPS * ey_R8P + EPS * ez_R8P ) is_inside_by_y = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = EPS * ex_R8P + ey_R8P + EPS * ez_R8P ) if ( is_inside_by_x . and . is_inside_by_y ) then is_inside = . true . else is_inside_by_z = is_inside_by_ray_intersect ( ray_origin = point , ray_direction = EPS * ex_R8P + EPS * ey_R8P + ez_R8P ) is_inside = (( is_inside_by_x . and . is_inside_by_y ). or .& ( is_inside_by_x . and . is_inside_by_z ). or .& ( is_inside_by_y . and . is_inside_by_z )) endif contains pure function is_inside_by_ray_intersect ( ray_origin , ray_direction ) result ( is_inside_by ) !< Generic line intersect test. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Ray intersections number of STL polyhedra with respect point. integer ( I4P ) :: f !< Counter. logical :: is_inside_by !< Test result. intersections_number = 0 if ( self % aabb % is_initialized ) then ! exploit AABB refinement levels intersections_number = self % aabb % ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) else ! brute-force search over all facets do f = 1 , self % facets_number if ( self % facet ( f )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) & intersections_number = intersections_number + 1 enddo endif if ( mod ( intersections_number , 2 ) == 0 ) then is_inside_by = . false . else is_inside_by = . true . endif endfunction is_inside_by_ray_intersect endfunction is_point_inside_polyhedron_ri","tags":"","loc":"proc/is_point_inside_polyhedron_ri.html","title":"is_point_inside_polyhedron_ri – FOSSIL"},{"text":"private pure function is_point_inside_polyhedron_sa(self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means of the solid angle criteria. Note STL's metrix must be already computed. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. Source Code is_point_inside_polyhedron_sa Source Code pure function is_point_inside_polyhedron_sa ( self , point ) result ( is_inside ) !< Determinate is a point is inside or not to a polyhedron described by STL facets by means of the solid angle criteria. !< !< @note STL's metrix must be already computed. class ( file_stl_object ), intent ( in ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. logical :: is_inside !< Check result. real ( R8P ) :: solid_angle !< Solid angle of STL polyhedra projected on point unit sphere. integer ( I4P ) :: f !< Counter. solid_angle = 0._R8P do f = 1 , self % facets_number solid_angle = solid_angle + self % facet ( f )% solid_angle ( point = point ) enddo if ( solid_angle < - 2._R8P * PI . or . 2._R8P * PI < solid_angle ) then is_inside = . true . else is_inside = . false . endif endfunction is_point_inside_polyhedron_sa","tags":"","loc":"proc/is_point_inside_polyhedron_sa.html","title":"is_point_inside_polyhedron_sa – FOSSIL"},{"text":"private pure function statistics(self, prefix) result(stats) Return STL statistics. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. character(len=*), intent(in), optional :: prefix Lines prefix. Return Value character(len=:),\n  allocatable STL statistics. Calls proc~~statistics~~CallsGraph proc~statistics statistics str str proc~statistics->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code statistics Source Code pure function statistics ( self , prefix ) result ( stats ) !< Return STL statistics. class ( file_stl_object ), intent ( in ) :: self !< File STL. character ( * ), intent ( in ), optional :: prefix !< Lines prefix. character ( len = :), allocatable :: stats !< STL statistics. character ( len = :), allocatable :: prefix_ !< Lines prefix, local variable. character ( 1 ), parameter :: NL = new_line ( 'a' ) !< Line terminator. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix stats = prefix_ // self % header // NL if ( allocated ( self % file_name )) stats = stats // prefix_ // 'file name:   ' // self % file_name // NL if ( self % is_ascii ) then stats = stats // prefix_ // 'file format: ascii' // NL else stats = stats // prefix_ // 'file format: binary' // NL endif if ( self % facets_number > 0 ) then stats = stats // prefix_ // 'X extents: [' // trim ( str ( self % bmin % x )) // ', ' // trim ( str ( self % bmax % x )) // ']' // NL stats = stats // prefix_ // 'Y extents: [' // trim ( str ( self % bmin % y )) // ', ' // trim ( str ( self % bmax % y )) // ']' // NL stats = stats // prefix_ // 'Z extents: [' // trim ( str ( self % bmin % z )) // ', ' // trim ( str ( self % bmax % z )) // ']' // NL stats = stats // prefix_ // 'volume: ' // trim ( str ( self % volume )) // NL stats = stats // prefix_ // 'number of facets: ' // trim ( str ( self % facets_number )) // NL ! stats=stats//prefix_//'number of facets with 1 edge disconnected: '//trim(str(self%facets_1disconnect_number))//NL ! stats=stats//prefix_//'number of facets with 2 edge disconnected: '//trim(str(self%facets_2disconnect_number))//NL ! stats=stats//prefix_//'number of facets with 3 edge disconnected: '//trim(str(self%facets_3disconnect_number))//NL endif endfunction statistics","tags":"","loc":"proc/statistics.html","title":"statistics – FOSSIL"},{"text":"private pure subroutine analize(self) Analize STL. Buil connectivity, compute metrix, compute volume. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code analize Source Code pure subroutine analize ( self ) !< Analize STL. !< !< Buil connectivity, compute metrix, compute volume. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then call self % build_connectivity call self % compute_metrix call self % compute_volume endif endsubroutine analize","tags":"","loc":"proc/analize.html","title":"analize – FOSSIL"},{"text":"private pure subroutine build_connectivity(self) Build facets connectivity. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code build_connectivity Source Code pure subroutine build_connectivity ( self ) !< Build facets connectivity. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ) :: f1 , f2 !< Counter. if ( self % facets_number > 0 ) then do f1 = 1 , self % facets_number - 1 do f2 = f1 + 1 , self % facets_number call self % facet ( f1 )% check_vertices_occurrencies ( other = self % facet ( f2 )) enddo enddo do f1 = 1 , self % facets_number call self % facet ( f1 )% update_connectivity enddo endif endsubroutine build_connectivity","tags":"","loc":"proc/build_connectivity.html","title":"build_connectivity – FOSSIL"},{"text":"private subroutine close_file(self) Close file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code close_file Source Code subroutine close_file ( self ) !< Close file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical :: file_exist !< Sentinel to check if file exist. if ( self % is_open ) then close ( unit = self % file_unit ) self % file_unit = 0 self % is_open = . false . endif endsubroutine close_file","tags":"","loc":"proc/close_file.html","title":"close_file – FOSSIL"},{"text":"private pure subroutine compute_metrix(self) Compute facets metrix. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code compute_metrix Source Code pure subroutine compute_metrix ( self ) !< Compute facets metrix. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then call self % facet % compute_metrix ! computing bounding box extents self % bmin % x = minval ( self % facet (:)% bb ( 1 )% x ) self % bmin % y = minval ( self % facet (:)% bb ( 1 )% y ) self % bmin % z = minval ( self % facet (:)% bb ( 1 )% z ) self % bmax % x = maxval ( self % facet (:)% bb ( 2 )% x ) self % bmax % y = maxval ( self % facet (:)% bb ( 2 )% y ) self % bmax % z = maxval ( self % facet (:)% bb ( 2 )% z ) endif endsubroutine compute_metrix","tags":"","loc":"proc/compute_metrix~2.html","title":"compute_metrix – FOSSIL"},{"text":"private elemental subroutine compute_normals(self) Compute facets normals by means of vertices data. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code compute_normals Source Code elemental subroutine compute_normals ( self ) !< Compute facets normals by means of vertices data. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) call self % facet % compute_normal endsubroutine compute_normals","tags":"","loc":"proc/compute_normals.html","title":"compute_normals – FOSSIL"},{"text":"private elemental subroutine compute_volume(self) Compute volume bounded by STL surface. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code compute_volume Source Code elemental subroutine compute_volume ( self ) !< Compute volume bounded by STL surface. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then self % volume = 0._R8P do f = 1 , self % facets_number self % volume = self % volume + self % facet ( f )% tetrahedron_volume ( apex = self % facet ( 1 )% vertex_1 ) enddo endif endsubroutine compute_volume","tags":"","loc":"proc/compute_volume.html","title":"compute_volume – FOSSIL"},{"text":"private subroutine create_aabb_tree(self, refinement_levels) Create AABB tree. Note Facets metrix must be already computed. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. integer(kind=I4P), intent(in), optional :: refinement_levels Total number of refinement levels used. Source Code create_aabb_tree Source Code subroutine create_aabb_tree ( self , refinement_levels ) !< Create AABB tree. !< !< @note Facets metrix must be already computed. class ( file_stl_object ), intent ( inout ) :: self !< File STL. integer ( I4P ), intent ( in ), optional :: refinement_levels !< Total number of refinement levels used. integer ( I4P ) :: refinement_levels_ !< Total number of refinement levels used, local variable. refinement_levels_ = 2 ; if ( present ( refinement_levels )) refinement_levels_ = refinement_levels call self % aabb % initialize ( refinement_levels = refinement_levels_ , facet = self % facet ) endsubroutine create_aabb_tree","tags":"","loc":"proc/create_aabb_tree.html","title":"create_aabb_tree – FOSSIL"},{"text":"private elemental subroutine destroy(self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( file_stl_object ) :: fresh !< Fresh instance of file STL. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOSSIL"},{"text":"private elemental subroutine initialize(self, skip_destroy, file_name, is_ascii) Initialize file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. logical, intent(in), optional :: skip_destroy Flag to skip destroy file. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. Source Code initialize Source Code elemental subroutine initialize ( self , skip_destroy , file_name , is_ascii ) !< Initialize file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical , intent ( in ), optional :: skip_destroy !< Flag to skip destroy file. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical :: skip_destroy_ !< Flag to skip destroy file, local variable. skip_destroy_ = . false . ; if ( present ( skip_destroy )) skip_destroy_ = skip_destroy if (. not . skip_destroy_ ) call self % destroy if ( present ( file_name )) self % file_name = trim ( adjustl ( file_name )) if ( present ( is_ascii )) self % is_ascii = is_ascii endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – FOSSIL"},{"text":"private subroutine load_from_file(self, file_name, is_ascii, guess_format, disable_analysis) Load from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. logical, intent(in), optional :: disable_analysis Sentinel to disable STL analysis. Source Code load_from_file Source Code subroutine load_from_file ( self , file_name , is_ascii , guess_format , disable_analysis ) !< Load from file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical , intent ( in ), optional :: guess_format !< Sentinel to try to guess format directly from file. logical , intent ( in ), optional :: disable_analysis !< Sentinel to disable STL analysis. logical :: disable_analysis_ !< Sentinel to disable STL analysis, local variable. integer ( I4P ) :: f !< Counter. disable_analysis_ = . false . ; if ( present ( disable_analysis )) disable_analysis_ = disable_analysis call self % initialize ( skip_destroy = . true ., file_name = file_name , is_ascii = is_ascii ) call self % open_file ( file_action = 'read' , guess_format = guess_format ) call self % load_facets_number_from_file call self % allocate_facets call self % load_header_from_file if ( self % is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% load_from_file_ascii ( file_unit = self % file_unit ) self % facet ( f )% id = f enddo else do f = 1 , self % facets_number self % facet ( f )% id = f call self % facet ( f )% load_from_file_binary ( file_unit = self % file_unit ) enddo endif call self % close_file if (. not . disable_analysis_ ) call self % analize endsubroutine load_from_file","tags":"","loc":"proc/load_from_file.html","title":"load_from_file – FOSSIL"},{"text":"private subroutine open_file(self, file_action, guess_format) Open file, once initialized. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in) :: file_action File action, \"read\" or \"write\". logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. Source Code open_file Source Code subroutine open_file ( self , file_action , guess_format ) !< Open file, once initialized. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ) :: file_action !< File action, \"read\" or \"write\". logical , intent ( in ), optional :: guess_format !< Sentinel to try to guess format directly from file. logical :: guess_format_ !< Sentinel to try to guess format directly from file, local var. logical :: file_exist !< Sentinel to check if file exist. character ( 5 ) :: ascii_header !< Ascii header sentinel. if ( allocated ( self % file_name )) then select case ( trim ( adjustl ( file_action ))) case ( 'read' ) guess_format_ = . false . ; if ( present ( guess_format )) guess_format_ = guess_format inquire ( file = self % file_name , exist = file_exist ) if ( file_exist ) then if ( guess_format_ ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) read ( self % file_unit , '(A)' ) ascii_header close ( self % file_unit ) if ( ascii_header == 'solid' ) then self % is_ascii = . true . else self % is_ascii = . false . endif endif if ( self % is_ascii ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) else open ( newunit = self % file_unit , file = self % file_name , access = 'stream' , form = 'unformatted' ) endif self % is_open = . true . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" does not exist, impossible to open file!' endif case ( 'write' ) if ( self % is_ascii ) then open ( newunit = self % file_unit , file = self % file_name , form = 'formatted' ) else open ( newunit = self % file_unit , file = self % file_name , access = 'stream' , form = 'unformatted' ) endif self % is_open = . true . case default write ( stderr , '(A)' ) 'error: file action \"' // trim ( adjustl ( file_action )) // '\" unknown!' endselect else write ( stderr , '(A)' ) 'error: file name has not be initialized, impossible to open file!' endif endsubroutine open_file","tags":"","loc":"proc/open_file.html","title":"open_file – FOSSIL"},{"text":"private elemental subroutine reverse_normals(self) Reverse facets normals. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code reverse_normals Source Code elemental subroutine reverse_normals ( self ) !< Reverse facets normals. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) call self % facet % reverse_normal endsubroutine reverse_normals","tags":"","loc":"proc/reverse_normals.html","title":"reverse_normals – FOSSIL"},{"text":"private pure subroutine sanitize_normals(self) Sanitize facets normals, make them consistent. Note Facets connectivity and normals must be already computed. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code sanitize_normals Source Code pure subroutine sanitize_normals ( self ) !< Sanitize facets normals, make them consistent. !< !< @note Facets connectivity and normals must be already computed. class ( file_stl_object ), intent ( inout ) :: self !< File STL. logical , allocatable :: facet_checked (:) !< List of facets checked. integer ( I4P ) :: f , ff !< Counter. if ( self % facets_number > 0 ) then allocate ( facet_checked ( 1 : self % facets_number )) facet_checked = . false . f = 1 facet_checked ( f ) = . true . do ff = 0 if ( self % facet ( f )% fcon_edge_12 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_12 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_12' , other = self % facet ( self % facet ( f )% fcon_edge_12 )) facet_checked ( self % facet ( f )% fcon_edge_12 ) = . true . ff = self % facet ( f )% fcon_edge_12 endif if ( self % facet ( f )% fcon_edge_23 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_23 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_23' , other = self % facet ( self % facet ( f )% fcon_edge_23 )) facet_checked ( self % facet ( f )% fcon_edge_23 ) = . true . ff = self % facet ( f )% fcon_edge_23 endif if ( self % facet ( f )% fcon_edge_31 > 0. and .(. not . facet_checked ( self % facet ( f )% fcon_edge_31 ))) then call self % facet ( f )% make_normal_consistent ( edge_dir = 'edge_31' , other = self % facet ( self % facet ( f )% fcon_edge_31 )) facet_checked ( self % facet ( f )% fcon_edge_31 ) = . true . ff = self % facet ( f )% fcon_edge_31 endif if ( ff == 0 ) then exit else f = ff endif enddo endif call self % compute_volume if ( self % volume < 0 ) call self % reverse_normals endsubroutine sanitize_normals","tags":"","loc":"proc/sanitize_normals.html","title":"sanitize_normals – FOSSIL"},{"text":"private subroutine save_into_file(self, file_name, is_ascii) Save into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. Source Code save_into_file Source Code subroutine save_into_file ( self , file_name , is_ascii ) !< Save into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( * ), intent ( in ), optional :: file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. integer ( I4P ) :: f !< Counter. call self % initialize ( skip_destroy = . true ., file_name = file_name , is_ascii = is_ascii ) call self % open_file ( file_action = 'write' ) call self % save_header_into_file if ( self % is_ascii ) then do f = 1 , self % facets_number call self % facet ( f )% save_into_file_ascii ( file_unit = self % file_unit ) enddo else do f = 1 , self % facets_number call self % facet ( f )% save_into_file_binary ( file_unit = self % file_unit ) enddo endif call self % save_trailer_into_file call self % close_file endsubroutine save_into_file","tags":"","loc":"proc/save_into_file.html","title":"save_into_file – FOSSIL"},{"text":"private elemental subroutine resize(self, x, y, z, factor, recompute_metrix) Resize (scale) facets by x or y or z or vectorial factors. Note The name scale has not been used, it been a Fortran built-in. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Factor along x axis. real(kind=R8P), intent(in), optional :: y Factor along y axis. real(kind=R8P), intent(in), optional :: z Factor along z axis. type(vector_R8P), intent(in), optional :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code resize Source Code elemental subroutine resize ( self , x , y , z , factor , recompute_metrix ) !< Resize (scale) facets by x or y or z or vectorial factors. !< !< @note The name `scale` has not been used, it been a Fortran built-in. class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ), optional :: x !< Factor along x axis. real ( R8P ), intent ( in ), optional :: y !< Factor along y axis. real ( R8P ), intent ( in ), optional :: z !< Factor along z axis. type ( vector_R8P ), intent ( in ), optional :: factor !< Vectorial factor. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. type ( vector_R8P ) :: factor_ !< Vectorial factor, local variable. if ( self % facets_number > 0 ) then factor_ = 1._R8P if ( present ( factor )) then factor_ = factor else if ( present ( x )) factor_ % x = x if ( present ( y )) factor_ % y = y if ( present ( z )) factor_ % z = z endif call self % facet % resize ( factor = factor_ , recompute_metrix = recompute_metrix ) endif endsubroutine resize","tags":"","loc":"proc/resize~2.html","title":"resize – FOSSIL"},{"text":"private elemental subroutine translate(self, x, y, z, delta, recompute_metrix) Translate facets x or y or z or vectorial delta increments. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Increment along x axis. real(kind=R8P), intent(in), optional :: y Increment along y axis. real(kind=R8P), intent(in), optional :: z Increment along z axis. type(vector_R8P), intent(in), optional :: delta Vectorial increment. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code translate Source Code elemental subroutine translate ( self , x , y , z , delta , recompute_metrix ) !< Translate facets x or y or z or vectorial delta increments. class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ), optional :: x !< Increment along x axis. real ( R8P ), intent ( in ), optional :: y !< Increment along y axis. real ( R8P ), intent ( in ), optional :: z !< Increment along z axis. type ( vector_R8P ), intent ( in ), optional :: delta !< Vectorial increment. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. type ( vector_R8P ) :: delta_ !< Vectorial increment, local variable. if ( self % facets_number > 0 ) then delta_ = 0._R8P if ( present ( delta )) then delta_ = delta else if ( present ( x )) delta_ % x = x if ( present ( y )) delta_ % y = y if ( present ( z )) delta_ % z = z endif call self % facet % translate ( delta = delta_ , recompute_metrix = recompute_metrix ) endif endsubroutine translate","tags":"","loc":"proc/translate~2.html","title":"translate – FOSSIL"},{"text":"private pure subroutine file_stl_assign_file_stl(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: lhs Left hand side. type( file_stl_object ), intent(in) :: rhs Right hand side. Source Code file_stl_assign_file_stl Source Code pure subroutine file_stl_assign_file_stl ( lhs , rhs ) !< Operator `=`. class ( file_stl_object ), intent ( inout ) :: lhs !< Left hand side. type ( file_stl_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( lhs % file_name )) deallocate ( lhs % file_name ) if ( allocated ( rhs % file_name )) lhs % file_name = rhs % file_name lhs % file_unit = rhs % file_unit lhs % header = rhs % header lhs % facets_number = rhs % facets_number if ( allocated ( lhs % facet )) deallocate ( lhs % facet ) if ( allocated ( rhs % facet )) allocate ( lhs % facet ( 1 : lhs % facets_number ), source = rhs % facet ) lhs % aabb = rhs % aabb lhs % bmin = rhs % bmin lhs % bmax = rhs % bmax lhs % is_ascii = rhs % is_ascii lhs % is_open = rhs % is_open endsubroutine file_stl_assign_file_stl","tags":"","loc":"proc/file_stl_assign_file_stl.html","title":"file_stl_assign_file_stl – FOSSIL"},{"text":"private elemental subroutine allocate_facets(self) Allocate facets. Note Facets previously allocated are lost. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code allocate_facets Source Code elemental subroutine allocate_facets ( self ) !< Allocate facets. !< !< @note Facets previously allocated are lost. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % facets_number > 0 ) then if ( allocated ( self % facet )) deallocate ( self % facet ) allocate ( self % facet ( 1 : self % facets_number )) endif endsubroutine allocate_facets","tags":"","loc":"proc/allocate_facets.html","title":"allocate_facets – FOSSIL"},{"text":"private subroutine load_facets_number_from_file(self) Load facets number from file. Note File is rewinded. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code load_facets_number_from_file Source Code subroutine load_facets_number_from_file ( self ) !< Load facets number from file. !< !< @note File is rewinded. class ( file_stl_object ), intent ( inout ) :: self !< File STL. character ( FRLEN ) :: facet_record !< Facet record string buffer. if ( self % is_open ) then self % facets_number = 0 rewind ( self % file_unit ) if ( self % is_ascii ) then do read ( self % file_unit , '(A)' , end = 10 , err = 10 ) facet_record if ( index ( string = facet_record , substring = 'facet normal' ) > 0 ) self % facets_number = self % facets_number + 1 enddo else read ( self % file_unit , end = 10 , err = 10 ) facet_record read ( self % file_unit , end = 10 , err = 10 ) self % facets_number endif 10 rewind ( self % file_unit ) else write ( stderr , '(A)' ) 'error: file is not open, impossible to load facets number from file!' endif endsubroutine load_facets_number_from_file","tags":"","loc":"proc/load_facets_number_from_file.html","title":"load_facets_number_from_file – FOSSIL"},{"text":"private subroutine load_header_from_file(self) Load header from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code load_header_from_file Source Code subroutine load_header_from_file ( self ) !< Load header from file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then rewind ( self % file_unit ) if ( self % is_ascii ) then read ( self % file_unit , '(A)' ) self % header self % header = trim ( adjustl ( self % header ( index ( self % header , 'solid' ) + 6 :))) else read ( self % file_unit ) self % header read ( self % file_unit ) self % facets_number endif else write ( stderr , '(A)' ) 'error: file is not open, impossible to load header from file!' endif endsubroutine load_header_from_file","tags":"","loc":"proc/load_header_from_file.html","title":"load_header_from_file – FOSSIL"},{"text":"private elemental subroutine mirror_by_normal(self, normal, recompute_metrix) Mirror facets given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Calls proc~~mirror_by_normal~2~~CallsGraph proc~mirror_by_normal~2 mirror_by_normal mirror_matrix_r8p mirror_matrix_r8p proc~mirror_by_normal~2->mirror_matrix_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mirror_by_normal Source Code elemental subroutine mirror_by_normal ( self , normal , recompute_metrix ) !< Mirror facets given normal of mirroring plane. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: normal !< Normal of mirroring plane. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. real ( R8P ) :: matrix ( 3 , 3 ) !< Mirroring matrix. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then matrix = mirror_matrix_R8P ( normal = normal ) do f = 1 , self % facets_number call self % facet ( f )% mirror ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine mirror_by_normal","tags":"","loc":"proc/mirror_by_normal~2.html","title":"mirror_by_normal – FOSSIL"},{"text":"private pure subroutine mirror_by_matrix(self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code mirror_by_matrix Source Code pure subroutine mirror_by_matrix ( self , matrix , recompute_metrix ) !< Mirror facet given matrix (of mirroring). class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Mirroring matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then do f = 1 , self % facets_number call self % facet ( f )% mirror ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine mirror_by_matrix","tags":"","loc":"proc/mirror_by_matrix~2.html","title":"mirror_by_matrix – FOSSIL"},{"text":"private elemental subroutine rotate_by_axis_angle(self, axis, angle, recompute_metrix) Rotate facets given axis and angle. Angle must be in radiants. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Calls proc~~rotate_by_axis_angle~2~~CallsGraph proc~rotate_by_axis_angle~2 rotate_by_axis_angle rotation_matrix_r8p rotation_matrix_r8p proc~rotate_by_axis_angle~2->rotation_matrix_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code rotate_by_axis_angle Source Code elemental subroutine rotate_by_axis_angle ( self , axis , angle , recompute_metrix ) !< Rotate facets given axis and angle. !< !< Angle must be in radiants. class ( file_stl_object ), intent ( inout ) :: self !< File STL. type ( vector_R8P ), intent ( in ) :: axis !< Axis of rotation. real ( R8P ), intent ( in ) :: angle !< Angle of rotation. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. real ( R8P ) :: matrix ( 3 , 3 ) !< Rotation matrix. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then matrix = rotation_matrix_R8P ( axis = axis , angle = angle ) do f = 1 , self % facets_number call self % facet ( f )% rotate ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine rotate_by_axis_angle","tags":"","loc":"proc/rotate_by_axis_angle~2.html","title":"rotate_by_axis_angle – FOSSIL"},{"text":"private pure subroutine rotate_by_matrix(self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. Source Code rotate_by_matrix Source Code pure subroutine rotate_by_matrix ( self , matrix , recompute_metrix ) !< Rotate facet given matrix (of ratation). class ( file_stl_object ), intent ( inout ) :: self !< File STL. real ( R8P ), intent ( in ) :: matrix ( 3 , 3 ) !< Rotation matrix. logical , intent ( in ), optional :: recompute_metrix !< Sentinel to activate metrix recomputation. integer ( I4P ) :: f !< Counter. if ( self % facets_number > 0 ) then do f = 1 , self % facets_number call self % facet ( f )% rotate ( matrix = matrix , recompute_metrix = recompute_metrix ) enddo endif endsubroutine rotate_by_matrix","tags":"","loc":"proc/rotate_by_matrix~2.html","title":"rotate_by_matrix – FOSSIL"},{"text":"private subroutine save_header_into_file(self) Save header into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code save_header_into_file Source Code subroutine save_header_into_file ( self ) !< Save header into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then rewind ( self % file_unit ) if ( self % is_ascii ) then write ( self % file_unit , '(A)' ) 'solid ' // trim ( self % header ) else write ( self % file_unit ) self % header write ( self % file_unit ) self % facets_number endif else write ( stderr , '(A)' ) 'error: file is not open, impossible to load header from file!' endif endsubroutine save_header_into_file","tags":"","loc":"proc/save_header_into_file.html","title":"save_header_into_file – FOSSIL"},{"text":"private subroutine save_trailer_into_file(self) Save trailer into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. Source Code save_trailer_into_file Source Code subroutine save_trailer_into_file ( self ) !< Save trailer into file. class ( file_stl_object ), intent ( inout ) :: self !< File STL. if ( self % is_open ) then if ( self % is_ascii ) write ( self % file_unit , '(A)' ) 'endsolid ' // trim ( self % header ) else write ( stderr , '(A)' ) 'error: file is not open, impossible to write trailer into file!' endif endsubroutine save_trailer_into_file","tags":"","loc":"proc/save_trailer_into_file.html","title":"save_trailer_into_file – FOSSIL"},{"text":"private pure function bmin(self) Return AABB bmin. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmin. Source Code bmin Source Code pure function bmin ( self ) !< Return AABB bmin. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ) :: bmin !< AABB bmin. if ( allocated ( self % aabb )) bmin = self % aabb % bmin endfunction bmin","tags":"","loc":"proc/bmin.html","title":"bmin – FOSSIL"},{"text":"private pure function bmax(self) Return AABB bmax. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmax. Source Code bmax Source Code pure function bmax ( self ) !< Return AABB bmax. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ) :: bmax !< AABB bmax. if ( allocated ( self % aabb )) bmax = self % aabb % bmax endfunction bmax","tags":"","loc":"proc/bmax.html","title":"bmax – FOSSIL"},{"text":"private pure function closest_point(self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. Source Code closest_point Source Code pure function closest_point ( self , point ) result ( closest ) !< Return closest point on (or in) AABB from point reference. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. type ( vector_R8P ), intent ( in ) :: point !< Point reference. type ( vector_R8P ) :: closest !< Closest point on (on in) aabb to point. closest = MaxR8P if ( allocated ( self % aabb )) closest = self % aabb % closest_point ( point = point ) endfunction closest_point","tags":"","loc":"proc/closest_point~2.html","title":"closest_point – FOSSIL"},{"text":"private pure function distance(self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. Source Code distance Source Code pure function distance ( self , point ) !< Return the (square) distance from point to AABB. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB. distance = MaxR8P if ( allocated ( self % aabb )) distance = self % aabb % distance ( point = point ) endfunction distance","tags":"","loc":"proc/distance~4.html","title":"distance – FOSSIL"},{"text":"private pure function distance_from_facets(self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. Source Code distance_from_facets Source Code pure function distance_from_facets ( self , point ) result ( distance ) !< Return the (square) distance from point to AABB's facets. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: point !< Point reference. real ( R8P ) :: distance !< Distance from point to AABB's facets. distance = MaxR8P if ( allocated ( self % aabb )) distance = self % aabb % distance_from_facets ( point = point ) endfunction distance_from_facets","tags":"","loc":"proc/distance_from_facets~2.html","title":"distance_from_facets – FOSSIL"},{"text":"private pure function do_ray_intersect(self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. Source Code do_ray_intersect Source Code pure function do_ray_intersect ( self , ray_origin , ray_direction ) result ( do_intersect ) !< Return true if AABB is intersected by ray from origin and oriented as ray direction vector. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. logical :: do_intersect !< Test result. do_intersect = . false . if ( allocated ( self % aabb )) do_intersect = self % aabb % do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction ) endfunction do_ray_intersect","tags":"","loc":"proc/do_ray_intersect~3.html","title":"do_ray_intersect – FOSSIL"},{"text":"private pure function has_facets(self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. Source Code has_facets Source Code pure function has_facets ( self ) !< Return true if AABB has facets. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. logical :: has_facets !< Check result. has_facets = allocated ( self % aabb ) if ( has_facets ) has_facets = self % aabb % has_facets () endfunction has_facets","tags":"","loc":"proc/has_facets~2.html","title":"has_facets – FOSSIL"},{"text":"private pure function is_allocated(self) Return true if node is allocated. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. Source Code is_allocated Source Code pure function is_allocated ( self ) !< Return true if node is allocated. class ( aabb_node_object ), intent ( in ) :: self !< AABB box. logical :: is_allocated !< Check result. is_allocated = allocated ( self % aabb ) endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated – FOSSIL"},{"text":"private pure function ray_intersections_number(self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. Source Code ray_intersections_number Source Code pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. intersections_number = 0 if ( allocated ( self % aabb )) & intersections_number = self % aabb % ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) endfunction ray_intersections_number","tags":"","loc":"proc/ray_intersections_number~2.html","title":"ray_intersections_number – FOSSIL"},{"text":"private subroutine add_facets(self, facet) Add facets to AABB. Note Facets added to AABB are removed to facets list that is also returned. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. Source Code add_facets Source Code subroutine add_facets ( self , facet ) !< Add facets to AABB. !< !< @note Facets added to AABB are removed to facets list that is also returned. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), allocatable , intent ( inout ) :: facet (:) !< Facets list. if ( allocated ( self % aabb )) call self % aabb % add_facets ( facet = facet ) endsubroutine add_facets","tags":"","loc":"proc/add_facets~2.html","title":"add_facets – FOSSIL"},{"text":"private pure subroutine compute_octants(self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. Source Code compute_octants Source Code pure subroutine compute_octants ( self , octant ) !< Return AABB octants. class ( aabb_node_object ), intent ( in ) :: self !< AABB. type ( aabb_object ), intent ( out ) :: octant ( 8 ) !< AABB octants. type ( vector_R8P ) :: vertex ( 8 ) !< AABB vertices. integer ( I4P ) :: o !< Counter. call self % aabb % compute_octants ( octant = octant ) endsubroutine compute_octants","tags":"","loc":"proc/compute_octants~2.html","title":"compute_octants – FOSSIL"},{"text":"private elemental subroutine destroy(self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy AABB. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( aabb_node_object ) :: fresh !< Fresh instance of AABB. if ( allocated ( self % aabb )) then call self % aabb % destroy deallocate ( self % aabb ) endif endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FOSSIL"},{"text":"private pure subroutine initialize(self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. Source Code initialize Source Code pure subroutine initialize ( self , facet , bmin , bmax ) !< Initialize AABB. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. call self % destroy if ( present ( facet ). or .( present ( bmin ). and . present ( bmin ))) then allocate ( self % aabb ) call self % aabb % initialize ( facet = facet , bmin = bmin , bmax = bmax ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – FOSSIL"},{"text":"private subroutine save_geometry_tecplot_ascii(self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. Source Code save_geometry_tecplot_ascii Source Code subroutine save_geometry_tecplot_ascii ( self , file_unit , aabb_name ) !< Save AABB geometry into Tecplot ascii file. class ( aabb_node_object ), intent ( in ) :: self !< AABB. integer ( I4P ), intent ( in ) :: file_unit !< File unit. character ( * ), intent ( in ), optional :: aabb_name !< Name of AABB. if ( allocated ( self % aabb )) call self % aabb % save_geometry_tecplot_ascii ( file_unit = file_unit , aabb_name = aabb_name ) endsubroutine save_geometry_tecplot_ascii","tags":"","loc":"proc/save_geometry_tecplot_ascii~2.html","title":"save_geometry_tecplot_ascii – FOSSIL"},{"text":"private subroutine save_facets_into_file_stl(self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. Source Code save_facets_into_file_stl Source Code subroutine save_facets_into_file_stl ( self , file_name , is_ascii ) !< Save facets into file STL. class ( aabb_node_object ), intent ( in ) :: self !< AABB. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ) :: is_ascii !< Sentinel to check if file is ASCII. if ( allocated ( self % aabb )) call self % aabb % save_facets_into_file_stl ( file_name = file_name , is_ascii = is_ascii ) endsubroutine save_facets_into_file_stl","tags":"","loc":"proc/save_facets_into_file_stl~2.html","title":"save_facets_into_file_stl – FOSSIL"},{"text":"private pure subroutine update_extents(self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. Source Code update_extents Source Code pure subroutine update_extents ( self ) !< Update AABB bounding box extents. class ( aabb_node_object ), intent ( inout ) :: self !< AABB. if ( allocated ( self % aabb )) call self % aabb % update_extents endsubroutine update_extents","tags":"","loc":"proc/update_extents~2.html","title":"update_extents – FOSSIL"},{"text":"private pure subroutine aabb_node_assign_aabb_node(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: lhs Left hand side. type( aabb_node_object ), intent(in) :: rhs Right hand side. Source Code aabb_node_assign_aabb_node Source Code pure subroutine aabb_node_assign_aabb_node ( lhs , rhs ) !< Operator `=`. class ( aabb_node_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_node_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( lhs % aabb )) then call lhs % aabb % destroy deallocate ( lhs % aabb ) endif if ( allocated ( rhs % aabb )) then allocate ( lhs % aabb ) lhs % aabb = rhs % aabb endif endsubroutine aabb_node_assign_aabb_node","tags":"","loc":"proc/aabb_node_assign_aabb_node.html","title":"aabb_node_assign_aabb_node – FOSSIL"},{"text":"private pure function distance(self, point) Compute the (minimum) distance from a point to the triangulated surface. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: point Point coordinates. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. Calls proc~~distance~5~~CallsGraph proc~distance~5 distance node node proc~distance~5->node proc~first_node first_node proc~distance~5->proc~first_node proc~nodes_number_at_level nodes_number_at_level proc~distance~5->proc~nodes_number_at_level proc~nodes_number nodes_number proc~first_node->proc~nodes_number proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code distance Source Code pure function distance ( self , point ) !< Compute the (minimum) distance from a point to the triangulated surface. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. type ( vector_R8P ), intent ( in ) :: point !< Point coordinates. real ( R8P ) :: distance !< Minimum distance from point to the triangulated surface. real ( R8P ), allocatable :: distance_ (:) !< Minimum distance, temporary buffer. integer ( I4P ), allocatable :: aabb_closest (:) !< Index of closest AABB. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) allocate ( distance_ ( 0 : self % refinement_levels )) allocate ( aabb_closest ( 0 : self % refinement_levels )) distance_ = MaxR8P aabb_closest = - 1 do level = 0 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at finest level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( node ( bbb )% is_allocated ()) then distance = node ( bbb )% distance ( point = point ) ! node distance if ( distance <= distance_ ( level )) then distance_ ( level ) = distance ! update minimum distance aabb_closest ( level ) = bbb ! store closest node endif endif enddo enddo distance = MaxR8P do level = 0 , self % refinement_levels if ( aabb_closest ( level ) >= 0 ) then distance = min ( distance , node ( aabb_closest ( level ))% distance_from_facets ( point = point )) endif enddo endassociate endfunction distance","tags":"","loc":"proc/distance~5.html","title":"distance – FOSSIL"},{"text":"private pure function ray_intersections_number(self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. Calls proc~~ray_intersections_number~3~~CallsGraph proc~ray_intersections_number~3 ray_intersections_number node node proc~ray_intersections_number~3->node proc~first_node first_node proc~ray_intersections_number~3->proc~first_node proc~nodes_number_at_level nodes_number_at_level proc~ray_intersections_number~3->proc~nodes_number_at_level proc~nodes_number nodes_number proc~first_node->proc~nodes_number proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ray_intersections_number Source Code pure function ray_intersections_number ( self , ray_origin , ray_direction ) result ( intersections_number ) !< Return ray intersections number. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. type ( vector_R8P ), intent ( in ) :: ray_origin !< Ray origin. type ( vector_R8P ), intent ( in ) :: ray_direction !< Ray direction. integer ( I4P ) :: intersections_number !< Intersection number. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. intersections_number = 0 associate ( node => self % node ) do level = 0 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at finest level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( node ( bbb )% do_ray_intersect ( ray_origin = ray_origin , ray_direction = ray_direction )) then intersections_number = intersections_number + & node ( bbb )% ray_intersections_number ( ray_origin = ray_origin , ray_direction = ray_direction ) endif enddo enddo endassociate endfunction ray_intersections_number","tags":"","loc":"proc/ray_intersections_number~3.html","title":"ray_intersections_number – FOSSIL"},{"text":"private pure function first_child_node(node) Return first child tree node. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: node Node queried. Return Value integer(kind=I4P) First child tree node. Source Code first_child_node Source Code pure function first_child_node ( node ) !< Return first child tree node. integer ( I4P ), intent ( in ) :: node !< Node queried. integer ( I4P ) :: first_child_node !< First child tree node. first_child_node = node * TREE_RATIO + 1 endfunction first_child_node","tags":"","loc":"proc/first_child_node.html","title":"first_child_node – FOSSIL"},{"text":"private pure function first_node(level) Return first tree node at a given level. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: level Refinement level queried. Return Value integer(kind=I4P) Number of tree nodes at given level. Calls proc~~first_node~~CallsGraph proc~first_node first_node proc~nodes_number nodes_number proc~first_node->proc~nodes_number proc~nodes_number_at_level nodes_number_at_level proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~first_node~~CalledByGraph proc~first_node first_node proc~distance~5 distance proc~distance~5->proc~first_node proc~initialize~5 initialize proc~initialize~5->proc~first_node proc~save_geometry_tecplot_ascii~3 save_geometry_tecplot_ascii proc~save_geometry_tecplot_ascii~3->proc~first_node proc~save_into_file_stl save_into_file_stl proc~save_into_file_stl->proc~first_node proc~ray_intersections_number~3 ray_intersections_number proc~ray_intersections_number~3->proc~first_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code first_node Source Code pure function first_node ( level ) !< Return first tree node at a given level. integer ( I4P ), intent ( in ) :: level !< Refinement level queried. integer ( I4P ) :: first_node !< Number of tree nodes at given level. first_node = nodes_number ( refinement_levels = level - 1 ) endfunction first_node","tags":"","loc":"proc/first_node.html","title":"first_node – FOSSIL"},{"text":"private pure function nodes_number(refinement_levels) Return total number of tree nodes given the total number refinement levels used. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: refinement_levels Total number of refinement levels used. Return Value integer(kind=I4P) Total number of tree nodes. Calls proc~~nodes_number~~CallsGraph proc~nodes_number nodes_number proc~nodes_number_at_level nodes_number_at_level proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~nodes_number~~CalledByGraph proc~nodes_number nodes_number proc~initialize~5 initialize proc~initialize~5->proc~nodes_number proc~first_node first_node proc~initialize~5->proc~first_node proc~first_node->proc~nodes_number proc~distance~5 distance proc~distance~5->proc~first_node proc~save_geometry_tecplot_ascii~3 save_geometry_tecplot_ascii proc~save_geometry_tecplot_ascii~3->proc~first_node proc~save_into_file_stl save_into_file_stl proc~save_into_file_stl->proc~first_node proc~ray_intersections_number~3 ray_intersections_number proc~ray_intersections_number~3->proc~first_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code nodes_number Source Code pure function nodes_number ( refinement_levels ) !< Return total number of tree nodes given the total number refinement levels used. integer ( I4P ), intent ( in ) :: refinement_levels !< Total number of refinement levels used. integer ( I4P ) :: nodes_number !< Total number of tree nodes. integer :: level !< Counter. nodes_number = 0 do level = 0 , refinement_levels nodes_number = nodes_number + nodes_number_at_level ( level = level ) enddo endfunction nodes_number","tags":"","loc":"proc/nodes_number.html","title":"nodes_number – FOSSIL"},{"text":"private pure function nodes_number_at_level(level) result(nodes_number) Return number of tree nodes at a given level. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: level Refinement level queried. Return Value integer(kind=I4P) Number of tree nodes at given level. Called By proc~~nodes_number_at_level~~CalledByGraph proc~nodes_number_at_level nodes_number_at_level proc~distance~5 distance proc~distance~5->proc~nodes_number_at_level proc~first_node first_node proc~distance~5->proc~first_node proc~ray_intersections_number~3 ray_intersections_number proc~ray_intersections_number~3->proc~nodes_number_at_level proc~ray_intersections_number~3->proc~first_node proc~save_geometry_tecplot_ascii~3 save_geometry_tecplot_ascii proc~save_geometry_tecplot_ascii~3->proc~nodes_number_at_level proc~save_geometry_tecplot_ascii~3->proc~first_node proc~save_into_file_stl save_into_file_stl proc~save_into_file_stl->proc~nodes_number_at_level proc~save_into_file_stl->proc~first_node proc~initialize~5 initialize proc~initialize~5->proc~nodes_number_at_level proc~nodes_number nodes_number proc~initialize~5->proc~nodes_number proc~initialize~5->proc~first_node proc~nodes_number->proc~nodes_number_at_level proc~first_node->proc~nodes_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code nodes_number_at_level Source Code pure function nodes_number_at_level ( level ) result ( nodes_number ) !< Return number of tree nodes at a given level. integer ( I4P ), intent ( in ) :: level !< Refinement level queried. integer ( I4P ) :: nodes_number !< Number of tree nodes at given level. nodes_number = TREE_RATIO ** ( level ) endfunction nodes_number_at_level","tags":"","loc":"proc/nodes_number_at_level.html","title":"nodes_number_at_level – FOSSIL"},{"text":"private pure function parent_node(node) Return parent tree node. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: node Node queried. Return Value integer(kind=I4P) Parent tree node. Called By proc~~parent_node~~CalledByGraph proc~parent_node parent_node proc~initialize~5 initialize proc~initialize~5->proc~parent_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parent_node Source Code pure function parent_node ( node ) !< Return parent tree node. integer ( I4P ), intent ( in ) :: node !< Node queried. integer ( I4P ) :: parent_node !< Parent tree node. parent_node = ( node - 1 ) / TREE_RATIO endfunction parent_node","tags":"","loc":"proc/parent_node.html","title":"parent_node – FOSSIL"},{"text":"private elemental subroutine destroy(self) Destroy AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy AABB tree. class ( aabb_tree_object ), intent ( inout ) :: self !< AABB tree. type ( aabb_tree_object ) :: fresh !< Fresh instance of AABB tree. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FOSSIL"},{"text":"private subroutine initialize(self, refinement_levels, facet, bmin, bmax) Initialize AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. integer(kind=I4P), intent(in) :: refinement_levels Total number of refinement levels used. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. Calls proc~~initialize~5~~CallsGraph proc~initialize~5 initialize proc~nodes_number_at_level nodes_number_at_level proc~initialize~5->proc~nodes_number_at_level proc~nodes_number nodes_number proc~initialize~5->proc~nodes_number node node proc~initialize~5->node proc~parent_node parent_node proc~initialize~5->proc~parent_node proc~first_node first_node proc~initialize~5->proc~first_node proc~nodes_number->proc~nodes_number_at_level proc~first_node->proc~nodes_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , refinement_levels , facet , bmin , bmax ) !< Initialize AABB tree. class ( aabb_tree_object ), intent ( inout ) :: self !< AABB tree. integer ( I4P ), intent ( in ) :: refinement_levels !< Total number of refinement levels used. type ( facet_object ), intent ( in ), optional :: facet (:) !< Facets list. type ( vector_R8P ), intent ( in ), optional :: bmin !< Minimum point of AABB. type ( vector_R8P ), intent ( in ), optional :: bmax !< Maximum point of AABB. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb , bbbb !< Counter. integer ( I4P ) :: parent !< Parent node index. type ( aabb_object ) :: octant ( 8 ) !< AABB octants. type ( facet_object ), allocatable :: facet_ (:) !< Facets list, local variable. call self % destroy self % refinement_levels = refinement_levels self % nodes_number = nodes_number ( refinement_levels = self % refinement_levels ) allocate ( self % node ( 0 : self % nodes_number - 1 )) associate ( node => self % node ) ! inizialize all tree nodes with only the bounding box call node ( 0 )% initialize ( facet = facet , bmin = bmin , bmax = bmax ) do level = 1 , self % refinement_levels ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ), TREE_RATIO ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree parent = parent_node ( node = bbb ) ! parent of the current node if ( node ( parent )% is_allocated ()) then ! create children nodes call node ( parent )% compute_octants ( octant = octant ) ! compute parent AABB octants do bbbb = 0 , TREE_RATIO - 1 ! loop over children call node ( bbb + bbbb )% initialize ( bmin = octant ( bbbb + 1 )% bmin , bmax = octant ( bbbb + 1 )% bmax ) ! initialize node enddo endif enddo enddo ! fill all tree nodes with facets if ( present ( facet )) then allocate ( facet_ , source = facet ) ! add facets to nodes do level = self % refinement_levels , 0 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if ( allocated ( facet_ )) then ! check if facets list still has facets call node ( bbb )% add_facets ( facet = facet_ ) ! add facets to node and prune added facets from list endif enddo enddo ! destroy void nodes (except root node) do level = self % refinement_levels , 1 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree if (. not . node ( bbb )% has_facets ()) call node ( bbb )% destroy ! destroy void node enddo enddo ! update AABB extents do level = self % refinement_levels , 1 , - 1 ! loop over refinement levels b = first_node ( level = level ) ! first node at level do bb = 1 , nodes_number_at_level ( level = level ) ! loop over nodes at level bbb = b + bb - 1 ! node numeration in tree call node ( bbb )% update_extents ! update extents enddo enddo endif endassociate self % is_initialized = . true . endsubroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – FOSSIL"},{"text":"private subroutine save_geometry_tecplot_ascii(self, file_name) Save AABB tree boxes geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: file_name File name. Calls proc~~save_geometry_tecplot_ascii~3~~CallsGraph proc~save_geometry_tecplot_ascii~3 save_geometry_tecplot_ascii node node proc~save_geometry_tecplot_ascii~3->node str str proc~save_geometry_tecplot_ascii~3->str proc~first_node first_node proc~save_geometry_tecplot_ascii~3->proc~first_node proc~nodes_number_at_level nodes_number_at_level proc~save_geometry_tecplot_ascii~3->proc~nodes_number_at_level proc~nodes_number nodes_number proc~first_node->proc~nodes_number proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_geometry_tecplot_ascii Source Code subroutine save_geometry_tecplot_ascii ( self , file_name ) !< Save AABB tree boxes geometry into Tecplot ascii file. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. character ( * ), intent ( in ) :: file_name !< File name. integer ( I4P ) :: file_unit !< File unit. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) if ( self % is_initialized ) then open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) write ( file_unit , '(A)' ) 'VARIABLES=x y z' do level = 0 , self % refinement_levels b = first_node ( level = level ) do bb = 1 , nodes_number_at_level ( level = level ) bbb = b + bb - 1 call node ( bbb )% save_geometry_tecplot_ascii ( file_unit = file_unit , aabb_name = 'aabb-l_' // trim ( str ( level , . true .)) // & '-b_' // trim ( str ( bbb , . true .))) enddo enddo close ( file_unit ) endif endassociate endsubroutine save_geometry_tecplot_ascii","tags":"","loc":"proc/save_geometry_tecplot_ascii~3.html","title":"save_geometry_tecplot_ascii – FOSSIL"},{"text":"private subroutine save_into_file_stl(self, base_file_name, is_ascii) Save  AABB tree boxes facets into files STL. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: base_file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. Calls proc~~save_into_file_stl~~CallsGraph proc~save_into_file_stl save_into_file_stl node node proc~save_into_file_stl->node str str proc~save_into_file_stl->str proc~first_node first_node proc~save_into_file_stl->proc~first_node proc~nodes_number_at_level nodes_number_at_level proc~save_into_file_stl->proc~nodes_number_at_level proc~nodes_number nodes_number proc~first_node->proc~nodes_number proc~nodes_number->proc~nodes_number_at_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_into_file_stl Source Code subroutine save_into_file_stl ( self , base_file_name , is_ascii ) !< Save  AABB tree boxes facets into files STL. class ( aabb_tree_object ), intent ( in ) :: self !< AABB tree. character ( * ), intent ( in ) :: base_file_name !< File name. logical , intent ( in ), optional :: is_ascii !< Sentinel to check if file is ASCII. logical :: is_ascii_ !< Sentinel to check if file is ASCII, local variable. integer ( I4P ) :: level !< Counter. integer ( I4P ) :: b , bb , bbb !< Counter. associate ( node => self % node ) if ( self % is_initialized ) then is_ascii_ = . false . ; if ( present ( is_ascii )) is_ascii_ = is_ascii do level = 0 , self % refinement_levels b = first_node ( level = level ) do bb = 1 , nodes_number_at_level ( level = level ) bbb = b + bb - 1 call node ( bbb )% save_facets_into_file_stl ( file_name = trim ( adjustl ( base_file_name )) // & 'aabb-l_' // trim ( str ( level , . true .)) // & '-b_' // trim ( str ( bbb , . true .)) // '.stl' , is_ascii = is_ascii_ ) enddo enddo endif endassociate endsubroutine save_into_file_stl","tags":"","loc":"proc/save_into_file_stl.html","title":"save_into_file_stl – FOSSIL"},{"text":"private pure subroutine aabb_tree_assign_aabb_tree(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: lhs Left hand side. type( aabb_tree_object ), intent(in) :: rhs Right hand side. Source Code aabb_tree_assign_aabb_tree Source Code pure subroutine aabb_tree_assign_aabb_tree ( lhs , rhs ) !< Operator `=`. class ( aabb_tree_object ), intent ( inout ) :: lhs !< Left hand side. type ( aabb_tree_object ), intent ( in ) :: rhs !< Right hand side. integer :: b !< Counter. if ( allocated ( lhs % node )) then do b = 1 , lhs % nodes_number call lhs % node % destroy enddo deallocate ( lhs % node ) endif lhs % refinement_levels = rhs % refinement_levels lhs % nodes_number = rhs % nodes_number if ( allocated ( rhs % node )) then allocate ( lhs % node ( 0 : lhs % nodes_number - 1 )) do b = 0 , lhs % nodes_number - 1 lhs % node ( b ) = rhs % node ( b ) enddo endif lhs % is_initialized = rhs % is_initialized endsubroutine aabb_tree_assign_aabb_tree","tags":"","loc":"proc/aabb_tree_assign_aabb_tree.html","title":"aabb_tree_assign_aabb_tree – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~~CalledByGraph proc~cli_parse cli_parse program~fossil_test_sanitize_normals fossil_test_sanitize_normals program~fossil_test_sanitize_normals->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_sanitize_normals' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_sanitize_normals --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube-inconsistent.stl' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse","tags":"","loc":"proc/cli_parse.html","title":"cli_parse – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~2~~CalledByGraph proc~cli_parse~2 cli_parse program~fossil_test_translate fossil_test_translate program~fossil_test_translate->proc~cli_parse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: delta_ ( 3 ) !< Vectorial delta. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_translate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_translate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--delta' , & help = 'vectorial delta' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'delta x' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'delta y' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'delta z' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--delta' , val = delta_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop delta % x = delta_ ( 1 ) delta % y = delta_ ( 2 ) delta % z = delta_ ( 3 ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~2.html","title":"cli_parse – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~3~~CalledByGraph proc~cli_parse~3 cli_parse program~fossil_test_distance fossil_test_distance program~fossil_test_distance->proc~cli_parse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_distance' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_distance --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/naca0012-binary.stl' , & act = 'store' ) call cli % add ( switch = '--ref_levels' , & help = 'AABB refinement levels' , & required = . false ., & def = '2' , & act = 'store' ) call cli % add ( switch = '--save_aabb_tree_geometry' , & help = 'save AABB tree geometry' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--save_aabb_tree_stl' , & help = 'save AABB tree STL' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--brute_force' , & help = 'test (also) brute force' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--sign_algorithm' , & help = 'algorithm used to compute sign of distance' , & required = . false ., & def = 'ray_intersections' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ref_levels' , val = refinement_levels , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_geometry' , val = save_aabb_tree_geometry , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_stl' , val = save_aabb_tree_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--brute_force' , val = test_brute_force , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--sign_algorithm' , val = sign_algorithm , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~3.html","title":"cli_parse – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~4~~CalledByGraph proc~cli_parse~4 cli_parse program~fossil_test_mirror fossil_test_mirror program~fossil_test_mirror->proc~cli_parse~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: normal_ ( 3 ) !< Normal of mirroring plane. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_mirror' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_mirror --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--normal' , & help = 'normal of mirroring plane' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--normal' , val = normal_ , error = error ) ; if ( error /= 0 ) stop normal % x = normal_ ( 1 ) normal % y = normal_ ( 2 ) normal % z = normal_ ( 3 ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~4.html","title":"cli_parse – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~5~~CalledByGraph proc~cli_parse~5 cli_parse program~fossil_test_resize fossil_test_resize program~fossil_test_resize->proc~cli_parse~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: factor_ ( 3 ) !< Vectorial factor. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_resize' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_resize --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--factor' , & help = 'vectorial factor' , & required = . false ., & nargs = '+' , & def = '2.0 2.0 2.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'factor x' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'factor y' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'factor z' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--factor' , val = factor_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop factor % x = factor_ ( 1 ) factor % y = factor_ ( 2 ) factor % z = factor_ ( 3 ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~5.html","title":"cli_parse – FOSSIL"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~6~~CalledByGraph proc~cli_parse~6 cli_parse program~fossil_test_rotate fossil_test_rotate program~fossil_test_rotate->proc~cli_parse~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: axis_ ( 3 ) !< Axis of rotation. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_rotate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_rotate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--axis' , & help = 'axis of rotation' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--angle' , & help = 'angle of rotation' , & required = . false ., & def = '1.57079633' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--axis' , val = axis_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--angle' , val = angle , error = error ) ; if ( error /= 0 ) stop axis % x = axis_ ( 1 ) axis % y = axis_ ( 2 ) axis % z = axis_ ( 3 ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~6.html","title":"cli_parse – FOSSIL"},{"text":"Uses: fossil_utils iso_fortran_env penf vecfor module~~fossil_facet_object~~UsesGraph module~fossil_facet_object fossil_facet_object module~fossil_utils fossil_utils module~fossil_utils->module~fossil_facet_object vecfor vecfor vecfor->module~fossil_facet_object penf penf penf->module~fossil_facet_object penf->module~fossil_utils iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_facet_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, facet class definition. Used By module~~fossil_facet_object~~UsedByGraph module~fossil_facet_object fossil_facet_object module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_file_stl_object fossil_file_stl_object module~fossil_facet_object->module~fossil_file_stl_object module~fossil fossil module~fossil_facet_object->module~fossil module~fossil_aabb_object fossil_aabb_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_file_stl_object->module~fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize module~fossil_aabb_object->module~fossil_aabb_node_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_tree_object->module~fossil_file_stl_object var panmodulefossil_facet_objectUsedByGraph = svgPanZoom('#modulefossil_facet_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types facet_object Functions check_normal distance do_ray_intersect solid_angle tetrahedron_volume vertex_global_id Subroutines add_vertex_occurrence check_vertices_occurrencies compute_metrix compute_normal destroy initialize load_from_file_ascii load_from_file_binary make_normal_consistent resize reverse_normal save_into_file_ascii save_into_file_binary translate update_connectivity flip_edge mirror_by_normal mirror_by_matrix rotate_by_axis_angle rotate_by_matrix edge_connection_in_other_ref facet_assign_facet Derived Types type, public :: facet_object FOSSIL, facet class. Components Type Visibility Attributes Name Initial type(vector_R8P), public :: normal Facet (outward) normal (versor), (v2-v1).cross.(v3-v1) . type(vector_R8P), public :: vertex_1 Facet vertex 1. type(vector_R8P), public :: vertex_2 Facet vertex 2. type(vector_R8P), public :: vertex_3 Facet vertex 3. type(vector_R8P), public :: E12 Edge 1-2, V2-V1 . type(vector_R8P), public :: E13 Edge 1-3, V3-V1 . real(kind=R8P), public :: a = 0._R8P E12.dot.E12 . real(kind=R8P), public :: b = 0._R8P E12.dot.E13 . real(kind=R8P), public :: c = 0._R8P E13.dot.E13 . real(kind=R8P), public :: det = 0._R8P a*c - b*b . real(kind=R8P), public :: d = 0._R8P normal.dot.vertex_1 type(vector_R8P), public :: bb (2) Axis-aligned bounding box (AABB), bb(1)=min, bb(2)=max. integer(kind=I4P), public :: id Facet global ID. integer(kind=I4P), public :: fcon_edge_12 = 0_I4P Connected face ID along edge 1-2. integer(kind=I4P), public :: fcon_edge_23 = 0_I4P Connected face ID along edge 2-3. integer(kind=I4P), public :: fcon_edge_31 = 0_I4P Connected face ID along edge 3-1. integer(kind=I4P), public, allocatable :: vertex_1_occurrence (:) List of vertex 1 \"occurrencies\", list of facets global ID containing it. integer(kind=I4P), public, allocatable :: vertex_2_occurrence (:) List of vertex 2 \"occurrencies\", list of facets global ID containing it. integer(kind=I4P), public, allocatable :: vertex_3_occurrence (:) List of vertex 3 \"occurrencies\", list of facets global ID containing it. Type-Bound Procedures procedure, public, pass(self) :: add_vertex_occurrence Add vertex occurence. procedure, public, pass(self) :: check_normal Check normal consistency. procedure, public, pass(self) :: check_vertices_occurrencies Check if vertices of facet are identical to ones of other facet. procedure, public, pass(self) :: compute_metrix Compute local (plane) metrix. procedure, public, pass(self) :: compute_normal Compute normal by means of vertices data. procedure, public, pass(self) :: destroy Destroy facet. procedure, public, pass(self) :: distance Compute the (unsigned, squared) distance from a point to facet. procedure, public, pass(self) :: do_ray_intersect Return true if facet is intersected by a ray. procedure, public, pass(self) :: initialize Initialize facet. procedure, public, pass(self) :: load_from_file_ascii Load facet from ASCII file. procedure, public, pass(self) :: load_from_file_binary Load facet from binary file. procedure, public, pass(self) :: make_normal_consistent Make normal of other facet consistent with self. generic, public :: mirror => mirror_by_normal, mirror_by_matrix Mirror facet. procedure, public, pass(self) :: reverse_normal Reverse facet normal. procedure, public, pass(self) :: resize Resize (scale) facet by x or y or z or vectorial factors. generic, public :: rotate => rotate_by_axis_angle, rotate_by_matrix Rotate facet. procedure, public, pass(self) :: save_into_file_ascii Save facet into ASCII file. procedure, public, pass(self) :: save_into_file_binary Save facet into binary file. procedure, public, pass(self) :: solid_angle Return the (projected) solid angle of the facet with respect point. procedure, public, pass(self) :: tetrahedron_volume Return the volume of tetrahedron built by facet and a given apex. procedure, public, pass(self) :: translate Translate facet given vectorial delta. procedure, public, pass(self) :: update_connectivity Update facet connectivity. procedure, public, pass(self) :: vertex_global_id Return the vertex global id given the local one. generic, public :: assignment(=) => facet_assign_facet Overload = . procedure, private, pass(self) :: edge_connection_in_other_ref Return the edge of connection in the other reference. procedure, private, pass(lhs) :: facet_assign_facet Operator = . procedure, private, pass(self) :: flip_edge Flip facet edge. procedure, private, pass(self) :: mirror_by_normal Mirror facet given normal of mirroring plane. procedure, private, pass(self) :: mirror_by_matrix Mirror facet given matrix. procedure, private, pass(self) :: rotate_by_axis_angle Rotate facet given axis and angle. procedure, private, pass(self) :: rotate_by_matrix Rotate facet given matrix. Functions private elemental function check_normal (self) result(is_consistent) Check normal consistency. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. Return Value logical Consistency check result. private pure function distance (self, point) Compute the (unsigned, squared) distance from a point to the facet surface. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Closest distance from point to the facet. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(intersect) Return true if facet is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Intersection test result. private pure function solid_angle (self, point) Return the (projected) solid angle of the facet with respect the point. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: point Point. Return Value real(kind=R8P) Solid angle. private pure function tetrahedron_volume (self, apex) result(volume) Return the volume of tetrahedron built by facet and a given apex. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type(vector_R8P), intent(in) :: apex Tetrahedron apex. Return Value real(kind=R8P) Tetrahedron volume. private pure function vertex_global_id (self, vertex_id) Return the vertex global id given the local one. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Local vertex id. Return Value integer(kind=I4P) Gloval vertex id. Subroutines private elemental subroutine add_vertex_occurrence (self, vertex_id, facet_id) Add vertex occurrence. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: vertex_id Vertex ID in local numeration, 1, 2 or 3. integer(kind=I4P), intent(in) :: facet_id Other facet ID containing vertex. private pure subroutine check_vertices_occurrencies (self, other) Check if vertices of facet are identical (with tollerance) to the ones of other facet. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type( facet_object ), intent(inout) :: other Other facet. private elemental subroutine compute_metrix (self) Compute local (plane) metrix. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private elemental subroutine compute_normal (self) Compute normal by means of vertices data. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private elemental subroutine initialize (self) Initialize facet. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private subroutine load_from_file_ascii (self, file_unit) Load facet from ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. private subroutine load_from_file_binary (self, file_unit) Load facet from binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. private pure subroutine make_normal_consistent (self, edge_dir, other) Make normal of other facet consistent with self. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. character(len=*), intent(in) :: edge_dir Edge (in self numeration) along which other is connected. type( facet_object ), intent(inout) :: other Other facet to make consistent with self. private elemental subroutine resize (self, factor, recompute_metrix) Resize (scale) facet by x or y or z or vectorial factors. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet type(vector_R8P), intent(in) :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private elemental subroutine reverse_normal (self) Reverse facet normal. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private subroutine save_into_file_ascii (self, file_unit) Save facet into ASCII file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. private subroutine save_into_file_binary (self, file_unit) Save facet into binary file. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. integer(kind=I4P), intent(in) :: file_unit File unit. private elemental subroutine translate (self, delta, recompute_metrix) Translate facet given vectorial delta. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: delta Translation delta. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine update_connectivity (self) Update facet connectivity. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. private pure subroutine flip_edge (self, edge_dir) Flip facet edge. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. character(len=*), intent(in) :: edge_dir Edge to be flipped. private pure subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facet given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facet given axis and angle. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: self Facet. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine edge_connection_in_other_ref (self, other, edge_dir, edge) Return the edge of connection in the other reference. Arguments Type Intent Optional Attributes Name class( facet_object ), intent(in) :: self Facet. type( facet_object ), intent(in) :: other Other facet. character(len=*), intent(out) :: edge_dir Edge (in other numeration) along which self is connected. type(vector_R8P), intent(out) :: edge Edge (in other numeration) along which self is connected. private pure subroutine facet_assign_facet (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( facet_object ), intent(inout) :: lhs Left hand side. type( facet_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/fossil_facet_object.html","title":"fossil_facet_object – FOSSIL"},{"text":"Uses: fossil_facet_object fossil_utils iso_fortran_env penf vecfor module~~fossil_aabb_object~~UsesGraph module~fossil_aabb_object fossil_aabb_object module~fossil_utils fossil_utils module~fossil_utils->module~fossil_aabb_object module~fossil_facet_object fossil_facet_object module~fossil_utils->module~fossil_facet_object penf penf penf->module~fossil_aabb_object penf->module~fossil_utils penf->module~fossil_facet_object vecfor vecfor vecfor->module~fossil_aabb_object vecfor->module~fossil_facet_object module~fossil_facet_object->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_aabb_object iso_fortran_env->module~fossil_facet_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, Axis-Aligned Bounding Box (AABB) class definition. Used By module~~fossil_aabb_object~~UsedByGraph module~fossil_aabb_object fossil_aabb_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_aabb_object->module~fossil_aabb_node_object module~fossil_file_stl_object fossil_file_stl_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil fossil module~fossil_file_stl_object->module~fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize var panmodulefossil_aabb_objectUsedByGraph = svgPanZoom('#modulefossil_aabb_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types aabb_object Functions closest_point distance distance_from_facets do_ray_intersect has_facets is_inside ray_intersections_number vertex Subroutines add_facets compute_octants destroy initialize save_geometry_tecplot_ascii save_facets_into_file_stl update_extents aabb_assign_aabb compute_bb_from_facets Derived Types type, public :: aabb_object FOSSIL Axis-Aligned Bounding Box (AABB) class. Components Type Visibility Attributes Name Initial type(vector_R8P), public :: bmin Minimum point of AABB. type(vector_R8P), public :: bmax Maximum point of AABB. integer(kind=I4P), public :: facets_number = 0 Facets number. type( facet_object ), public, allocatable :: facet (:) Facets. Type-Bound Procedures procedure, public, pass(self) :: add_facets Add facets to AABB. procedure, public, pass(self) :: closest_point Return closest point on AABB from point reference. procedure, public, pass(self) :: compute_octants Compute AABB octants. procedure, public, pass(self) :: destroy Destroy AABB. procedure, public, pass(self) :: distance Return the (square) distance from point to AABB. procedure, public, pass(self) :: distance_from_facets Return the (square) distance from point to AABB's facets. procedure, public, pass(self) :: do_ray_intersect Return true if AABB is intersected by ray. procedure, public, pass(self) :: has_facets Return true if AABB has facets. procedure, public, pass(self) :: initialize Initialize AABB. procedure, public, pass(self) :: is_inside Return the true if point is inside ABB. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB geometry into Tecplot ascii file. procedure, public, pass(self) :: save_facets_into_file_stl Save facets into file STL. procedure, public, pass(self) :: update_extents Update AABB bounding box extents. procedure, public, pass(self) :: vertex Return AABB vertices. generic, public :: assignment(=) => aabb_assign_aabb Overload = . procedure, private, pass(lhs) :: aabb_assign_aabb Operator = . Functions private pure function closest_point (self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. private pure function distance (self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. private pure function distance_from_facets (self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. private pure function has_facets (self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB box. Return Value logical Check result. private pure function is_inside (self, point) Return the true if point is inside ABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value logical Check result. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. private pure function vertex (self) Return AABB vertices. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. Return Value type(vector_R8P)\n  (8) AABB vertices. Subroutines private subroutine add_facets (self, facet) Add facets to AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. private pure subroutine compute_octants (self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. private pure subroutine initialize (self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. private subroutine save_geometry_tecplot_ascii (self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. private subroutine save_facets_into_file_stl (self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. private pure subroutine update_extents (self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: self AABB. private pure subroutine aabb_assign_aabb (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_object ), intent(inout) :: lhs Left hand side. type( aabb_object ), intent(in) :: rhs Right hand side. private pure subroutine compute_bb_from_facets (facet, bmin, bmax) Compute AABB extents (minimum and maximum bounding box) from facets list. Arguments Type Intent Optional Attributes Name type( facet_object ), intent(in) :: facet (:) Facets list. type(vector_R8P), intent(inout) :: bmin Minimum point of AABB. type(vector_R8P), intent(inout) :: bmax Maximum point of AABB.","tags":"","loc":"module/fossil_aabb_object.html","title":"fossil_aabb_object – FOSSIL"},{"text":"Uses: penf module~~fossil_utils~~UsesGraph module~fossil_utils fossil_utils penf penf penf->module~fossil_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, utils library. Used By module~~fossil_utils~~UsedByGraph module~fossil_utils fossil_utils module~fossil_file_stl_object fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object module~fossil_utils->module~fossil_facet_object module~fossil_aabb_object fossil_aabb_object module~fossil_utils->module~fossil_aabb_object module~fossil fossil module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_facet_object->module~fossil module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object module~fossil_aabb_object->module~fossil_aabb_tree_object program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_tree_object->module~fossil_file_stl_object var panmodulefossil_utilsUsedByGraph = svgPanZoom('#modulefossil_utilsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables EPS FRLEN PI Variables Type Visibility Attributes Name Initial real(kind=R8P), public, parameter :: EPS = real(ZeroR4P, R8P) Small EPSILON to avoid rund off errors. integer(kind=I4P), public, parameter :: FRLEN = 80 Maximum length of fossil STL label string. real(kind=R8P), public, parameter :: PI = 4._R8P*atan(1._R8P) Pi greek.","tags":"","loc":"module/fossil_utils.html","title":"fossil_utils – FOSSIL"},{"text":"Uses: fossil_aabb_tree_object fossil_facet_object fossil_utils iso_fortran_env penf vecfor module~~fossil_file_stl_object~~UsesGraph module~fossil_file_stl_object fossil_file_stl_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils fossil_utils module~fossil_utils->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object module~fossil_utils->module~fossil_facet_object module~fossil_aabb_object fossil_aabb_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_facet_object module~fossil_aabb_node_object fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object penf penf penf->module~fossil_file_stl_object penf->module~fossil_aabb_tree_object penf->module~fossil_utils penf->module~fossil_facet_object penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object vecfor vecfor vecfor->module~fossil_file_stl_object vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panmodulefossil_file_stl_objectUsesGraph = svgPanZoom('#modulefossil_file_stl_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL,  STL file class definition. Used By module~~fossil_file_stl_object~~UsedByGraph module~fossil_file_stl_object fossil_file_stl_object module~fossil fossil module~fossil_file_stl_object->module~fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types file_stl_object Functions distance is_point_inside_polyhedron_ri is_point_inside_polyhedron_sa statistics Subroutines analize build_connectivity close_file compute_metrix compute_normals compute_volume create_aabb_tree destroy initialize load_from_file open_file reverse_normals sanitize_normals save_into_file resize translate file_stl_assign_file_stl allocate_facets load_facets_number_from_file load_header_from_file mirror_by_normal mirror_by_matrix rotate_by_axis_angle rotate_by_matrix save_header_into_file save_trailer_into_file Derived Types type, public :: file_stl_object FOSSIL STL file class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_name File name integer(kind=I4P), public :: file_unit = 0 File unit. character(len=FRLEN), public :: header File header. integer(kind=I4P), public :: facets_number = 0 Facets number. type( facet_object ), public, allocatable :: facet (:) Facets. type( aabb_tree_object ), public :: aabb AABB tree. type(vector_R8P), public :: bmin Minimum point of STL. type(vector_R8P), public :: bmax Maximum point of STL. real(kind=R8P), public :: volume = 0._R8P Volume bounded by STL surface. logical, public :: is_ascii = .true. Sentinel to check if file is ASCII. logical, public :: is_open = .false. Sentinel to check if file is open. Type-Bound Procedures procedure, public, pass(self) :: analize Analize STL. procedure, public, pass(self) :: build_connectivity Build facets connectivity. procedure, public, pass(self) :: close_file Close file. procedure, public, pass(self) :: compute_metrix Compute facets metrix. procedure, public, pass(self) :: compute_normals Compute facets normals by means of vertices data. procedure, public, pass(self) :: compute_volume Compute volume bounded by STL surface. procedure, public, pass(self) :: create_aabb_tree Create the AABB tree. procedure, public, pass(self) :: destroy Destroy file. procedure, public, pass(self) :: distance Compute the (minimum) distance from point to triangulated surface. procedure, public, pass(self) :: initialize Initialize file. procedure, public, pass(self) :: is_point_inside_polyhedron_ri Determinate is point is inside or not STL facets by ray intersect. procedure, public, pass(self) :: is_point_inside_polyhedron_sa Determinate is point is inside or not STL facets by solid angle. procedure, public, pass(self) :: load_from_file Load from file. generic, public :: mirror => mirror_by_normal, mirror_by_matrix Mirror facets. procedure, public, pass(self) :: open_file Open file, once initialized. procedure, public, pass(self) :: reverse_normals Reverse facets normals. procedure, public, pass(self) :: resize Resize (scale) facets by x or y or z or vectorial factors. generic, public :: rotate => rotate_by_axis_angle, rotate_by_matrix Rotate facets. procedure, public, pass(self) :: sanitize_normals Sanitize facets normals, make them consistent. procedure, public, pass(self) :: save_into_file Save into file. procedure, public, pass(self) :: statistics Return STL statistics. procedure, public, pass(self) :: translate Translate facet given vectorial delta. generic, public :: assignment(=) => file_stl_assign_file_stl Overload = . procedure, private, pass(lhs) :: file_stl_assign_file_stl Operator = . procedure, private, pass(self) :: allocate_facets Allocate facets. procedure, private, pass(self) :: load_facets_number_from_file Load facets number from file. procedure, private, pass(self) :: load_header_from_file Load header from file. procedure, private, pass(self) :: mirror_by_normal Mirror facets given normal of mirroring plane. procedure, private, pass(self) :: mirror_by_matrix Mirror facets given matrix. procedure, private, pass(self) :: rotate_by_axis_angle Rotate facets given axis and angle. procedure, private, pass(self) :: rotate_by_matrix Rotate facets given matrix. procedure, private, pass(self) :: save_header_into_file Save header into file. procedure, private, pass(self) :: save_trailer_into_file Save trailer into file. Functions private pure function distance (self, point, is_signed, sign_algorithm, is_square_root) Compute the (minimum) distance from a point to the triangulated surface. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. logical, intent(in), optional :: is_signed Sentinel to trigger signed distance. character(len=*), intent(in), optional :: sign_algorithm Algorithm used for \"point in polyhedron\" test. logical, intent(in), optional :: is_square_root Sentinel to trigger square-root distance. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. private pure function is_point_inside_polyhedron_ri (self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means ray intersections count. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. private pure function is_point_inside_polyhedron_sa (self, point) result(is_inside) Determinate is a point is inside or not to a polyhedron described by STL facets by means of the solid angle criteria. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. type(vector_R8P), intent(in) :: point Point coordinates. Return Value logical Check result. private pure function statistics (self, prefix) result(stats) Return STL statistics. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(in) :: self File STL. character(len=*), intent(in), optional :: prefix Lines prefix. Return Value character(len=:),\n  allocatable STL statistics. Subroutines private pure subroutine analize (self) Analize STL. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private pure subroutine build_connectivity (self) Build facets connectivity. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine close_file (self) Close file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private pure subroutine compute_metrix (self) Compute facets metrix. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private elemental subroutine compute_normals (self) Compute facets normals by means of vertices data. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private elemental subroutine compute_volume (self) Compute volume bounded by STL surface. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine create_aabb_tree (self, refinement_levels) Create AABB tree. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. integer(kind=I4P), intent(in), optional :: refinement_levels Total number of refinement levels used. private elemental subroutine destroy (self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private elemental subroutine initialize (self, skip_destroy, file_name, is_ascii) Initialize file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. logical, intent(in), optional :: skip_destroy Flag to skip destroy file. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. private subroutine load_from_file (self, file_name, is_ascii, guess_format, disable_analysis) Load from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. logical, intent(in), optional :: disable_analysis Sentinel to disable STL analysis. private subroutine open_file (self, file_action, guess_format) Open file, once initialized. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in) :: file_action File action, \"read\" or \"write\". logical, intent(in), optional :: guess_format Sentinel to try to guess format directly from file. private elemental subroutine reverse_normals (self) Reverse facets normals. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private pure subroutine sanitize_normals (self) Sanitize facets normals, make them consistent. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine save_into_file (self, file_name, is_ascii) Save into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. character(len=*), intent(in), optional :: file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. private elemental subroutine resize (self, x, y, z, factor, recompute_metrix) Resize (scale) facets by x or y or z or vectorial factors. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Factor along x axis. real(kind=R8P), intent(in), optional :: y Factor along y axis. real(kind=R8P), intent(in), optional :: z Factor along z axis. type(vector_R8P), intent(in), optional :: factor Vectorial factor. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private elemental subroutine translate (self, x, y, z, delta, recompute_metrix) Translate facets x or y or z or vectorial delta increments. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in), optional :: x Increment along x axis. real(kind=R8P), intent(in), optional :: y Increment along y axis. real(kind=R8P), intent(in), optional :: z Increment along z axis. type(vector_R8P), intent(in), optional :: delta Vectorial increment. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine file_stl_assign_file_stl (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: lhs Left hand side. type( file_stl_object ), intent(in) :: rhs Right hand side. private elemental subroutine allocate_facets (self) Allocate facets. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine load_facets_number_from_file (self) Load facets number from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine load_header_from_file (self) Load header from file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private elemental subroutine mirror_by_normal (self, normal, recompute_metrix) Mirror facets given normal of mirroring plane. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: normal Normal of mirroring plane. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine mirror_by_matrix (self, matrix, recompute_metrix) Mirror facet given matrix (of mirroring). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Mirroring matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private elemental subroutine rotate_by_axis_angle (self, axis, angle, recompute_metrix) Rotate facets given axis and angle. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. type(vector_R8P), intent(in) :: axis Axis of rotation. real(kind=R8P), intent(in) :: angle Angle of rotation. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private pure subroutine rotate_by_matrix (self, matrix, recompute_metrix) Rotate facet given matrix (of ratation). Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. real(kind=R8P), intent(in) :: matrix (3,3) Rotation matrix. logical, intent(in), optional :: recompute_metrix Sentinel to activate metrix recomputation. private subroutine save_header_into_file (self) Save header into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL. private subroutine save_trailer_into_file (self) Save trailer into file. Arguments Type Intent Optional Attributes Name class( file_stl_object ), intent(inout) :: self File STL.","tags":"","loc":"module/fossil_file_stl_object.html","title":"fossil_file_stl_object – FOSSIL"},{"text":"Uses: fossil_facet_object fossil_file_stl_object module~~fossil~~UsesGraph module~fossil fossil module~fossil_file_stl_object fossil_file_stl_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object fossil_facet_object module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils fossil_utils module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object penf penf penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object vecfor vecfor vecfor->module~fossil_file_stl_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panmodulefossilUsesGraph = svgPanZoom('#modulefossilUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, FOrtran Stereo (si) Litography parser. Used By module~~fossil~~UsedByGraph module~fossil fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/fossil.html","title":"fossil – FOSSIL"},{"text":"Uses: fossil_aabb_object fossil_facet_object iso_fortran_env penf vecfor module~~fossil_aabb_node_object~~UsesGraph module~fossil_aabb_node_object fossil_aabb_node_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object iso_fortran_env->module~fossil_aabb_object module~fossil_facet_object fossil_facet_object iso_fortran_env->module~fossil_facet_object penf penf penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object penf->module~fossil_facet_object module~fossil_utils fossil_utils penf->module~fossil_utils vecfor vecfor vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object vecfor->module~fossil_facet_object module~fossil_aabb_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_utils->module~fossil_aabb_object module~fossil_utils->module~fossil_facet_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, Axis-Aligned Bounding Box (AABB) tree-node class definition. This is just a container for AABB tree's nodes. Used By module~~fossil_aabb_node_object~~UsedByGraph module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_file_stl_object fossil_file_stl_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil fossil module~fossil_file_stl_object->module~fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize var panmodulefossil_aabb_node_objectUsedByGraph = svgPanZoom('#modulefossil_aabb_node_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types aabb_node_object Functions bmin bmax closest_point distance distance_from_facets do_ray_intersect has_facets is_allocated ray_intersections_number Subroutines add_facets compute_octants destroy initialize save_geometry_tecplot_ascii save_facets_into_file_stl update_extents aabb_node_assign_aabb_node Derived Types type, public :: aabb_node_object FOSSIL Axis-Aligned Bounding Box (AABB) tree-node class. Components Type Visibility Attributes Name Initial type( aabb_object ), private, allocatable :: aabb AABB data. Type-Bound Procedures procedure, public, pass(self) :: add_facets Add facets to AABB. procedure, public, pass(self) :: bmin Return AABB bmin. procedure, public, pass(self) :: bmax Return AABB bmax. procedure, public, pass(self) :: closest_point Return closest point on AABB from point reference. procedure, public, pass(self) :: compute_octants Compute AABB octants. procedure, public, pass(self) :: destroy Destroy AABB. procedure, public, pass(self) :: distance Return the (square) distance from point to AABB. procedure, public, pass(self) :: distance_from_facets Return the (square) distance from point to AABB's facets. procedure, public, pass(self) :: do_ray_intersect Return true if AABB is intersected by ray. procedure, public, pass(self) :: has_facets Return true if AABB has facets. procedure, public, pass(self) :: initialize Initialize AABB. procedure, public, pass(self) :: is_allocated Return true is node is allocated. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB geometry into Tecplot ascii file. procedure, public, pass(self) :: save_facets_into_file_stl Save facets into file STL. procedure, public, pass(self) :: update_extents Update AABB bounding box extents. generic, public :: assignment(=) => aabb_node_assign_aabb_node Overload = . procedure, private, pass(lhs) :: aabb_node_assign_aabb_node Operator = . Functions private pure function bmin (self) Return AABB bmin. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmin. private pure function bmax (self) Return AABB bmax. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value type(vector_R8P) AABB bmax. private pure function closest_point (self, point) result(closest) Return closest point on (or in) AABB from point reference. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. type(vector_R8P), intent(in) :: point Point reference. Return Value type(vector_R8P) Closest point on (on in) aabb to point. private pure function distance (self, point) Return the (square) distance from point to AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB. private pure function distance_from_facets (self, point) result(distance) Return the (square) distance from point to AABB's facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: point Point reference. Return Value real(kind=R8P) Distance from point to AABB's facets. private pure function do_ray_intersect (self, ray_origin, ray_direction) result(do_intersect) Return true if AABB is intersected by ray from origin and oriented as ray direction vector. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value logical Test result. private pure function has_facets (self) Return true if AABB has facets. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. private pure function is_allocated (self) Return true if node is allocated. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB box. Return Value logical Check result. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. Subroutines private subroutine add_facets (self, facet) Add facets to AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(inout), allocatable :: facet (:) Facets list. private pure subroutine compute_octants (self, octant) Return AABB octants. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. type( aabb_object ), intent(out) :: octant (8) AABB octants. private elemental subroutine destroy (self) Destroy AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. private pure subroutine initialize (self, facet, bmin, bmax) Initialize AABB. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. private subroutine save_geometry_tecplot_ascii (self, file_unit, aabb_name) Save AABB geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. integer(kind=I4P), intent(in) :: file_unit File unit. character(len=*), intent(in), optional :: aabb_name Name of AABB. private subroutine save_facets_into_file_stl (self, file_name, is_ascii) Save facets into file STL. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(in) :: self AABB. character(len=*), intent(in) :: file_name File name. logical, intent(in) :: is_ascii Sentinel to check if file is ASCII. private pure subroutine update_extents (self) Update AABB bounding box extents. Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: self AABB. private pure subroutine aabb_node_assign_aabb_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_node_object ), intent(inout) :: lhs Left hand side. type( aabb_node_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/fossil_aabb_node_object.html","title":"fossil_aabb_node_object – FOSSIL"},{"text":"Uses: fossil_aabb_object fossil_aabb_node_object fossil_facet_object iso_fortran_env penf vecfor module~~fossil_aabb_tree_object~~UsesGraph module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object penf penf penf->module~fossil_aabb_tree_object penf->module~fossil_aabb_node_object module~fossil_facet_object fossil_facet_object penf->module~fossil_facet_object module~fossil_aabb_object fossil_aabb_object penf->module~fossil_aabb_object module~fossil_utils fossil_utils penf->module~fossil_utils vecfor vecfor vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object var panmodulefossil_aabb_tree_objectUsesGraph = svgPanZoom('#modulefossil_aabb_tree_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, Axis-Aligned Bounding Box (AABB) tree class definition. Note The tree is assumed to be an octree . Used By module~~fossil_aabb_tree_object~~UsedByGraph module~fossil_aabb_tree_object fossil_aabb_tree_object module~fossil_file_stl_object fossil_file_stl_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil fossil module~fossil_file_stl_object->module~fossil program~fossil_test_distance fossil_test_distance module~fossil->program~fossil_test_distance program~fossil_test_sanitize_normals fossil_test_sanitize_normals module~fossil->program~fossil_test_sanitize_normals program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil->program~fossil_test_load_save_ascii program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil->program~fossil_test_load_save_binary program~fossil_test_rotate fossil_test_rotate module~fossil->program~fossil_test_rotate program~fossil_test_mirror fossil_test_mirror module~fossil->program~fossil_test_mirror program~fossil_test_translate fossil_test_translate module~fossil->program~fossil_test_translate program~fossil_test_resize fossil_test_resize module~fossil->program~fossil_test_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables TREE_RATIO Derived Types aabb_tree_object Functions distance ray_intersections_number first_child_node first_node nodes_number nodes_number_at_level parent_node Subroutines destroy initialize save_geometry_tecplot_ascii save_into_file_stl aabb_tree_assign_aabb_tree Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: TREE_RATIO = 8 Tree refinement ratio, it is assumed to be an octree . Derived Types type, public :: aabb_tree_object FOSSIL Axis-Aligned Bounding Box (AABB) tree class. Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: refinement_levels = 0 Total number of refinement levels used. integer(kind=I4P), public :: nodes_number = 0 Total number of tree nodes. type( aabb_node_object ), public, allocatable :: node (:) AABB tree nodes [0:nodes_number-1]. logical, public :: is_initialized = .false. Sentinel to check is AABB tree is initialized. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy AABB tree. procedure, public, pass(self) :: distance Compute the (minimum) distance from point to triangulated surface. procedure, public, pass(self) :: initialize Initialize AABB tree. procedure, public, pass(self) :: ray_intersections_number Return ray intersections number. procedure, public, pass(self) :: save_geometry_tecplot_ascii Save AABB tree boxes geometry into Tecplot ascii file. procedure, public, pass(self) :: save_into_file_stl Save  AABB tree boxes facets into files STL. generic, public :: assignment(=) => aabb_tree_assign_aabb_tree Overload = . procedure, private, pass(lhs) :: aabb_tree_assign_aabb_tree Operator = . Functions private pure function distance (self, point) Compute the (minimum) distance from a point to the triangulated surface. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: point Point coordinates. Return Value real(kind=R8P) Minimum distance from point to the triangulated surface. private pure function ray_intersections_number (self, ray_origin, ray_direction) result(intersections_number) Return ray intersections number. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. type(vector_R8P), intent(in) :: ray_origin Ray origin. type(vector_R8P), intent(in) :: ray_direction Ray direction. Return Value integer(kind=I4P) Intersection number. private pure function first_child_node (node) Return first child tree node. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: node Node queried. Return Value integer(kind=I4P) First child tree node. private pure function first_node (level) Return first tree node at a given level. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: level Refinement level queried. Return Value integer(kind=I4P) Number of tree nodes at given level. private pure function nodes_number (refinement_levels) Return total number of tree nodes given the total number refinement levels used. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: refinement_levels Total number of refinement levels used. Return Value integer(kind=I4P) Total number of tree nodes. private pure function nodes_number_at_level (level) result(nodes_number) Return number of tree nodes at a given level. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: level Refinement level queried. Return Value integer(kind=I4P) Number of tree nodes at given level. private pure function parent_node (node) Return parent tree node. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: node Node queried. Return Value integer(kind=I4P) Parent tree node. Subroutines private elemental subroutine destroy (self) Destroy AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. private subroutine initialize (self, refinement_levels, facet, bmin, bmax) Initialize AABB tree. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: self AABB tree. integer(kind=I4P), intent(in) :: refinement_levels Total number of refinement levels used. type( facet_object ), intent(in), optional :: facet (:) Facets list. type(vector_R8P), intent(in), optional :: bmin Minimum point of AABB. type(vector_R8P), intent(in), optional :: bmax Maximum point of AABB. private subroutine save_geometry_tecplot_ascii (self, file_name) Save AABB tree boxes geometry into Tecplot ascii file. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: file_name File name. private subroutine save_into_file_stl (self, base_file_name, is_ascii) Save  AABB tree boxes facets into files STL. Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(in) :: self AABB tree. character(len=*), intent(in) :: base_file_name File name. logical, intent(in), optional :: is_ascii Sentinel to check if file is ASCII. private pure subroutine aabb_tree_assign_aabb_tree (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( aabb_tree_object ), intent(inout) :: lhs Left hand side. type( aabb_tree_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/fossil_aabb_tree_object.html","title":"fossil_aabb_tree_object – FOSSIL"},{"text":"Uses: fossil penf program~~fossil_test_load_save_binary~~UsesGraph program~fossil_test_load_save_binary fossil_test_load_save_binary module~fossil fossil module~fossil->program~fossil_test_load_save_binary penf penf penf->program~fossil_test_load_save_binary module~fossil_file_stl_object fossil_file_stl_object penf->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object penf->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils module~fossil_aabb_node_object fossil_aabb_node_object penf->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object vecfor vecfor vecfor->module~fossil_file_stl_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_load_save_binaryUsesGraph = svgPanZoom('#programfossil_test_load_save_binaryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test load and write binary file. Variables file_1 file_2 file_unit are_tests_passed Source Code fossil_test_load_save_binary Variables Type Attributes Name Initial type( file_stl_object ) :: file_1 STL file. type( file_stl_object ) :: file_2 STL file. integer :: file_unit File unit. logical :: are_tests_passed (8) Result of tests check. Source Code program fossil_test_load_save_binary !< FOSSIL, test load and write binary file. use fossil , only : file_stl_object use penf , only : R4P implicit none type ( file_stl_object ) :: file_1 !< STL file. type ( file_stl_object ) :: file_2 !< STL file. integer :: file_unit !< File unit. logical :: are_tests_passed ( 8 ) !< Result of tests check. are_tests_passed = . false . call file_1 % initialize ( file_name = 'src/tests/naca0012-binary.stl' , is_ascii = . false .) call file_1 % load_from_file are_tests_passed ( 1 ) = file_1 % facets_number == 188 are_tests_passed ( 2 ) = real ( file_1 % facet ( 5 )% vertex_2 % x , R4P ) == 0.683601_R4P are_tests_passed ( 3 ) = real ( file_1 % facet ( 5 )% vertex_2 % y , R4P ) == - 0.00763869_R4P are_tests_passed ( 4 ) = real ( file_1 % facet ( 5 )% vertex_2 % z , R4P ) == 0._R4P call file_1 % save_into_file ( file_name = 'fossil_test_load_save-naca0012-binary.stl' ) call file_2 % initialize ( file_name = 'fossil_test_load_save-naca0012-binary.stl' , is_ascii = . false .) call file_2 % load_from_file are_tests_passed ( 5 ) = file_2 % facets_number == 188 are_tests_passed ( 6 ) = real ( file_2 % facet ( 5 )% vertex_2 % x , R4P ) == 0.683601_R4P are_tests_passed ( 7 ) = real ( file_2 % facet ( 5 )% vertex_2 % y , R4P ) == - 0.00763869_R4P are_tests_passed ( 8 ) = real ( file_2 % facet ( 5 )% vertex_2 % z , R4P ) == 0._R4P print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) open ( newunit = file_unit , file = 'fossil_test_load_save-naca0012-binary.stl' ) close ( unit = file_unit , status = 'delete' ) endprogram fossil_test_load_save_binary","tags":"","loc":"program/fossil_test_load_save_binary.html","title":"fossil_test_load_save_binary – FOSSIL"},{"text":"Uses: flap fossil penf program~~fossil_test_sanitize_normals~~UsesGraph program~fossil_test_sanitize_normals fossil_test_sanitize_normals flap flap flap->program~fossil_test_sanitize_normals module~fossil fossil module~fossil->program~fossil_test_sanitize_normals penf penf penf->program~fossil_test_sanitize_normals module~fossil_file_stl_object fossil_file_stl_object penf->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object penf->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils module~fossil_aabb_node_object fossil_aabb_node_object penf->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object vecfor vecfor vecfor->module~fossil_file_stl_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_sanitize_normalsUsesGraph = svgPanZoom('#programfossil_test_sanitize_normalsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test normals sanitization . Calls program~~fossil_test_sanitize_normals~~CallsGraph program~fossil_test_sanitize_normals fossil_test_sanitize_normals proc~cli_parse cli_parse program~fossil_test_sanitize_normals->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl file_name_stl are_tests_passed Subroutines cli_parse Source Code fossil_test_sanitize_normals Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. character(len=999) :: file_name_stl Input STL file name. logical :: are_tests_passed (2) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_sanitize_normals !< FOSSIL, test normals *sanitization*. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) print * , 'volume before sanitize normals: ' , file_stl % volume are_tests_passed ( 1 ) = file_stl % volume < 0._R8P call file_stl % sanitize_normals call file_stl % compute_volume print * , 'volume after sanitize normals:  ' , file_stl % volume are_tests_passed ( 2 ) = nint ( file_stl % volume ) == 1 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_sanitize_normals' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_sanitize_normals --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube-inconsistent.stl' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse endprogram fossil_test_sanitize_normals","tags":"","loc":"program/fossil_test_sanitize_normals.html","title":"fossil_test_sanitize_normals – FOSSIL"},{"text":"Uses: flap fossil penf vecfor program~~fossil_test_translate~~UsesGraph program~fossil_test_translate fossil_test_translate flap flap flap->program~fossil_test_translate vecfor vecfor vecfor->program~fossil_test_translate module~fossil_file_stl_object fossil_file_stl_object vecfor->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object vecfor->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object vecfor->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object vecfor->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object vecfor->module~fossil_aabb_object module~fossil fossil module~fossil->program~fossil_test_translate penf penf penf->program~fossil_test_translate penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_translateUsesGraph = svgPanZoom('#programfossil_test_translateUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test translate STL. Calls program~~fossil_test_translate~~CallsGraph program~fossil_test_translate fossil_test_translate proc~cli_parse~2 cli_parse program~fossil_test_translate->proc~cli_parse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl file_name_stl delta x y z are_tests_passed Subroutines cli_parse Source Code fossil_test_translate Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. character(len=999) :: file_name_stl Input STL file name. type(vector_R8P) :: delta Vectorial delta. real(kind=R8P) :: x Scalar deltas. real(kind=R8P) :: y Scalar deltas. real(kind=R8P) :: z Scalar deltas. logical :: are_tests_passed (4) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_translate !< FOSSIL, test translate STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: delta !< Vectorial delta. real ( R8P ) :: x , y , z !< Scalar deltas. logical :: are_tests_passed ( 4 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % translate ( delta = delta ) call file_stl % save_into_file ( file_name = 'fossil_test_translate-delta.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( delta =- delta ) call file_stl % translate ( x = x ) are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( y = y ) are_tests_passed ( 3 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % translate ( z = z ) are_tests_passed ( 4 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 2 * ez_R8P )) == 0 call file_stl % save_into_file ( file_name = 'fossil_test_translate-xyz.stl' ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: delta_ ( 3 ) !< Vectorial delta. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_translate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_translate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--delta' , & help = 'vectorial delta' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'delta x' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'delta y' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'delta z' , & required = . false ., & def = '1.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--delta' , val = delta_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop delta % x = delta_ ( 1 ) delta % y = delta_ ( 2 ) delta % z = delta_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_translate","tags":"","loc":"program/fossil_test_translate.html","title":"fossil_test_translate – FOSSIL"},{"text":"Uses: flap fossil penf vecfor program~~fossil_test_distance~~UsesGraph program~fossil_test_distance fossil_test_distance flap flap flap->program~fossil_test_distance vecfor vecfor vecfor->program~fossil_test_distance module~fossil_file_stl_object fossil_file_stl_object vecfor->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object vecfor->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object vecfor->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object vecfor->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object vecfor->module~fossil_aabb_object module~fossil fossil module~fossil->program~fossil_test_distance penf penf penf->program~fossil_test_distance penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_distanceUsesGraph = svgPanZoom('#programfossil_test_distanceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test distance computation. Calls program~~fossil_test_distance~~CallsGraph program~fossil_test_distance fossil_test_distance proc~cli_parse~3 cli_parse program~fossil_test_distance->proc~cli_parse~3 str str program~fossil_test_distance->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl grid distance file_name_stl refinement_levels save_aabb_tree_geometry save_aabb_tree_stl test_brute_force sign_algorithm ni nj nk i j k Dx Dy Dz file_unit timing are_tests_passed Subroutines cli_parse Source Code fossil_test_distance Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. type(vector_R8P), allocatable :: grid (:,:,:) Grid. real(kind=R8P), allocatable :: distance (:,:,:) Distance of grid points to STL surface. character(len=999) :: file_name_stl Input STL file name. integer(kind=I4P) :: refinement_levels AABB refinement levels used. logical :: save_aabb_tree_geometry Sentinel to save AABB geometry. logical :: save_aabb_tree_stl Sentinel to save AABB stl. logical :: test_brute_force Sentinel to test also brute force. character(len=999) :: sign_algorithm Algorithm used for \"point in polyhedron\" test. integer(kind=I4P) :: ni Grid dimensions. integer(kind=I4P) :: nj Grid dimensions. integer(kind=I4P) :: nk Grid dimensions. integer(kind=I4P) :: i Counter. integer(kind=I4P) :: j Counter. integer(kind=I4P) :: k Counter. real(kind=R8P) :: Dx Space steps. real(kind=R8P) :: Dy Space steps. real(kind=R8P) :: Dz Space steps. integer(kind=I4P) :: file_unit File unit. integer(kind=I8P) :: timing (0:4) Tic toc timing. logical :: are_tests_passed (1) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_distance !< FOSSIL, test distance computation. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , I8P , R8P , str use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. type ( vector_R8P ), allocatable :: grid (:,:,:) !< Grid. real ( R8P ), allocatable :: distance (:,:,:) !< Distance of grid points to STL surface. character ( 999 ) :: file_name_stl !< Input STL file name. integer ( I4P ) :: refinement_levels !< AABB refinement levels used. logical :: save_aabb_tree_geometry !< Sentinel to save AABB geometry. logical :: save_aabb_tree_stl !< Sentinel to save AABB stl. logical :: test_brute_force !< Sentinel to test also brute force. character ( 999 ) :: sign_algorithm !< Algorithm used for \"point in polyhedron\" test. integer ( I4P ) :: ni , nj , nk !< Grid dimensions. integer ( I4P ) :: i , j , k !< Counter. real ( R8P ) :: Dx , Dy , Dz !< Space steps. integer ( I4P ) :: file_unit !< File unit. integer ( I8P ) :: timing ( 0 : 4 ) !< Tic toc timing. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % sanitize_normals print * , file_stl % statistics () call file_stl % create_aabb_tree ( refinement_levels = refinement_levels ) are_tests_passed = int ( file_stl % distance ( point = 0 * ex_R8P ), I4P ) == 0_I4P if ( save_aabb_tree_geometry ) call file_stl % aabb % save_geometry_tecplot_ascii ( file_name = 'fossil_test_distance_aabb_tree.dat' ) if ( save_aabb_tree_stl ) call file_stl % aabb % save_into_file_stl ( base_file_name = 'fossil_test_distance_' , is_ascii = . true .) associate ( bmin => file_stl % aabb % node ( 0 )% bmin (), bmax => file_stl % aabb % node ( 0 )% bmax ()) ni = 64 nj = 64 nk = 64 Dx = ( bmax % x - bmin % x ) / ni Dy = ( bmax % y - bmin % y ) / nj Dz = ( bmax % z - bmin % z ) / nk allocate ( grid ( - 4 : ni + 5 , - 4 : nj + 5 , - 4 : nk + 5 )) allocate ( distance ( - 4 : ni + 5 , - 4 : nj + 5 , - 4 : nk + 5 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 grid ( i , j , k ) = bmin + ( i * Dx ) * ex_R8P + ( j * Dy ) * ey_R8P + ( k * Dz ) * ez_R8P enddo enddo enddo endassociate if ( test_brute_force ) then file_stl % aabb % is_initialized = . false . print * , 'compute distances brute force' call system_clock ( timing ( 1 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 distance ( i , j , k ) = file_stl % distance ( point = grid ( i , j , k ), is_signed = . true ., sign_algorithm = trim ( sign_algorithm )) enddo enddo enddo call system_clock ( timing ( 2 ), timing ( 0 )) print * , 'brute force timing: ' , real ( timing ( 2 ) - timing ( 1 )) / timing ( 0 ) print * , 'save output' open ( newunit = file_unit , file = 'fossil_test_distance-brute.dat' ) write ( file_unit , '(A)' ) 'VARIABLES = x y z distance' write ( file_unit , '(A)' ) 'ZONE T=\"distance\", I=' // trim ( str ( ni + 10 )) // ', J=' // trim ( str ( nj + 10 )) // ', K=' // trim ( str ( nk + 10 )) // '' do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 write ( file_unit , '(A)' ) str ( grid ( i , j , k )% x ) // ' ' // str ( grid ( i , j , k )% y ) // ' ' // str ( grid ( i , j , k )% z ) // ' ' // str ( distance ( i , j , k )) enddo enddo enddo close ( file_unit ) endif file_stl % aabb % is_initialized = . true . print * , 'compute distances AABB' call system_clock ( timing ( 3 )) do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 distance ( i , j , k ) = file_stl % distance ( point = grid ( i , j , k ), is_signed = . true ., sign_algorithm = trim ( sign_algorithm )) enddo enddo enddo call system_clock ( timing ( 4 ), timing ( 0 )) print * , 'AABB timing: ' , real ( timing ( 4 ) - timing ( 3 )) / timing ( 0 ) print * , 'save output' open ( newunit = file_unit , file = 'fossil_test_distance-aabb.dat' ) write ( file_unit , '(A)' ) 'VARIABLES = x y z distance' write ( file_unit , '(A)' ) 'ZONE T=\"distance\", I=' // trim ( str ( ni + 10 )) // ', J=' // trim ( str ( nj + 10 )) // ', K=' // trim ( str ( nk + 10 )) // '' do k =- 4 , nk + 5 do j =- 4 , nj + 5 do i =- 4 , ni + 5 write ( file_unit , '(A)' ) str ( grid ( i , j , k )% x ) // ' ' // str ( grid ( i , j , k )% y ) // ' ' // str ( grid ( i , j , k )% z ) // ' ' // str ( distance ( i , j , k )) enddo enddo enddo close ( file_unit ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_distance' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_distance --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/naca0012-binary.stl' , & act = 'store' ) call cli % add ( switch = '--ref_levels' , & help = 'AABB refinement levels' , & required = . false ., & def = '2' , & act = 'store' ) call cli % add ( switch = '--save_aabb_tree_geometry' , & help = 'save AABB tree geometry' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--save_aabb_tree_stl' , & help = 'save AABB tree STL' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--brute_force' , & help = 'test (also) brute force' , & required = . false ., & def = '.false.' , & act = 'store_true' ) call cli % add ( switch = '--sign_algorithm' , & help = 'algorithm used to compute sign of distance' , & required = . false ., & def = 'ray_intersections' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ref_levels' , val = refinement_levels , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_geometry' , val = save_aabb_tree_geometry , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--save_aabb_tree_stl' , val = save_aabb_tree_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--brute_force' , val = test_brute_force , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--sign_algorithm' , val = sign_algorithm , error = error ) ; if ( error /= 0 ) stop endsubroutine cli_parse endprogram fossil_test_distance","tags":"","loc":"program/fossil_test_distance.html","title":"fossil_test_distance – FOSSIL"},{"text":"Uses: fossil penf program~~fossil_test_load_save_ascii~~UsesGraph program~fossil_test_load_save_ascii fossil_test_load_save_ascii module~fossil fossil module~fossil->program~fossil_test_load_save_ascii penf penf penf->program~fossil_test_load_save_ascii module~fossil_file_stl_object fossil_file_stl_object penf->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object penf->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils module~fossil_aabb_node_object fossil_aabb_node_object penf->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object vecfor vecfor vecfor->module~fossil_file_stl_object vecfor->module~fossil_facet_object vecfor->module~fossil_aabb_tree_object vecfor->module~fossil_aabb_node_object vecfor->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_load_save_asciiUsesGraph = svgPanZoom('#programfossil_test_load_save_asciiUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test load and write ASCII file. Variables file_1 file_2 file_unit are_tests_passed Source Code fossil_test_load_save_ascii Variables Type Attributes Name Initial type( file_stl_object ) :: file_1 STL file. type( file_stl_object ) :: file_2 STL file. integer :: file_unit File unit. logical :: are_tests_passed (8) Result of tests check. Source Code program fossil_test_load_save_ascii !< FOSSIL, test load and write ASCII file. use fossil , only : file_stl_object use penf , only : R8P implicit none type ( file_stl_object ) :: file_1 !< STL file. type ( file_stl_object ) :: file_2 !< STL file. integer :: file_unit !< File unit. logical :: are_tests_passed ( 8 ) !< Result of tests check. are_tests_passed = . false . call file_1 % initialize ( file_name = 'src/tests/naca0012-ascii.stl' , is_ascii = . true .) call file_1 % load_from_file are_tests_passed ( 1 ) = file_1 % facets_number == 188 are_tests_passed ( 2 ) = file_1 % facet ( 5 )% vertex_2 % x == 0.683601_R8P are_tests_passed ( 3 ) = file_1 % facet ( 5 )% vertex_2 % y == - 0.00763869_R8P are_tests_passed ( 4 ) = file_1 % facet ( 5 )% vertex_2 % z == 0._R8P call file_1 % save_into_file ( file_name = 'fossil_test_load_save-naca0012-ascii.stl' ) call file_2 % initialize ( file_name = 'fossil_test_load_save-naca0012-ascii.stl' , is_ascii = . true .) call file_2 % load_from_file are_tests_passed ( 5 ) = file_2 % facets_number == 188 are_tests_passed ( 6 ) = file_2 % facet ( 5 )% vertex_2 % x == 0.683601_R8P are_tests_passed ( 7 ) = file_2 % facet ( 5 )% vertex_2 % y == - 0.00763869_R8P are_tests_passed ( 8 ) = file_2 % facet ( 5 )% vertex_2 % z == 0._R8P print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) open ( newunit = file_unit , file = 'fossil_test_load_save-naca0012-ascii.stl' ) close ( unit = file_unit , status = 'delete' ) endprogram fossil_test_load_save_ascii","tags":"","loc":"program/fossil_test_load_save_ascii.html","title":"fossil_test_load_save_ascii – FOSSIL"},{"text":"Uses: flap fossil penf vecfor program~~fossil_test_mirror~~UsesGraph program~fossil_test_mirror fossil_test_mirror flap flap flap->program~fossil_test_mirror vecfor vecfor vecfor->program~fossil_test_mirror module~fossil_file_stl_object fossil_file_stl_object vecfor->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object vecfor->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object vecfor->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object vecfor->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object vecfor->module~fossil_aabb_object module~fossil fossil module~fossil->program~fossil_test_mirror penf penf penf->program~fossil_test_mirror penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_mirrorUsesGraph = svgPanZoom('#programfossil_test_mirrorUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test mirror STL. Calls program~~fossil_test_mirror~~CallsGraph program~fossil_test_mirror fossil_test_mirror proc~cli_parse~4 cli_parse program~fossil_test_mirror->proc~cli_parse~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl file_name_stl normal are_tests_passed Subroutines cli_parse Source Code fossil_test_mirror Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. character(len=999) :: file_name_stl Input STL file name. type(vector_R8P) :: normal Normal of mirroring plane. logical :: are_tests_passed (2) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_mirror !< FOSSIL, test mirror STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: normal !< Normal of mirroring plane. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) print '(A)' , file_stl % statistics () call file_stl % mirror ( normal = normal ) call file_stl % save_into_file ( file_name = 'fossil_test_mirror.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 0 * ex_R8P - 1 * ey_R8P + 1 * ez_R8P )) == 1 are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 1 * ex_R8P - 1 * ey_R8P + 0 * ez_R8P )) == 1 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: normal_ ( 3 ) !< Normal of mirroring plane. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_mirror' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_mirror --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--normal' , & help = 'normal of mirroring plane' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--normal' , val = normal_ , error = error ) ; if ( error /= 0 ) stop normal % x = normal_ ( 1 ) normal % y = normal_ ( 2 ) normal % z = normal_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_mirror","tags":"","loc":"program/fossil_test_mirror.html","title":"fossil_test_mirror – FOSSIL"},{"text":"Uses: flap fossil penf vecfor program~~fossil_test_resize~~UsesGraph program~fossil_test_resize fossil_test_resize flap flap flap->program~fossil_test_resize vecfor vecfor vecfor->program~fossil_test_resize module~fossil_file_stl_object fossil_file_stl_object vecfor->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object vecfor->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object vecfor->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object vecfor->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object vecfor->module~fossil_aabb_object module~fossil fossil module~fossil->program~fossil_test_resize penf penf penf->program~fossil_test_resize penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_resizeUsesGraph = svgPanZoom('#programfossil_test_resizeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test resize STL. Calls program~~fossil_test_resize~~CallsGraph program~fossil_test_resize fossil_test_resize proc~cli_parse~5 cli_parse program~fossil_test_resize->proc~cli_parse~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl file_name_stl factor x y z are_tests_passed Subroutines cli_parse Source Code fossil_test_resize Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. character(len=999) :: file_name_stl Input STL file name. type(vector_R8P) :: factor Vectorial factor. real(kind=R8P) :: x Scalar factors. real(kind=R8P) :: y Scalar factors. real(kind=R8P) :: z Scalar factors. logical :: are_tests_passed (4) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_resize !< FOSSIL, test resize STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: factor !< Vectorial factor. real ( R8P ) :: x , y , z !< Scalar factors. logical :: are_tests_passed ( 4 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % resize ( factor = factor ) call file_stl % save_into_file ( file_name = 'fossil_test_resize-factor.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( factor = factor / 4._R8P ) call file_stl % resize ( x = x ) are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 0 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( y = y ) are_tests_passed ( 3 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 0 * ez_R8P )) == 0 call file_stl % resize ( z = z ) are_tests_passed ( 4 ) = nint ( file_stl % distance ( point = 2 * ex_R8P + 2 * ey_R8P + 2 * ez_R8P )) == 0 call file_stl % save_into_file ( file_name = 'fossil_test_resize-xyz.stl' ) print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: factor_ ( 3 ) !< Vectorial factor. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_resize' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_resize --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--factor' , & help = 'vectorial factor' , & required = . false ., & nargs = '+' , & def = '2.0 2.0 2.0' , & act = 'store' ) call cli % add ( switch = '--x' , & help = 'factor x' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--y' , & help = 'factor y' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % add ( switch = '--z' , & help = 'factor z' , & required = . false ., & def = '2.0' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--factor' , val = factor_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--x' , val = x , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--y' , val = y , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--z' , val = z , error = error ) ; if ( error /= 0 ) stop factor % x = factor_ ( 1 ) factor % y = factor_ ( 2 ) factor % z = factor_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_resize","tags":"","loc":"program/fossil_test_resize.html","title":"fossil_test_resize – FOSSIL"},{"text":"Uses: flap fossil penf vecfor program~~fossil_test_rotate~~UsesGraph program~fossil_test_rotate fossil_test_rotate flap flap flap->program~fossil_test_rotate vecfor vecfor vecfor->program~fossil_test_rotate module~fossil_file_stl_object fossil_file_stl_object vecfor->module~fossil_file_stl_object module~fossil_facet_object fossil_facet_object vecfor->module~fossil_facet_object module~fossil_aabb_tree_object fossil_aabb_tree_object vecfor->module~fossil_aabb_tree_object module~fossil_aabb_node_object fossil_aabb_node_object vecfor->module~fossil_aabb_node_object module~fossil_aabb_object fossil_aabb_object vecfor->module~fossil_aabb_object module~fossil fossil module~fossil->program~fossil_test_rotate penf penf penf->program~fossil_test_rotate penf->module~fossil_file_stl_object penf->module~fossil_facet_object penf->module~fossil_aabb_tree_object module~fossil_utils fossil_utils penf->module~fossil_utils penf->module~fossil_aabb_node_object penf->module~fossil_aabb_object module~fossil_file_stl_object->module~fossil module~fossil_facet_object->module~fossil module~fossil_facet_object->module~fossil_file_stl_object module~fossil_facet_object->module~fossil_aabb_tree_object module~fossil_facet_object->module~fossil_aabb_node_object module~fossil_facet_object->module~fossil_aabb_object module~fossil_aabb_tree_object->module~fossil_file_stl_object module~fossil_utils->module~fossil_file_stl_object module~fossil_utils->module~fossil_facet_object module~fossil_utils->module~fossil_aabb_object iso_fortran_env iso_fortran_env iso_fortran_env->module~fossil_file_stl_object iso_fortran_env->module~fossil_facet_object iso_fortran_env->module~fossil_aabb_tree_object iso_fortran_env->module~fossil_aabb_node_object iso_fortran_env->module~fossil_aabb_object module~fossil_aabb_node_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_tree_object module~fossil_aabb_object->module~fossil_aabb_node_object var panprogramfossil_test_rotateUsesGraph = svgPanZoom('#programfossil_test_rotateUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOSSIL, test rotate STL. Calls program~~fossil_test_rotate~~CallsGraph program~fossil_test_rotate fossil_test_rotate proc~cli_parse~6 cli_parse program~fossil_test_rotate->proc~cli_parse~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables file_stl file_name_stl axis angle are_tests_passed Subroutines cli_parse Source Code fossil_test_rotate Variables Type Attributes Name Initial type( file_stl_object ) :: file_stl STL file. character(len=999) :: file_name_stl Input STL file name. type(vector_R8P) :: axis Axis of rotation. real(kind=R8P) :: angle Angle of rotation. logical :: are_tests_passed (2) Result of tests check. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program fossil_test_rotate !< FOSSIL, test rotate STL. use flap , only : command_line_interface use fossil , only : file_stl_object use penf , only : I4P , R8P use vecfor , only : ex_R8P , ey_R8P , ez_R8P , vector_R8P implicit none type ( file_stl_object ) :: file_stl !< STL file. character ( 999 ) :: file_name_stl !< Input STL file name. type ( vector_R8P ) :: axis !< Axis of rotation. real ( R8P ) :: angle !< Angle of rotation. logical :: are_tests_passed ( 2 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call file_stl % initialize ( file_name = trim ( adjustl ( file_name_stl ))) call file_stl % load_from_file ( guess_format = . true .) call file_stl % rotate ( axis = axis , angle = angle ) call file_stl % save_into_file ( file_name = 'fossil_test_rotate.stl' ) are_tests_passed ( 1 ) = nint ( file_stl % distance ( point = 0 * ex_R8P - 1 * ey_R8P + 1 * ez_R8P )) == 0 are_tests_passed ( 2 ) = nint ( file_stl % distance ( point = 1 * ex_R8P - 1 * ey_R8P + 0 * ez_R8P )) == 0 print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. real ( R8P ) :: axis_ ( 3 ) !< Axis of rotation. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'fossil_test_rotate' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"fossil_test_rotate --stl src/tests/dragon.stl\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--stl' , & help = 'STL (input) file name' , & required = . false ., & def = 'src/tests/cube.stl' , & act = 'store' ) call cli % add ( switch = '--axis' , & help = 'axis of rotation' , & required = . false ., & nargs = '+' , & def = '1.0 0.0 0.0' , & act = 'store' ) call cli % add ( switch = '--angle' , & help = 'angle of rotation' , & required = . false ., & def = '1.57079633' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--stl' , val = file_name_stl , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--axis' , val = axis_ , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--angle' , val = angle , error = error ) ; if ( error /= 0 ) stop axis % x = axis_ ( 1 ) axis % y = axis_ ( 2 ) axis % z = axis_ ( 3 ) endsubroutine cli_parse endprogram fossil_test_rotate","tags":"","loc":"program/fossil_test_rotate.html","title":"fossil_test_rotate – FOSSIL"}]}